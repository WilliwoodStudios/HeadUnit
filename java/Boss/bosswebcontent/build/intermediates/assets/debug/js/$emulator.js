/* [Copyright (c) 2015 Workshop 12 Inc.] $emulator VERSION: 1.0.0.4028*/

/**
 * $ui provides an extendible out of the box UI framework which provides a pre-defined user experience.
 * The main object that is used for creating this framework is the <b>$ui</b> object.
 * @namespace $ui
 * @property {$ui.CoreScreen[]} screens - The screen stack of currently loaded screens
 * @property {$ui.CoreScreen} topMostScreen - The screen that is currently on the top of the stack
 * @property {UIEvent} oninteraction - Assign this property to a callback function which you desire to handle any interaction logging from UI controls.  This is intended to provide a single point of filtering
 * of user interactions to be used with an analytics engine
 */
var $ui = {
	// Protected variables which should not be directly accessed from outside the toolkit
	_protected: {
		PROPERTY_WARNING: 'WARNING: Property "[prop]" cannot be dynamically updated',
		screens : [],  // Contains all of the current screens on the stack;
		definitions: [], // Contains all of the component definitions
		extensions: [], // Contains all of the extension functions to be called
		inScreenTransition: false,
		theme: {}, // This contains our core theme information
		events: [],
		pushQueue: []
	},
	
	/**
	 * Standard Sizing used in the toolkit
	 * @namespace Size
	 * @readonly
	 * @memberof $ui
	 */ 
	Size: {
		/** Largest possible size */
		HUGE: 'huge',
		/** Larger than normal size */
		LARGE: 'large',
		/** Normal default size */
		NORMAL: 'normal',
		/** Smaller than normal size */
		SMALL: 'small',
		/** Smallest possible size */
		TINY: 'tiny',
		/** Fill the space available */
		FILL: 'fill'
	},
	
	/**
	 * Type of extension to be used for extending the <b>$ui</b> framework when using a {@link UIExtension}
	 * @namespace UIExtensionType
	 * @readonly
	 * @memberof $ui
	 */
	UIExtensionType: {
		/** Extension is a control */
		CONTROL: 0,
		/** Extension is a new type of screen */
		SCREEN: 1,
		/** Extension is a new type of list item */
		LISTITEM: 2,
    /** Extension is a new type of attached object */
		ATTACHED_OBJECT: 3
	},
	
	/** 
	 * This function will initialize the toolkit and create the first screen provided by the screen parameter.
	 * @param {$ui.CoreScreen} screen - Initial screen to open
	 * @param {$ui.InitOptions} theme - Theme to use for the toolkit
	 */
	init: function(screen, options) {	
		this._protected.options = options;
    // Apply any theme settings
		if (options && options.theme) {
			this._applyTheme(options.theme);
		} else {
			console.log('WARNING: Theme has not been defined');
		}
		// before push the initial page, add _blockAllTapEvent function to body
		document.body._blockAllTapEvent = function(e) {
			e.preventDefault();
			e.stopPropagation();
		}.$bind(document.body);
		// Handle fast clicks in mobile browsers
		FastClick.attach(document.body);
		// Run all our registered extensions
		for (var i = 0; i < this._protected.extensions.length; i++) {
			this._protected.extensions[i](); // Call the extension
		}
		// Push the first screen
		this.push(screen);
		// Handle window resize
		window.addEventListener('resize', function() {
			// Fire any screen resize events needed
			var i, 
				screen;
			for (i = 0; i < $ui.screens.length; i++) {
				screen = $ui.screens[i];
				// Run internal resize
				if (screen._onresize) {
					screen._onresize();
				}
				// Fire the screen's public event
				if (screen.onresize) {
					screen.onresize();
				}
			}
		}, false);
	},

	/**
	 * Initialize the toolkit in a minimalistic way for test purposes ONLY
	 * @param screen - screen to render
	 * @param options
	 */
	test_init: function(screen, options) {
		this._protected.options = options;
		// Apply any theme settings
		if (options && options.theme) {
			this._applyTheme(options.theme);
		}
		// before push the initial page, add _blockAllTapEvent function to body
		document.body._blockAllTapEvent = function(e) {};
		// Run all our registered extensions
		for (var i = 0; i < this._protected.extensions.length; i++) {
			this._protected.extensions[i](); // Call the extension
		}
		this.push(screen);
	},

	/**
	 * You are able to register your $ui extensions by calling the extend function and providing it a callback function to fire when $ui is ready to
	 * load its extensions.  This function should be called before you call the $ui.init() function.  Within the callback function you will call the $ui.addExtension() functions
	 * to load your custom extensions
	 * @param {function} callback - Function to fire when $ui is ready for its extensions to be loaded
	 */
	extend: function(callback) {
		if (callback) {
			this._protected.extensions.push(callback);
		}
	},
			
	/** 
	 * You are able to extend the UI framework by registering your own control extensions. You must first register your extension with the framework by calling this function.
	 * @param {$ui.UIExtension} extension - Extension object to be added to the framework
	 */
	addExtension: function(extension) {
		if (extension.type == undefined) extension.type = $ui.UIExtensionType.CONTROL;
		if (extension.definition == undefined) extension.definition = {};
		$ui[extension.name] = extension.definition;
		extension.component = $ui[extension.name];
		if (extension.type == undefined) extension.type = $ui.UIExtensionType.CONTROL;
		this._protected.definitions.push(extension);
	},	
	
	
	// Internal function to raises an event for a user interaction
	_raiseInteractionEvent: function(event) {
		if (this.oninteraction == undefined) return;
		if (event == undefined || event == null) return;
		if (event.screenId == undefined || event.screenId == null) return;
		if (event.controlId == undefined || event.controlId == null) return;
		if (event.interaction == undefined || event.interaction == null) return;
		var interactionHandler = this.oninteraction;
		setTimeout(function() {
			interactionHandler(event);
		},0);
	},
	
	
	/** 
	 * Create any control that is passed in and return the DOM.  This should only be called internally by control extensions
	 * @param {object} control - Object definition of the control to create
	 * @param {$ui.CoreScreen} screen - The screen to which the control belongs
	 */
	createControl: function(control, screen) {
		if (control == undefined) {
			throw '$ui.createControl: "control" is not defined';
		} 
		if (screen == undefined) {
			throw '$ui.createControl: "screen" is not defined';
		}
		// Find and create the component
		var i,
			extension,
			controlDom = undefined;
		for (i = 0; i < this._protected.definitions.length; i++) {
			extension = this._protected.definitions[i];
			if (extension.type != $ui.UIExtensionType.CONTROL) continue;
			if (extension.component == control.component) {
				controlDom = new extension.constructor(control,screen);
				break;
			}
		}
		return controlDom;
	},

	/** 
	 *  Check to see if this is a mobile device
	 */
	isMobileDevice: function() {
		var check = false;
		(function(a,b){if(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|android|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0,4)))check = true})(navigator.userAgent||navigator.vendor||window.opera);
		return check;
	},

	// Private function to block all tap/click events during animations
	_blockAllTapEvent: function(value) {
		if(value == undefined) return;
		if(value === true) {
			document.body.addEventListener('click', document.body._blockAllTapEvent, true);
			document.body.addEventListener('touchstart', document.body._blockAllTapEvent, true);
		} else if (value === false) {
			document.body.removeEventListener('click', document.body._blockAllTapEvent, true);
			document.body.removeEventListener('touchstart', document.body._blockAllTapEvent, true);
		}
	},
	
	/** 
	 * This function will push a new screen on the stack and pass the optional data provided as a parameter to that screen's onshow() event.
	 * @param {$ui.CoreScreen} screen - Screen to open and push onto the top of the screen stack
	 * @param {object} data - Data to pass to the new screen that is opened
	 * @param {ScreenOptions} [options] - Optional options for this screen push
	 */
	push: function(screen, data, options) {
		if ($ui._protected.inScreenTransition === true) {
			this._protected.pushQueue.push({screen: screen, data: data, options: options});
			setTimeout(this._clearPushQueue, 100);
		} else {
			this._executePush(screen, data, options);
		}
	},
	
	// Clears out the push queue of screens one by one
	_clearPushQueue: function() {
		if ($ui._protected.inScreenTransition === true) {
			setTimeout($ui._clearPushQueue, 100);
			return;
		}
		if ($ui._protected.pushQueue.length == 0) return;
		item = $ui._protected.pushQueue[0];
		$ui._protected.pushQueue.splice(0,1);
		$ui._executePush(item.screen, item.data, item.options);
	},
	
	// Excute the screen push
	_executePush: function(screen, data, options) {
		screen = new screen();
		var screenVisible = (options == undefined) ? true : (options.visible != false);
		// Check to see if this screen has an oncreate event that needs to be run before
		// it is processed
		if (screen.oncreate) {
			screen.oncreate(data);
		}
		// Find and create the screen
		var dom,
			i,
			extension;
		for (i = 0; i < this._protected.definitions.length; i++) {
			extension = this._protected.definitions[i];
			if (extension.type != $ui.UIExtensionType.SCREEN) continue;
			if (extension.component == screen.component) {
				dom = new extension.constructor(screen,data);
				break;
			}
		}
		if (dom == undefined) return;
		$ui._blockAllTapEvent(true);
		$ui._protected.inScreenTransition = true;
		$ui.screens.push(screen);
		if (screenVisible == false) {
			dom.style.visibility = 'hidden';
			screen._protected.initialVisibility = false;
		}
		document.body.appendChild(dom);
		
		// Initialize our new screen
		if (screen.animated == true && screenVisible == true) {
			screen._numScreensToClose = (options != undefined) ? options.numScreensToClose : undefined;
			// Raise our onshow event when the animation ends
			screen.dom.pushAnimationEnd = function(e) {
				if (e.target == this.model.dom){
					this.removeEventListener('webkitAnimationEnd', this.pushAnimationEnd); // Webkit
          this.removeEventListener('animationend', this.pushAnimationEnd); 
					this.style['-webkit-animation-name'] = 'none'; // webkit browsers
          this.style['animation-name'] = 'none';
					// Close any underlying screens if necessary
					$ui._popBelowTop(this.model._numScreensToClose);
					// Change temporary visibility of below screens
					var i,
						stackScreen;
					for (i = 0; i < $ui._protected.screens.length; i++) {
						stackScreen = $ui._protected.screens[i];
						if (stackScreen._protected.initialVisibility == false) {
							stackScreen.dom.style.visibility = '';
							stackScreen._protected.initialVisibility = undefined;
						}
					}
					// Hide the screen below
					var length = $ui._protected.screens.length;
					if (length > 1 && screen.floatOnTop == false) {
						$ui._protected.screens[length-2].dom.style.display = 'none';
					}
					this.model.initialize();
				}
			};
			screen.dom.pushAnimationEnd = screen.dom.pushAnimationEnd.$bind(screen.dom);
			screen.dom.addEventListener('webkitAnimationEnd', screen.dom.pushAnimationEnd, false); // Webkit
      screen.dom.addEventListener('animationend', screen.dom.pushAnimationEnd, false); 
		} else {
			// Close any underlying screens if necessary
			if (options) {
				$ui._popBelowTop(options.numScreensToClose);
			}
			// Change temporary visibility of below screens
			if (screenVisible == true) {
				var stackScreen;
				for (i = 0; i < $ui._protected.screens.length; i++) {
					stackScreen = $ui._protected.screens[i];
					if (stackScreen._protected.initialVisibility == false) {
						stackScreen.dom.style.visibility = '';
						stackScreen._protected.initialVisibility = undefined;
					}
				}
			}
			// Hide the screen below
			var length = $ui._protected.screens.length;
			if (length > 1 && screen.floatOnTop == false) {
				$ui._protected.screens[length-2].dom.style.display = 'none';
			}
			screen.initialize();
		}
	},
	
	// This functions will pop of screens below the top screen.  The number of screens to pop off is supplied by the parameter "number"
	_popBelowTop: function(number) {
		if (number != undefined && number > 0) {
			// Make sure there is a screen beneath this new one
			if ($ui.screens.length-2 > -1) {
				var i,
					count = 0,
					screen;
				// Loop until we have no more screens or if the number of screens removed matches the number provided
				for (i = $ui.screens.length - 2; (i > -1) && (count < number); i--) {
					screen = $ui.screens[i];
					if (screen.onbeforepop) {
						screen.onbeforepop();
					}
					$ui._removeScreen(screen);
					count++;
				}
			}
		}
	},
	
	/** 
	 * Pop all the screens off until you get to the screen specified by the parameter
	 * @param {$ui.CoreScreen} screen - Screen to display after the popping
	 */
	popUntil: function(screen) {
		var index = this._protected.screens.indexOf(screen);
		if (index == this._protected.screens.length - 1) return; // Screen is the topmost screen
		if (index >= 0) {
			this.pop(this._protected.screens.length - (index + 1));
		}
	},
	
	/** 
	 * To close the top-most screen on the stack you can call the pop() function.
	 * @param {number} [numToPop=1] - This optional parameter allows you to specify the number of screens to pop off of the stack
	 */
	pop: function(numToPop) {
		if ($ui.screens.length == 0) return;
		// Return if the screen is in transition.
		if ($ui._protected.inScreenTransition === true) {
			setTimeout(function() {
				$ui.pop(numToPop);
			}, 100);
		} else {
			$ui._blockAllTapEvent(true);
			$ui._protected.inScreenTransition = true;
			
			// First remove screens below the topmost
			$ui._popBelowTop(numToPop - 1);
			
			// Hide the screen below
			var length = $ui._protected.screens.length;
			if (length > 1) {
				$ui._protected.screens[length-2].dom.style.display = 'block';
			}
			
			// Remove the top most screen
			var screen = $ui.screens[$ui.screens.length-1];
			if (screen.animated == true) {
				screen.dom.addEventListener('webkitAnimationEnd', function(e) {
					$ui._removeScreen(this.model);
				}, false);
        screen.dom.addEventListener('animationend', function(e) {
					$ui._removeScreen(this.model);
				}, false);
				// Call this so that the screen has a chance to set its animation
				if (screen.onbeforepop) {
					screen.onbeforepop();
				}
			} else {
				if (screen.onbeforepop) {
					screen.onbeforepop();
				}
				$ui._removeScreen(screen);
			} 
		}
	},

	// Remove a screen from the stack
	_removeScreen: function(screen) {
    try
    {
      screen.dom.style.display = 'none';
      document.body.removeChild(screen.dom);
      screen.destroy();
      // Remove any event listeners
      var i,
        event;
      for (i = this._protected.events.length - 1; i >= 0; i--) {
        event = this._protected.events[i];
        if (event.screen == screen) {
          event.id = undefined;
          event.callback = undefined;
          event.screen = undefined;
          this._protected.events.splice(i, 1);
        }
      }
    } catch (ex) {
      console.log(ex);
    }
		// Handle finalization
		$ui._protected.inScreenTransition = false;
		$ui._blockAllTapEvent(false);
		var index = $ui.screens.indexOf(screen);
		$ui.screens.splice(index, 1);
	},

 
	/** 
	 * Determines if an element has the class specified in it's class name.  This should only be called internally by extension controls
	 * @param {DOMElement} element - DOM element to be examined
	 * @param {string} name - The class name to look for
	 */
	hasClass: function(element, name){
		if (element == undefined || element == null) return false;
		var re = new RegExp('(^| )' + name + '( |$)');
		return re.test(element.className);
	},
	
	/** 
	 * Adds a class name to an element.  This should only be called internally by extension controls
	 * @param {DOMElement} element - DOM element to be modified
	 * @param {string} name - The class name to add to the element
	 */
	addClass: function(element, name){
		if (element == undefined || element == null) return;
		if (!$ui.hasClass(element, name)){
			if (element.className) {
				element.className += ' ' + name;
			} else {
				element.className = name;
			}
		}
	},
	
	/** 
	 * Removes a class from an element.  This should only be called internally by extension controls
	 * @param {DOMElement} element - DOM element to be modified
	 * @param {string} name - The class name to remove
	 */
	removeClass: function(element, name){
		if (element == undefined || element == null) return;
		var re = new RegExp('(^| )' + name + '( |$)');
		element.className = element.className.replace(re, ' ').replace(/^\s+|\s+$/g, "");
	},
	
	/**
	* Convert a HEX color value to an RGB object. This will return an object with properties R, G and B
	* @function hexToRgb
	* @memberof $ui
	* @param {string} value - The HEX string value to convert to RGB
	*/
	hexToRgb: function(value) {
		if (value == undefined || value == null) return {};
		function cutHex(h) {
			return (h.charAt(0)=="#") ? h.substring(1,7):h
		}
		// convert the color
		var R = parseInt((cutHex(value)).substring(0,2),16),
			G = parseInt((cutHex(value)).substring(2,4),16),
			B = parseInt((cutHex(value)).substring(4,6),16);
		return { R: R, G: G, B: B};
	},
  
  /**
	* Parse a CSS RGB string value to an RGB object. This will return an object with properties R, G and B
	* @function parseRgb
	* @memberof $ui
	* @param {string} value - The RGB string value to convert to RGB
	*/
	parseRgb: function(value) {
		if (value == undefined || value == null) return {};
    var R,
      G,
      B;
    // Handle rgb(redValue, greenValue, blueValue) format
    if (value[0]=='r')
    {
      // Find the index of the redValue.  Using subscring function to 
      // get rid off "rgb(" and ")" part.  
      // The indexOf function returns the index of the "(" and ")" which we 
      // then use to get inner content.  
      value=value.substring(value.indexOf('(')+1, value.indexOf(')'));
      // Notice here that we don't know how many digits are in each value,
      // but we know that every value is separated by a comma.
      // So split the three values using comma as the separator.
      // The split function returns an object.
      var rgbColors=value.split(',', 3);
      // Convert redValue to integer
      R=parseInt(rgbColors[0]);
      // Convert greenValue to integer
      G=parseInt(rgbColors[1]);
      // Convert blueValue to integer
      B=parseInt(rgbColors[2]);	
      return { R: R, G: G, B: B};
    } else {
      return {};
    }
	},
	
	/**
	* Generate a unique identifier
	*/
	guid: function() {
	   function guidS4() {
		   return (((1 + Math.random()) * 0x10000)|0).toString(16).substring(1);
		}
	   return (guidS4() + guidS4() + "-" + guidS4() + "-" + guidS4() + "-" + guidS4() + "-" + guidS4() + guidS4() + guidS4());
	},
	
	// Internal function for applying a theme
	_applyTheme: function(value) {
		this._protected.options.theme = value;
		if (value == undefined) return;
		var styleElement = document.createElement('style');
		styleElement.setAttribute('type','text/css');
		if (this._protected.themeStyleElement != undefined) {
			document.head.removeChild(this._protected.themeStyleElement);
		} 
		this._protected.themeStyleElement = styleElement;
		// Replaces variables with their values
		function replaceVariables(text, variables) {
			if (variables == undefined || variables.length == 0) return text;
			var i,
				result = text,
				variable;
			for (i = 0; i < variables.length; i++) {
				variable = variables[i];
				result = result.replace(variable.name, variable.value);
			}
			return result;
		}
		// Process any defined classes
		if (this.theme.classList) {
			var i, j,
				item,
				property,
				content = '';
			for (i = 0; i < this.theme.classList.length; i++) {
				item = this.theme.classList[i];
				content += item.className + '{';
				for (j = 0; j < item.properties.length; j++) {
					property = item.properties[j];
					content += property.name + ': ' + replaceVariables(property.value,this.theme.variables)+';';
				}
				content += '}\n';
			}
			styleElement.innerHTML = content;
		}
		document.head.appendChild(styleElement);
	},
	
	/** 
	 * This function will return the first screen found in the screen stack that has an id that matches the id parameter
	 * @function getScreenById
	 * @memberof $ui
	 * @param {string} id - Id of the screen to find
	 * @returns {$ui.CoreScreen}
	 */
	getScreenById: function(id) {
		if (this._protected.screens.length == 0) return undefined;
		var i,
			screen;
		for (i = 0; i < this._protected.screens.length; i++) {
			screen = this._protected.screens[i];
			if (screen.id == id) {
				return screen;
			}
		}
		return undefined;
	 },
	
	/** 
	 * This function will assign a listener for any event raised in the system that matches the supplied <b>event</b> parameter.  Then the subscribed to event occurs the 
	 * callback will be fired
	 * @function addEventListenter
	 * @memberof $ui
	 * @param {number} event - The numeric ID representing the event to listen for
	 * @param {TriggeredEvent} callback - The callback function to be fired when the subscribed to event occurs
	 * @param {$ui.CoreScreen} [screen] - The screen that this event listener belongs to
	 */
	 addEventListener: function(id, callback, screen) {
		 if (id == undefined) {
			 console.log('The "id" parameter cannot be undefined for addEventListener');
			 return;
		 }
		 if (callback == undefined) {
			 console.log('The "callback" parameter cannot be undefined for addEventListener');
			 return;
		 }
		 var entry = {
			 id: id,
			 callback: callback,
			 screen: screen
		 };
		 this._protected.events.push(entry);
	 },
	 
	 /** 
	 * This function will remove the listener for any event that matches the supplied <b>id</b> and <b>event</b> parameter.  
	 * @function removeEventListenter
	 * @memberof $ui
	 * @param {number} event - The numeric ID representing the event to remove
	 * @param {TriggeredEvent} callback - The callback function to be removed
	 */
	 removeEventListener: function(id, callback) {
		 var i,
			entry;
		for (i = this._protected.events.length - 1; i >= 0; i--) {
			entry = this._protected.events[i];
			if ((entry.id == id) && (entry.callback == callback)) {
				entry.id = undefined;
				entry.callback = undefined;
				entry.screen = undefined;
				this._protected.events.splice(i, 1);
			}
		}
	 },
	 
	 /** 
	 * This function will raise the supplied event and trigger any matching listeners
	 * @function raiseEvent
	 * @memberof $ui
	 * @param {$ui.DataEvent} event - The event to be raised
	 */
	 raiseEvent: function(event) {
		this._protected.events.forEach(function(entry) {
			if (entry.id == event.id && entry.callback) {
				setTimeout(function() {
					entry.callback(event);
				},0);
			}
		});
	 }
}

// Screen property handling
Object.defineProperty($ui, 'screens', {
	get: function() {return this._protected.screens;},
	set: function() {
		console.log(this._protected.PROPERTY_WARNING.replace('[prop]','screens'));
	},
	configurable: false}
);

// topMostScreen property handling
Object.defineProperty($ui, 'topMostScreen', {
	get: function() {
		if (this._protected.screens.length == 0) return undefined;
		return this._protected.screens[this._protected.screens.length -1];
	},
	set: function() {
		console.log(this._protected.PROPERTY_WARNING.replace('[prop]','topMostScreen'));
	},
	configurable: false}
);

// Theme property
Object.defineProperty($ui, 'theme', {
	get: function() {return this._protected.options.theme;},
	set: function(value) {
		this._applyTheme(value);
		// Raise the event to all of the screens
		var i,
			screen;
		for (i = 0; i < this._protected.screens.length; i++) {
			screen = this._protected.screens[i];
			if (screen._onthemechange) {
				screen._onthemechange();
			}
		}
	},
	configurable: false}
);

// options property
Object.defineProperty($ui, 'options', {
	get: function() {return this._protected.options;},
	set: function() {
		console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','options'));
	},
	configurable: false}
);

// This function is called as part of the extension registration
function $ui_RegisterRootExtensions() {
	// Register our extensions
	$ui.addExtension(new UIExtension('List', $ui_List));
	def = {
			/**
			 * Color of {@link $ui.Spinner} control
			 * @namespace
			 * @readonly
			 * @memberof $ui.Spinner
			 */
			SpinnerColor: {
				/** Light spinner Color */
				LIGHT: 'light',
				/** Dark spinner color */
				DARK: 'dark'
			}
		};
	$ui.addExtension(new UIExtension('Spinner', $ui_Spinner, undefined,def));
	def = {
		  /**
		 * Type of error related to retrieving information via a {@link $ui.DataProvider} 
		 * @namespace
		 * @readonly
		 * @memberof $ui.DataProvider
		 */
		ProviderError: {
			/** Head unit does not have a network connection */
			OFFLINE: -1,
			/** Data returned was invalid JSON */
			INVALID_JSON: -2,
			/** Network timed out */
			TIMEOUT: -3,
			/** Access to url denied */
			ACCESS_DENIED: -4,
			/** Invalid URL location */
			NOT_FOUND: -5
		}
	};
	$ui.addExtension(new UIExtension('DataProvider', $ui_DataProvider, $ui.UIExtensionType.ATTACHED_OBJECT, def));
}


Function.prototype.$bind = function(object){ 
  var fn = this; 
  return function(){ 
    return fn.apply(object, arguments); 
  }; 
}; 

// Register our root extensions
$ui.extend($ui_RegisterRootExtensions);

/**
 * General event that fires without any parameters
 * @callback GenericEvent
 */

/**
 * The {@link $ui} <b>oninteraction</b> fires when a user has interacted with the interface
 * @callback UIEvent
 * @param {$ui.InteractionEvent} event - Interaction event which was triggered by the UI
 */

/**
 * The options to be passed into the $ui.push() function
 * @namespace ScreenOptions
 * @memberof $ui
 * @property {number} [numScreensToClose] - Optional number of screens to close below the new screen pushed onto the stack
 * @property {boolean} [visible=true] - This property can be set to false if you want the screen to initially be invisble on the stack.  Typically used when you want to push multiple screens on the stack at a time.
 */
 
 /**
 * The options to be passed into the $ui.push() function
 * @namespace InitOptions
 * @memberof $ui
 * @property {$ui.Theme} [theme] - Theme to use for the toolkit
 * @property {GlobalDataProviderEvent} [globalDataProvider] - This option can be set to a global handler function for all {@link $ui.DataProvider} instances so that when their <b>fetch</b> function is called the request will be handled by the assigned function.
 */
 
 

/**
 * DataEvent class allows you to create an event that can be passed over the global event handler.
 * @class DataEvent
 * @memberof $ui
 * @param {number} id - Identifier for the event being raised
 * @param {object} data - The data to be passed with the event
 */
$ui.DataEvent = function(id, data) {
	/**
	* Numeric identifier for the event 
	* @name id
	* @type {number}
	* @memberof $ui.DataEvent
	*/
	if (id == undefined || id == null) throw 'DataEvent - The identifier "id" must be supplied';
	this.id = id;
	/**
	* Data payload for the event 
	* @name data
	* @type {object}
	* @memberof $ui.DataEvent
	*/
	this.data = data;
}

/**
 * The callback signature for the <i>addEventListner</i> function from {@link $ui}
 * @callback TriggeredEvent
 * @param {$ui.DataEvent} event - The event which was just received
 */
/**
 * @preserve FastClick: polyfill to remove click delays on browsers with touch UIs.
 *
 * @version 1.0.0
 * @codingstandard ftlabs-jsv2
 * @copyright The Financial Times Limited [All Rights Reserved]
 * @license MIT License (see LICENSE.txt)
 */

/*jslint browser:true, node:true*/
/*global define, Event, Node*/


/**
 * Instantiate fast-clicking listeners on the specificed layer.
 *
 * @constructor
 * @param {Element} layer The layer to listen on
 * @param {Object} options The options to override the defaults
 */
function FastClick(layer, options) {
	'use strict';
	var oldOnClick;

	options = options || {};

	/**
	 * Whether a click is currently being tracked.
	 *
	 * @type boolean
	 */
	this.trackingClick = false;


	/**
	 * Timestamp for when click tracking started.
	 *
	 * @type number
	 */
	this.trackingClickStart = 0;


	/**
	 * The element being tracked for a click.
	 *
	 * @type EventTarget
	 */
	this.targetElement = null;


	/**
	 * X-coordinate of touch start event.
	 *
	 * @type number
	 */
	this.touchStartX = 0;


	/**
	 * Y-coordinate of touch start event.
	 *
	 * @type number
	 */
	this.touchStartY = 0;


	/**
	 * ID of the last touch, retrieved from Touch.identifier.
	 *
	 * @type number
	 */
	this.lastTouchIdentifier = 0;


	/**
	 * Touchmove boundary, beyond which a click will be cancelled.
	 *
	 * @type number
	 */
	this.touchBoundary = options.touchBoundary || 10;


	/**
	 * The FastClick layer.
	 *
	 * @type Element
	 */
	this.layer = layer;
	
	/**
	 * The minimum time between tap(touchstart and touchend) events
	 * 
	 * @type number
	 */
	this.tapDelay = options.tapDelay || 200;

	if (FastClick.notNeeded(layer)) {
		return;
	}

	// Some old versions of Android don't have Function.prototype.bind
	function bind(method, context) {
		return function() { return method.apply(context, arguments); };
	}

	// Set up event handlers as required
	if (deviceIsAndroid) {
		layer.addEventListener('mouseover', bind(this.onMouse, this), true);
		layer.addEventListener('mousedown', bind(this.onMouse, this), true);
		layer.addEventListener('mouseup', bind(this.onMouse, this), true);
	}

	layer.addEventListener('click', bind(this.onClick, this), true);
	layer.addEventListener('touchstart', bind(this.onTouchStart, this), false);
	layer.addEventListener('touchmove', bind(this.onTouchMove, this), false);
	layer.addEventListener('touchend', bind(this.onTouchEnd, this), false);
	layer.addEventListener('touchcancel', bind(this.onTouchCancel, this), false);

	// Hack is required for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
	// which is how FastClick normally stops click events bubbling to callbacks registered on the FastClick
	// layer when they are cancelled.
	if (!Event.prototype.stopImmediatePropagation) {
		layer.removeEventListener = function(type, callback, capture) {
			var rmv = Node.prototype.removeEventListener;
			if (type === 'click') {
				rmv.call(layer, type, callback.hijacked || callback, capture);
			} else {
				rmv.call(layer, type, callback, capture);
			}
		};

		layer.addEventListener = function(type, callback, capture) {
			var adv = Node.prototype.addEventListener;
			if (type === 'click') {
				adv.call(layer, type, callback.hijacked || (callback.hijacked = function(event) {
					if (!event.propagationStopped) {
						callback(event);
					}
				}), capture);
			} else {
				adv.call(layer, type, callback, capture);
			}
		};
	}

	// If a handler is already declared in the element's onclick attribute, it will be fired before
	// FastClick's onClick handler. Fix this by pulling out the user-defined handler function and
	// adding it as listener.
	if (typeof layer.onclick === 'function') {

		// Android browser on at least 3.2 requires a new reference to the function in layer.onclick
		// - the old one won't work if passed to addEventListener directly.
		oldOnClick = layer.onclick;
		layer.addEventListener('click', function(event) {
			oldOnClick(event);
		}, false);
		layer.onclick = null;
	}
}


/**
 * Android requires exceptions.
 *
 * @type boolean
 */
var deviceIsAndroid = navigator.userAgent.indexOf('Android') > 0;


/**
 * iOS requires exceptions.
 *
 * @type boolean
 */
var deviceIsIOS = /iP(ad|hone|od)/.test(navigator.userAgent);


/**
 * iOS 4 requires an exception for select elements.
 *
 * @type boolean
 */
var deviceIsIOS4 = deviceIsIOS && (/OS 4_\d(_\d)?/).test(navigator.userAgent);


/**
 * iOS 6.0(+?) requires the target element to be manually derived
 *
 * @type boolean
 */
var deviceIsIOSWithBadTarget = deviceIsIOS && (/OS ([6-9]|\d{2})_\d/).test(navigator.userAgent);


/**
 * Determine whether a given element requires a native click.
 *
 * @param {EventTarget|Element} target Target DOM element
 * @returns {boolean} Returns true if the element needs a native click
 */
FastClick.prototype.needsClick = function(target) {
	'use strict';
	switch (target.nodeName.toLowerCase()) {

	// Don't send a synthetic click to disabled inputs (issue #62)
	case 'button':
	case 'select':
	case 'textarea':
		if (target.disabled) {
			return true;
		}

		break;
	case 'input':

		// File inputs need real clicks on iOS 6 due to a browser bug (issue #68)
		if ((deviceIsIOS && target.type === 'file') || target.disabled) {
			return true;
		}

		break;
	case 'label':
	case 'video':
		return true;
	}

	return (/\bneedsclick\b/).test(target.className);
};


/**
 * Determine whether a given element requires a call to focus to simulate click into element.
 *
 * @param {EventTarget|Element} target Target DOM element
 * @returns {boolean} Returns true if the element requires a call to focus to simulate native click.
 */
FastClick.prototype.needsFocus = function(target) {
	'use strict';
	switch (target.nodeName.toLowerCase()) {
	case 'textarea':
		return true;
	case 'select':
		return !deviceIsAndroid;
	case 'input':
		switch (target.type) {
		case 'button':
		case 'checkbox':
		case 'file':
		case 'image':
		case 'radio':
		case 'submit':
			return false;
		}

		// No point in attempting to focus disabled inputs
		return !target.disabled && !target.readOnly;
	default:
		return (/\bneedsfocus\b/).test(target.className);
	}
};


/**
 * Send a click event to the specified element.
 *
 * @param {EventTarget|Element} targetElement
 * @param {Event} event
 */
FastClick.prototype.sendClick = function(targetElement, event) {
	'use strict';
	var clickEvent, touch;

	// On some Android devices activeElement needs to be blurred otherwise the synthetic click will have no effect (#24)
	if (document.activeElement && document.activeElement !== targetElement) {
		document.activeElement.blur();
	}

	touch = event.changedTouches[0];

	// Synthesise a click event, with an extra attribute so it can be tracked
	clickEvent = document.createEvent('MouseEvents');
	clickEvent.initMouseEvent(this.determineEventType(targetElement), true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null);
	clickEvent.forwardedTouchEvent = true;
	targetElement.dispatchEvent(clickEvent);
};

FastClick.prototype.determineEventType = function(targetElement) {
	'use strict';

	//Issue #159: Android Chrome Select Box does not open with a synthetic click event
	if (deviceIsAndroid && targetElement.tagName.toLowerCase() === 'select') {
		return 'mousedown';
	}

	return 'click';
};


/**
 * @param {EventTarget|Element} targetElement
 */
FastClick.prototype.focus = function(targetElement) {
	'use strict';
	var length;

	// Issue #160: on iOS 7, some input elements (e.g. date datetime) throw a vague TypeError on setSelectionRange. These elements don't have an integer value for the selectionStart and selectionEnd properties, but unfortunately that can't be used for detection because accessing the properties also throws a TypeError. Just check the type instead. Filed as Apple bug #15122724.
	if (deviceIsIOS && targetElement.setSelectionRange && targetElement.type.indexOf('date') !== 0 && targetElement.type !== 'time') {
		length = targetElement.value.length;
		targetElement.setSelectionRange(length, length);
	} else {
		targetElement.focus();
	}
};


/**
 * Check whether the given target element is a child of a scrollable layer and if so, set a flag on it.
 *
 * @param {EventTarget|Element} targetElement
 */
FastClick.prototype.updateScrollParent = function(targetElement) {
	'use strict';
	var scrollParent, parentElement;

	scrollParent = targetElement.fastClickScrollParent;

	// Attempt to discover whether the target element is contained within a scrollable layer. Re-check if the
	// target element was moved to another parent.
	if (!scrollParent || !scrollParent.contains(targetElement)) {
		parentElement = targetElement;
		do {
			if (parentElement.scrollHeight > parentElement.offsetHeight) {
				scrollParent = parentElement;
				targetElement.fastClickScrollParent = parentElement;
				break;
			}

			parentElement = parentElement.parentElement;
		} while (parentElement);
	}

	// Always update the scroll top tracker if possible.
	if (scrollParent) {
		scrollParent.fastClickLastScrollTop = scrollParent.scrollTop;
	}
};


/**
 * @param {EventTarget} targetElement
 * @returns {Element|EventTarget}
 */
FastClick.prototype.getTargetElementFromEventTarget = function(eventTarget) {
	'use strict';

	// On some older browsers (notably Safari on iOS 4.1 - see issue #56) the event target may be a text node.
	if (eventTarget.nodeType === Node.TEXT_NODE) {
		return eventTarget.parentNode;
	}

	return eventTarget;
};


/**
 * On touch start, record the position and scroll offset.
 *
 * @param {Event} event
 * @returns {boolean}
 */
FastClick.prototype.onTouchStart = function(event) {
	'use strict';
	var targetElement, touch, selection;
	
	// Ignore multiple touches, otherwise pinch-to-zoom is prevented if both fingers are on the FastClick element (issue #111).
	if (event.targetTouches.length > 1) {
		return true;
	}

	targetElement = this.getTargetElementFromEventTarget(event.target);
	touch = event.targetTouches[0];

	
	
	if (deviceIsIOS) {

		// Only trusted events will deselect text on iOS (issue #49)
		selection = window.getSelection();
		if (selection.rangeCount && !selection.isCollapsed) {
			return true;
		}

		if (!deviceIsIOS4 && soloUI.isPhoneGap === true) {

			// Weird things happen on iOS when an alert or confirm dialog is opened from a click event callback (issue #23):
			// when the user next taps anywhere else on the page, new touchstart and touchend events are dispatched
			// with the same identifier as the touch event that previously triggered the click that triggered the alert.
			// Sadly, there is an issue on iOS 4 that causes some normal touch events to have the same identifier as an
			// immediately preceeding touch event (issue #52), so this fix is unavailable on that platform.
			if (touch.identifier === this.lastTouchIdentifier) {
				event.preventDefault();
				return false;
			}

			this.lastTouchIdentifier = touch.identifier;

			// If the target element is a child of a scrollable layer (using -webkit-overflow-scrolling: touch) and:
			// 1) the user does a fling scroll on the scrollable layer
			// 2) the user stops the fling scroll with another tap
			// then the event.target of the last 'touchend' event will be the element that was under the user's finger
			// when the fling scroll was started, causing FastClick to send a click event to that layer - unless a check
			// is made to ensure that a parent layer was not scrolled before sending a synthetic click (issue #42).
			this.updateScrollParent(targetElement);
		}
	}

	this.trackingClick = true;
	this.trackingClickStart = event.timeStamp;
	this.targetElement = targetElement;

	this.touchStartX = touch.pageX;
	this.touchStartY = touch.pageY;

	// Prevent phantom clicks on fast double-tap (issue #36)
	if ((event.timeStamp - this.lastClickTime) < this.tapDelay) {
		event.preventDefault();
	}
	
	return true;
};


/**
 * Based on a touchmove event object, check whether the touch has moved past a boundary since it started.
 *
 * @param {Event} event
 * @returns {boolean}
 */
FastClick.prototype.touchHasMoved = function(event) {
	'use strict';
	var touch = event.changedTouches[0], boundary = this.touchBoundary;

	if (Math.abs(touch.pageX - this.touchStartX) > boundary || Math.abs(touch.pageY - this.touchStartY) > boundary) {
		return true;
	}

	return false;
};


/**
 * Update the last position.
 *
 * @param {Event} event
 * @returns {boolean}
 */
FastClick.prototype.onTouchMove = function(event) {
	'use strict';
	
	if (!this.trackingClick) {
		return true;
	}

	// If the touch has moved, cancel the click tracking
	if (this.targetElement !== this.getTargetElementFromEventTarget(event.target) || this.touchHasMoved(event)) {
		this.trackingClick = false;
		this.targetElement = null;
	}
	
	
	
	return true;
};


/**
 * Attempt to find the labelled control for the given label element.
 *
 * @param {EventTarget|HTMLLabelElement} labelElement
 * @returns {Element|null}
 */
FastClick.prototype.findControl = function(labelElement) {
	'use strict';

	// Fast path for newer browsers supporting the HTML5 control attribute
	if (labelElement.control !== undefined) {
		return labelElement.control;
	}

	// All browsers under test that support touch events also support the HTML5 htmlFor attribute
	if (labelElement.htmlFor) {
		return document.getElementById(labelElement.htmlFor);
	}

	// If no for attribute exists, attempt to retrieve the first labellable descendant element
	// the list of which is defined here: http://www.w3.org/TR/html5/forms.html#category-label
	return labelElement.querySelector('button, input:not([type=hidden]), keygen, meter, output, progress, select, textarea');
};


/**
 * On touch end, determine whether to send a click event at once.
 *
 * @param {Event} event
 * @returns {boolean}
 */
FastClick.prototype.onTouchEnd = function(event) {
	'use strict';
	var forElement, trackingClickStart, targetTagName, scrollParent, touch, targetElement = this.targetElement;

	if (!this.trackingClick) {
		return true;
	}

	// Prevent phantom clicks on fast double-tap (issue #36)
	if ((event.timeStamp - this.lastClickTime) < this.tapDelay) {
		this.cancelNextClick = true;
		return true;
	}

	// Reset to prevent wrong click cancel on input (issue #156).
	this.cancelNextClick = false;

	this.lastClickTime = event.timeStamp;

	trackingClickStart = this.trackingClickStart;
	this.trackingClick = false;
	this.trackingClickStart = 0;

	
	// On some iOS devices, the targetElement supplied with the event is invalid if the layer
	// is performing a transition or scroll, and has to be re-detected manually. Note that
	// for this to function correctly, it must be called *after* the event target is checked!
	// See issue #57; also filed as rdar://13048589 .
	if (deviceIsIOSWithBadTarget) {
		touch = event.changedTouches[0];
		// In certain cases arguments of elementFromPoint can be negative, so prevent setting targetElement to null
		targetElement = document.elementFromPoint(touch.pageX - window.pageXOffset, touch.pageY - window.pageYOffset) || targetElement;
		targetElement.fastClickScrollParent = this.targetElement.fastClickScrollParent;
	}

	targetTagName = targetElement.tagName.toLowerCase();
	if (targetTagName === 'label') {
		forElement = this.findControl(targetElement);
		if (forElement) {
			this.focus(targetElement);
			if (deviceIsAndroid) {
				return false;
			}

			targetElement = forElement;
		}
	} else if (this.needsFocus(targetElement)) {

		// Case 1: If the touch started a while ago (best guess is 100ms based on tests for issue #36) then focus will be triggered anyway. Return early and unset the target element reference so that the subsequent click will be allowed through.
		// Case 2: Without this exception for input elements tapped when the document is contained in an iframe, then any inputted text won't be visible even though the value attribute is updated as the user types (issue #37).
		if ((event.timeStamp - trackingClickStart) > 100 || (deviceIsIOS && window.top !== window && targetTagName === 'input')) {
			this.targetElement = null;
			return false;
		}

		this.focus(targetElement);
		this.sendClick(targetElement, event);

		// Select elements need the event to go through on iOS 4, otherwise the selector menu won't open.
		if (!deviceIsIOS4 || targetTagName !== 'select') {
			this.targetElement = null;
			event.preventDefault();
		}

		return false;
	}

	if (deviceIsIOS && !deviceIsIOS4) {

		// Don't send a synthetic click event if the target element is contained within a parent layer that was scrolled
		// and this tap is being used to stop the scrolling (usually initiated by a fling - issue #42).
		scrollParent = targetElement.fastClickScrollParent;
		if (scrollParent && scrollParent.fastClickLastScrollTop !== scrollParent.scrollTop) {
			return true;
		}
	}
	

	// Prevent the actual click from going though - unless the target node is marked as requiring
	// real clicks or if it is in the whitelist in which case only non-programmatic clicks are permitted.
	if (!this.needsClick(targetElement)) {
		event.preventDefault();
		this.sendClick(targetElement, event);
	}

	return false;
};


/**
 * On touch cancel, stop tracking the click.
 *
 * @returns {void}
 */
FastClick.prototype.onTouchCancel = function() {
	'use strict';
	
	this.trackingClick = false;
	this.targetElement = null;
};


/**
 * Determine mouse events which should be permitted.
 *
 * @param {Event} event
 * @returns {boolean}
 */
FastClick.prototype.onMouse = function(event) {
	'use strict';

	// If a target element was never set (because a touch event was never fired) allow the event
	if (!this.targetElement) {
		return true;
	}

	if (event.forwardedTouchEvent) {
		return true;
	}

	// Programmatically generated events targeting a specific element should be permitted
	if (!event.cancelable) {
		return true;
	}

	// Derive and check the target element to see whether the mouse event needs to be permitted;
	// unless explicitly enabled, prevent non-touch click events from triggering actions,
	// to prevent ghost/doubleclicks.
	if (!this.needsClick(this.targetElement) || this.cancelNextClick) {

		// Prevent any user-added listeners declared on FastClick element from being fired.
		if (event.stopImmediatePropagation) {
			event.stopImmediatePropagation();
		} else {

			// Part of the hack for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
			event.propagationStopped = true;
		}

		// Cancel the event
		event.stopPropagation();
		event.preventDefault();

		return false;
	}

	// If the mouse event is permitted, return true for the action to go through.
	return true;
};


/**
 * On actual clicks, determine whether this is a touch-generated click, a click action occurring
 * naturally after a delay after a touch (which needs to be cancelled to avoid duplication), or
 * an actual click which should be permitted.
 *
 * @param {Event} event
 * @returns {boolean}
 */
FastClick.prototype.onClick = function(event) {
	'use strict';
	var permitted;

	// It's possible for another FastClick-like library delivered with third-party code to fire a click event before FastClick does (issue #44). In that case, set the click-tracking flag back to false and return early. This will cause onTouchEnd to return early.
	if (this.trackingClick) {
		this.targetElement = null;
		this.trackingClick = false;
		return true;
	}

	// Very odd behaviour on iOS (issue #18): if a submit element is present inside a form and the user hits enter in the iOS simulator or clicks the Go button on the pop-up OS keyboard the a kind of 'fake' click event will be triggered with the submit-type input element as the target.
	if (event.target.type === 'submit' && event.detail === 0) {
		return true;
	}

	permitted = this.onMouse(event);

	// Only unset targetElement if the click is not permitted. This will ensure that the check for !targetElement in onMouse fails and the browser's click doesn't go through.
	if (!permitted) {
		this.targetElement = null;
	}

	// If clicks are permitted, return true for the action to go through.
	return permitted;
};


/**
 * Remove all FastClick's event listeners.
 *
 * @returns {void}
 */
FastClick.prototype.destroy = function() {
	'use strict';
	var layer = this.layer;

	if (deviceIsAndroid) {
		layer.removeEventListener('mouseover', this.onMouse, true);
		layer.removeEventListener('mousedown', this.onMouse, true);
		layer.removeEventListener('mouseup', this.onMouse, true);
	}

	layer.removeEventListener('click', this.onClick, true);
	layer.removeEventListener('touchstart', this.onTouchStart, false);
	layer.removeEventListener('touchmove', this.onTouchMove, false);
	layer.removeEventListener('touchend', this.onTouchEnd, false);
	layer.removeEventListener('touchcancel', this.onTouchCancel, false);
};


/**
 * Check whether FastClick is needed.
 *
 * @param {Element} layer The layer to listen on
 */
FastClick.notNeeded = function(layer) {
	'use strict';
	var metaViewport;
	var chromeVersion;

	// Devices that don't support touch don't need FastClick
	if (typeof window.ontouchstart === 'undefined') {
		return true;
	}

	// Chrome version - zero for other browsers
	chromeVersion = +(/Chrome\/([0-9]+)/.exec(navigator.userAgent) || [,0])[1];

	if (chromeVersion) {

		if (deviceIsAndroid) {
			metaViewport = document.querySelector('meta[name=viewport]');

			if (metaViewport) {
				// Chrome on Android with user-scalable="no" doesn't need FastClick (issue #89)
				if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
					return true;
				}
				// Chrome 32 and above with width=device-width or less don't need FastClick
				if (chromeVersion > 31 && window.innerWidth <= window.screen.width) {
					return true;
				}
			}

		// Chrome desktop doesn't need FastClick (issue #15)
		} else {
			return true;
		}
	}

	// IE10 with -ms-touch-action: none, which disables double-tap-to-zoom (issue #97)
	if (layer.style.msTouchAction === 'none') {
		return true;
	}

	return false;
};


/**
 * Factory method for creating a FastClick object
 *
 * @param {Element} layer The layer to listen on
 * @param {Object} options The options to override the defaults
 */
FastClick.attach = function(layer, options) {
	'use strict';
	return new FastClick(layer, options);
};


if (typeof define !== 'undefined' && define.amd) {

	// AMD. Register as an anonymous module.
	define(function() {
		'use strict';
		return FastClick;
	});
} else if (typeof module !== 'undefined' && module.exports) {
	module.exports = FastClick.attach;
	module.exports.FastClick = FastClick;
} else {
	window.FastClick = FastClick;
}
/**
 * Every component in the UI follows the same general patterns. This is to keep consistency and make coding easier.
 * <br><br><b>NOTE: The core component is an abstract base class and cannot be created as an instance on its own</b>
 * @namespace
 * @name CoreComponent
 * @memberof $ui
 * @property {namespace} component - The <b>mandatory</b> component property defines what type of component is being defined. This property always starts with a <b>$ui.</b> defining the component to be used for generating the UI.
 * @property {string} [id] - The id property is used to uniquely define the control in the screen for which it belongs. <br><br>Providing an id for your control is very convenient because you can easily access your control through your javascript coding. Each id is added as a direct handle on the screen object for access.
 * @property {boolean} [animated=false] - Set this value to <b>true</b> for the control to have animation.  NOTE: Each derivative control is responsible for their animation styling. Setting this property to true will add the ".animated" CSS class to the root element of the control.  Feel free to define your own CSS for the ".animated" property
 * @property {boolean} [visible=true] - The visible property specifies the visibility of the control. 
 * @property {boolean} [enabled=true] - The enabled property specifies the initial enabled state of the control.  <i>NOTE: Not all controls will render a disabled state. If you wish to render a disabled state simply override the ".disabled" CSS for the root of your control</i>
 * @property {$ui.CoreScreen} screen - This <b>readonly</b> property allows for you to reference the screen from the control. This will be the screen in which the control is embedded
 * @property {$ui.DataProviderLink} [provider] - This property allows you to bind the control to a [data provider]{@link $ui.DataProvider} in the application. 
 * @property {object[]} attachedObjects - This property specifies an array of objects that can be attached to the control. These could be objects such as data providers and usually entail a component that does not provide a user interface.
 * @property {boolean} [marginTop=false] - A boolean property which when set to true will place a standard margin on the top of the control. 
 * @property {boolean} [marginBottom=false] - A boolean property which when set to true will place a standard margin on the bottom of the control.
 * @property {boolean} [marginLeft=false] - A boolean property which when set to true will place a standard margin on the left of the control
 * @property {boolean} [marginRight=false] - A boolean property which when set to true will place a standard margin on the right of the control.
 */
function $ui_CoreComponent(object, screen) {
	try {
	if (object) {
		this.object = object;
		// The protected object is where we store our dynamic object variables
		object._protected = {
			model: object
		};
		
		// Create our base container for the control 
		object.dom = document.createElement('div');
		object.dom.model = object;
		$ui.addClass(object.dom, 'ui-core-component');
		
		// Assign our control name for automation & analytics
		if (object.id) {
			object.dom.setAttribute('data-id',object.id);
		}
		
		// Component Property
		object._protected.component = object.component;
		Object.defineProperty(object, 'component', {
			get: function() {return this._protected.component;},
			set: function() {
				console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','component'));
			},
			configurable: false} 
		);
		
		// Screen Property
		if (screen != undefined) {
			object.screen = screen;
			screen.children.push(object);
			if (object.id) {
        if (screen[object.id] != undefined) {
          var text = 'WARNING: You have used a non-unique id: "'+ object.id+'"';
          if (screen.id != undefined) {
            text = text + ' on screen "'+screen.id+'"';
          }
          console.log(text);
        }
				screen[object.id] = object;
			}
		}
		object._protected.screen = object.screen;
		Object.defineProperty(object, 'screen', {
			get: function() {return this._protected.screen;},
			set: function() {
				console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','screen'));
			},
			configurable: false}
		);
		
		// id property
		object._protected.id = object.id;
		Object.defineProperty(object, 'id', {
			get: function() {return this._protected.id;},
			set: function() {
				console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','id'));
			},
			configurable: false}
		);
		
		// Enabled Property
		if (object.enabled != false) {
			object.enabled = true;
		} else {
			$ui.addClass(object.dom, 'disabled');
		}
		object._protected.enabled = object.enabled;
		Object.defineProperty(object, 'enabled', {
			get: function() {return this._protected.enabled;},
			set: function(value) {
				if (value == this._protected.enabled) return;
				if (this._protected.enabled && (value == false)) {
					this._protected.enabled = false;
					$ui.addClass(this.dom, 'disabled');
				} else if ((this._protected.enabled == false) && (value == true)) {
					this._protected.enabled = true;
					$ui.removeClass(this.dom, 'disabled');
				}
				// Call a child class' protected function if they need
				// to do special handling for enabling
				if (this._setEnabled) {
					this._setEnabled(value);
				}
			},
			configurable: false}
		);		

		
		// Animated property
		if (object.animated == true) {
			$ui.addClass(object.dom, 'animated');
		} else {
			object.animated = false;
		}
		object._protected.animated = object.animated;
		Object.defineProperty(object, 'animated', {
			get: function() {return this._protected.animated;},
			set: function() {
				console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','animated'));
			},
			configurable: false}
		);
		
		// Set our initial visibility
		if ((object.visible != undefined) && (object.visible == false)) {
			object.dom.style.display = 'none';
		} else {
			object.visible = true;
		}
		object._protected.visible = object.visible;
		// Set our modification rules for 'visible'
		Object.defineProperty(object, 'visible', {
			get: function() {return this._protected.visible;},
			set: function(value) {
				if (value != this._protected.visible) {
					if (value == true) {
						this._protected.visible = true;
						if (this.dom != undefined) {
							this.dom.style.display = '';
						}
					} else {
						this._protected.visible = false;
						if (this.dom != undefined) {
							this.dom.style.display = 'none';
						}
					}
					// Allow of the top level control to also react to the visibility change
					if (this._setVisible) {
						this._setVisible(value);
					}
				} 
			},
			configurable: false}
		);
		
		// Attached Objects Property
		if (object.attachedObjects) {
			var i,
        j,
				control,
        extension,
				controlDom,
				targetScreen = (object.screen != undefined) ? object.screen : object; // The only control without a screen is a screen
			for (i = 0; i < object.attachedObjects.length; i++) {
				control = object.attachedObjects[i];
        if (control == undefined) {
    			throw 'CoreComponent.attachedObject: "control" is not defined';
    		} 
    		if (targetScreen == undefined) {
    			throw 'CoreComponent.attachedObject: "screen" is not defined';
    		}
    		// Find and create the attached object extension
    		for (j = 0; j < $ui._protected.definitions.length; j++) {
    			extension = $ui._protected.definitions[j];
    			if (extension.type != $ui.UIExtensionType.ATTACHED_OBJECT) continue;
    			if (extension.component == control.component) {
    				controlDom = new extension.constructor(control, object, targetScreen);
    				break;
    			}
    		}
				// If this control needs to be in the DOM add it
				if (controlDom instanceof HTMLElement) {
					object.dom.appendChild(controlDom);
				}
			}
		} else {
			object.attachedObjects = [];
		}
		object._protected.attachedObjects = object.attachedObjects;
		Object.defineProperty(object, 'attachedObjects', {
			get: function() {return this._protected.attachedObjects;},
			set: function(value) {
				console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','attachedObjects'));
			},
			configurable: false}
		);
		
		/** 
		 * This protected function will raise an interaction event for the <b>oninteraction</b> callback assigned to the {@link $ui} object.
		 * @memberof $ui.CoreComponent
		 * @protected 
		 * @function _raiseInteractionEvent
		 * @param {string} interaction - Desired interaction to raise
		 */
		object._raiseInteractionEvent = function(interaction) {
			var event = new InteractionEvent(this.screen.id, this.id, interaction, this.component);
			$ui._raiseInteractionEvent(event);
		}.$bind(object);
		
		
		// Private function to animate scrolling the control into view 
		object._scrollIntoView = function() {
			var step = 20,
				rect = this.dom.getBoundingClientRect(),
				scrollArea = this.dom.parentNode;
				
			this._scrollIterationCounter = this._scrollIterationCounter + 1;
			// See if it has reached the top of the screen
			if (rect.top == scrollArea.offsetTop) { 
				return;
			}
			
			// If the bottom and top of the control is visible
			if ((rect.bottom < (scrollArea.offsetTop + scrollArea.offsetHeight)) && (rect.top > scrollArea.offsetTop)) {
				return;
			}
				
			if (rect.top > scrollArea.offsetTop) { // Need to scroll down
				if (rect.top - scrollArea.offsetTop < step) {
					step = 1;
				}
				scrollArea.scrollTop = scrollArea.scrollTop + step;
			} else { // Need to scroll up
				if (scrollArea.offsetTop - rect.top < step) {
					step = 1;
				}
				scrollArea.scrollTop = scrollArea.scrollTop - step;
			}
			
			if (this._scrollIterationCounter > 100) { // Equivalent to moving something 2000 pixels
				console.log('fail safe scroll counter exceeded');
				return;
			}
			requestAnimationFrame(this._scrollIntoView);
		}.$bind(object);
		
		/** 
		 * This function will scroll the control into view for the user.
		 * @memberof $ui.CoreComponent
		 * @function scrollIntoView
		 */
		object.scrollIntoView = function() {
			if (this.dom) {
				this._scrollIterationCounter = 0;
				requestAnimationFrame(this._scrollIntoView);
			}
		}.$bind(object);
		
		// Public base destructor for the component
		object.destroy = function() {	
			// Call private destructor of control if it is there
			if (object._destroy) {
				object._destroy();
			}
			// Remove the provider listener
			if (this.provider != undefined) {
				if (this.provider.id != undefined) {
					window.removeEventListener(this.screen.guid+'-'+this.provider.id+'-updated', this._providerRefresh, false);
				}
			}	
      // Remove screen reference
      if (this.id != undefined && this.id.length > 0) {
				this.screen[this.id] = undefined;
			}
			// Clean-up any attached objects
			var i,
				attachedObject;
			if (this.attachedObjects && this.attachedObjects.length > 0) {
				for (i = 0; i < this.attachedObjects.length; i++) {
					attachedObject = this.attachedObjects[i];
					if (attachedObject._destroy) {
						attachedObject._destroy();
					}
				}
			}
			this.dom = undefined;
		}.$bind(object);
		
		// Handle a provider update
		object._providerRefresh = function() {
			// Find the data provider
			var dataProvider = this.screen[this.provider.id];
			if (dataProvider != undefined) {
				// Make sure it has some data assigned to it
				if (dataProvider.data != undefined) {
					var properties = this.provider.property.split('.'),
						i,
						data = dataProvider.data,
						found = true;
					// traverse it's hierarchy for our data value	
					for (i = 0; i < properties.length; i++) {
						data = data[properties[i]];
						if (data == undefined) {
							found = false;
							break;
						}
					}
					if (found) {
						if (this._providerUpdate) {
							this._providerUpdate(data);
						}
						return;
					} else {
						if (this._providerUpdate) {
							this._providerUpdate(undefined);
						}
					}
				} else {
					// If there was data we would not reach this point other wise it is undefined
					// so we have to check to see if it is an initial load so that we don't trigger 
					// the control's update unnecessarily 
					if (this._providerUpdate) {
						this._providerUpdate(undefined);
					}
				}
			} 
		}.$bind(object);
		
		
    // This function will remove the control from the screen
    object._remove = function() {
      if (this._onremove) {
        this._onremove();
      }
      // Remove node
      if (this.dom && this.dom.parentNode) {
        this.dom.parentNode.removeChild(this.dom);
      }
      if (this.screen) {
        var index = this.screen.children.indexOf(this);
        if (index >= 0) {
          this.screen.children.splice(index, 1);
        }
      }
      this.destroy();
    }.$bind(object);
    
		// This function will update the provider data source with new data from the control
		object._updateData = function(value) {
			// Find the data provider
			var dataProvider = (this.provider == undefined) ? undefined : this.screen[this.provider.id];
			if (dataProvider != undefined) {
				// Mark the property as updated
				dataProvider._propertyUpdated(this.provider.property, value);
				// Make sure it has some data assigned to it
				if (dataProvider.data != undefined) {
					var properties = this.provider.property.split('.'),
						i,
						data = dataProvider.data,
						currentValue;
					// traverse it's hierarchy for our data value	
					for (i = 0; i < properties.length; i++) {
						currentValue = data[properties[i]];
						if ((currentValue == undefined) && (i < (properties.length -1))) {
							break;
						} else if (i == (properties.length -1)) {
							data[properties[i]] = value;
							break;
						}
						data = currentValue;
					}
				}
			}
		}.$bind(object);
		
		// Data Provider Property
		if (object.provider != undefined) {
			if (object.provider.id != undefined) {
				// unique event listener for this provider on this screen
				window.addEventListener(object.screen.guid+'-'+object.provider.id+'-updated', object._providerRefresh, false);
				// Evaluate our bindings 
				object._providerRefresh();
			}
		}
		object._protected.provider = object.provider;
		Object.defineProperty(object, 'provider', {
			get: function() {return this._protected.provider;},
			set: function(value) {
				console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','provider'));
			},
			configurable: false}
		);
	}
	} catch (error) {
		console.log("RPW error in core component: " + error);
	}
}

/** 
 * The function assigned to this member will fire when the component has been asked to be removed from its parent. This is an <b>internal protected</b> member to be used by derivative controls and should not be bound to by application code
 * @name _onremove
 * @memberof $ui.CoreComponent
 * @protected
 * @type {function} 
 */

/** 
 * The function assigned to this member will fire when the screen the component belongs to receives an onshow event. This is an <b>internal protected</b> member to be used by derivative controls and should not be bound to by application code
 * @name _onshow
 * @memberof $ui.CoreComponent
 * @protected
 * @type {function} 
 */
 
 /** 
 * The function assigned to this member will fire when the toolkit has updated its theme. This is an <b>internal protected</b> member to be used by derivative controls and should not be bound to by application code
 * @name _onthemechange
 * @memberof $ui.CoreComponent
 * @protected
 * @type {function} 
 */

 
/** 
 * The function assigned to this member will fire when the screen that the component belongs to has it's viewport size changed. This is an <b>internal protected</b> member to be used by derivative controls and should not be bound to by application code
 * @name _onresize
 * @memberof $ui.CoreComponent
 * @protected
 * @type {function} 
 */

/** 
 * The function assigned to this member will fire when the screen that the component belongs to is just about to be popped. This will only fire if the screen is the top most screen in the stack. It allows for any clean-up that might need to be done before animating. This is an <b>internal protected</b> member to be used by derivative controls and should not be bound to by application code
 * @name _onbeforepop
 * @memberof $ui.CoreComponent
 * @protected
 * @type {function} 
 */

/**
 * This is the abstract base class that represents a component instance which contains other components. It derives from {@link $ui.CoreComponent}. 
 * <br><br><b>NOTE: This is an abstract class </b>
 * @namespace
 * @name CoreContainerComponent
 * @memberof $ui
 * @extends $ui.CoreComponent 
 * @property {boolean} [modified] - This property will cascade the <b>modified</b> value to all child controls contained in the control group <b>IF</b> the value is false.  Otherwise it will simply mark itself as modified.
 */
function $ui_CoreContainerComponent(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	if (object) {
		
		/**
		* Protected internal function for derivative controls to implement to return the control list array
		* @function _getControlListProperty
		* @memberof $ui.CoreContainerComponent
		* @returns {$ui.CoreComponent[]}
		* @protected
		*/
		
		/**
		* Protected internal function for derivative controls to implement to return the DOM element that contains the controls
		* @function _getControlListDom
		* @memberof $ui.CoreContainerComponent
		* @returns {HTMLElement}
		* @protected
		*/
		
		/**
		* Protected internal function for derivative controls to implement to react if there is a cascading of visibility
		* @function _oncascadevisibility
		* @memberof $ui.CoreContainerComponent
		* @protected
		*/
    
    /**
		* Protected internal function for derivative controls to implement to react to the results of the validation of the control
		* @function _onvalidate
    * @param {boolean} result
		* @memberof $ui.CoreContainerComponent
		* @protected
		*/
    
    /**
		* Protected internal function for derivative controls to implement to react to the change of the modified flag
		* @function _onmodified
		* @memberof $ui.CoreContainerComponent
		* @protected
		*/
		
		// modified property
		if (object.modified == undefined) {
			object.modified = false;
		} 
		object._protected.modified = object.modified;
		Object.defineProperty(object, 'modified', {
			get: function() {return this._protected.modified;},
			set: function(value) {
				if (value == undefined) value = false;
				this._protected.modified = value;
				if (this._getControlListProperty == undefined) {
					console.log('ERROR: _getControlListProperty not defined for CoreContainerComponent');
					return;
				}
        if (value == false) {
          var i,
  					control,
  					controlList = this._getControlListProperty();
  				for (i = 0; i < controlList.length; i++) {
  					control = controlList[i];
  					control.modified = value;
  				}
        }
        if (this._onmodified) {
          this._onmodified();
        }
			},
			configurable: false}
		);
		
		/** 
		 * Validate all the controls contained in this column (including nested controls) and return the boolean result
		 * @function validate
		 * @memberof $ui.CoreContainerComponent
		 * @returns {boolean}
		 */
		object.validate = function() {
			if (this._getControlListProperty == undefined) {
				console.log('ERROR: _getControlListProperty not defined for CoreContainerComponent');
				return false;
			}
			var i,
				control,
				controlList = this._getControlListProperty(),
				result = true;
			for (i = 0; i < controlList.length; i++) {
				control = controlList[i];
				if (control.validate)  {
					if (control.validate() == false) {
						result = false;
					}
				}
			}
      if (this._onvalidate) {
        this._onvalidate(result);
      }
			return result;
		}.$bind(object);
		
		// This function is called to cascade down a visibility change to child controls
		object._cascadeVisibility = function() {
			if (this._getControlListProperty == undefined) {
				console.log('ERROR: _getControlListProperty not defined for CoreContainerComponent');
				return;
			}
			var i,
				controlList = this._getControlListProperty(),
				control;			
			for (i = 0; i < controlList.length; i++) {
				control = controlList[i];
				if (control._cascadeVisibility) {
					control._cascadeVisibility();
				} else {
					if (control._onshow) {
						control._onshow();
					}
				}
			}
			if (this._oncascadevisibility) {
				this._oncascadevisibility();
			}
		}.$bind(object);
		
		
		// Internal function to create the component
		object._addComponent = function(control) {
			if (control == undefined) return;
			if (this._getControlListDom == undefined) {
				console.log('ERROR: _getControlListDom not defined for CoreContainerComponent');
				return;
			}
			var dom = this._getControlListDom();
			if (dom == undefined) {
				console.log('ERROR: _getControlListDom did not return a valid DOM element');
				return;
			}
			if (this.modified != undefined) {
				control.modified = this.modified;
			}
			$ui.createControl(control, this.screen);
			if (control.dom) {
				dom.appendChild(control.dom);
			}
		}.$bind(object);
		
		/** 
		 * Add a new control to the end of this container control
		 * @function addComponent
		 * @memberof $ui.CoreContainerComponent
		 * @param {$ui.CoreComponent} control - The control that you wish to add to the container control
		 */
		object.addComponent = function(control) {
			if (control == undefined) return;
			this._addComponent(control);
			if (this._getControlListProperty == undefined) {
				console.log('ERROR: _getControlListProperty not defined for CoreContainerComponent');
				return;
			}
			var list = this._getControlListProperty();
			if (list == undefined) {
				console.log('ERROR: _getControlListProperty did not return a valid object');
				return;
			}
			list.push(control);
			if (control._onshow) {
				control._onshow();
			}
			if (control.provider != undefined) {
				control._providerRefresh();
			}
		}.$bind(object);
		
		/** 
		 * Insert a new control into this container control before the targetControl
		 * @function insertComponentBefore
		 * @memberof $ui.CoreContainerComponent
		 * @param {$ui.CoreComponent} control - The control that you wish to insert to the container control
		 * @param {$ui.CoreComponent} targetControl - The target control that you wish to insert before 
		 */
		object.insertComponentBefore = function(control, targetControl) {
			if (control == undefined) return;
			if (targetControl == undefined) return;
			if (this._getControlListProperty == undefined) {
				console.log('ERROR: _getControlListProperty not defined for CoreContainerComponent');
				return;
			}
			var list = this._getControlListProperty();
			if (list == undefined) {
				console.log('ERROR: _getControlListProperty did not return a valid object');
				return;
			}
			if (this._getControlListDom == undefined) {
				console.log('ERROR: _getControlListDom not defined for CoreContainerComponent');
				return;
			}
			var dom = this._getControlListDom();
			if (dom == undefined) {
				console.log('ERROR: _getControlListDom did not return a valid DOM element');
				return;
			}
			// See if we can find the target control
			var i,
				item;
			for (i = 0; i < list.length; i++) {
				item = list[i];
				if (item == targetControl && item.dom && item.dom.parentNode) {
					if (this.modified != undefined) {
						control.modified = this.modified;
					}
					$ui.createControl(control, this.screen);
					if (control.dom) {
						item.dom.parentNode.insertBefore(control.dom, item.dom);
						list.splice(i, 0, control);
						if (control._onshow) {
							control._onshow();
						}
						if (control.provider != undefined) {
							control._providerRefresh();
						}
					}
					break;
				}
			}
			
			
		}.$bind(object);
		
		/** 
		 * Remove an existing control from this container control
		 * @function removeComponent
		 * @memberof $ui.CoreContainerComponent
		 * @param {$ui.CoreComponent} control - The control that you wish to remove from the screen
		 */
		object.removeComponent = function(control) {
			if (control == undefined) return;
			if (this._getControlListDom == undefined) {
				console.log('ERROR: _getControlListDom not defined for CoreContainerComponent');
				return;
			}
			if (this._getControlListProperty == undefined) {
				console.log('ERROR: _getControlListProperty not defined for CoreContainerComponent');
				return;
			}
			var dom = this._getControlListDom();
			if (dom == undefined) {
				console.log('ERROR: _getControlListDom did not return a valid DOM element');
				return;
			}
			var list = this._getControlListProperty();
			if (list == undefined) {
				console.log('ERROR: _getControlListProperty did not return a valid object');
				return;
			}
			var i,
				item;
			for (i = 0; i < list.length; i ++) {
				item = list[i];
				if (item == control) {
					list.splice(i,1);
          if (item.clearComponents) {
            item.clearComponents();
          }
          item._remove();
					break;
				}
			}
		}.$bind(object);
		
		/** 
		 * Remove all the child controls from this container control
		 * @function clearComponents
		 * @memberof $ui.CoreContainerComponent
		 */
		object.clearComponents = function() {
			if (this._getControlListProperty == undefined) {
				console.log('ERROR: _getControlListProperty not defined for CoreContainerComponent');
				return;
			}
			var list = this._getControlListProperty();
			if (list == undefined) {
				console.log('ERROR: _getControlListProperty did not return a valid object');
				return;
			}
			for (var i = list.length - 1; i >= 0; i--) {
				this.removeComponent(list[i]);
			}
				
		}.$bind(object);
		
		return object.dom;
	}
}
/**
 * This is the abstract base class that represents a screen instance. It derives from {@link $ui.CoreComponent}. 
 * A screen is declared as a JavaScript function and has various different properties. When a screen is pushed onto the stack a new instance of the screen will be created and rendered.<br><br>
 * If a derivative screen is using the <b>animated</b> property to animate a screen transition to show the screen, it must also provide a reverse animation effect within its <b>_onbeforepop</b> event.
 * <br><br><b>NOTE: This is an abstract class </b>
 * @namespace
 * @name CoreScreen
 * @memberof $ui
 * @extends $ui.CoreContainerComponent 
 * @property {GenericEvent} [onresize] - This event will fire when the viewport of the screen changes size
 * @property {boolean} [floatOnTop=false] - When set to <b>true</b> the screens below this screen will remain visible and have this screen float on top.
 * @property {DataEvent} [onshow] - This event will fire when the screen has been displayed
 * @property {DataEvent} [oncreate] - This event will when the screen has been initialized but has not yet been processed.  This allows you to make any changes to the screens properties before any of the controls are created.
 * @property {GenericEvent} [ondestroy] - This event will fire when the screen is about to be destroyed. Allowing for any memory clean-up routines
 * @property {GenericEvent} [onthemechange] - This event will fire when the theme for the toolkit has been updated
 * @property {CheckReadyStateEvent} [oncheckreadystate] - This event will fire when the screen is asked about its dirty state.  It allows the screen to manage its own state and can call the <b>readyCallback<b> function passed as a parameter when the screen is ready.  Being ready means that whomever asked about your state can be assured that everything is ok with the screen's state.
 */
function $ui_CoreScreen(object, data) {
	$ui_CoreContainerComponent.call(this, object);
	if (object) {
		object.data = data;
		object._protected.screen = object;
		// Guid Property
		object.guid = $ui.guid();
		object._protected.guid = object.guid;
		Object.defineProperty(object, 'guid', {
			get: function() {return this._protected.guid;},
			set: function() {
				console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','guid'));
			},
			configurable: false}
		);
		
		// floatOnTop Property
		if (object.floatOnTop != true) {
			object.floatOnTop = false;
		}
		object._protected.floatOnTop = object.floatOnTop;
		Object.defineProperty(object, 'floatOnTop', {
			get: function() {return this._protected.floatOnTop;},
			set: function() {
				console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','floatOnTop'));
			},
			configurable: false}
		);
		
		object.children = []; // Contains all child controls in the screen
		$ui.addClass(object.dom,'ui-core-screen');
		
		/**
		* Protected internal function for derivative screens to implement if they have specific functionality they wish to
		* do when the screen initializes.  This function will fire just before the <b>onshow</b> event is triggered for the screen.
		* @function _intitialize
		* @memberof $ui.CoreScreen
		* @protected
		*/
     
    /**
		* This function allows for querying the ready state of the screen which in turn will fire the <b>oncheckreadystate</b> event.  This can be useful when someone wishes to navigate away from the screen but a 
    * user has not yet saved their changes. It allows the screen to determine if it is safe to leave the screen or if some action needs to be handled.
		* @function checkReadyState
		* @memberof $ui.CoreScreen
		* @param {GenericEvent} readyCallback - Callback function to be fired when the screen is ready
    * @param {GenericEvent} [cancelCallback] - Callback function to be fired when the screen says that it is not ready
		*/
    object.checkReadyState = function(readyCallback, cancelCallback) {
      if (readyCallback == undefined) {
        console.log('ERROR: Cannot pass an undefined readyCallback to CoreScreen.checkReadyState()');
        return;
      }
      if (this.oncheckreadystate) {
        this.oncheckreadystate(readyCallback, cancelCallback);
      } else {
        readyCallback();
      }
    }.$bind(object);
		
		// Initialize the screen
		object.initialize = function() {
      this.dom.style['z-index'] = $ui.screens.length+1;
			$ui._protected.inScreenTransition = false;
			$ui._blockAllTapEvent(false);
			// See if there is an internal implementation of _initialize
			if (this._initialize) {
				this._initialize();
			}
			// Raise our onshow event
			if (this.onshow) {
				this.onshow(this.data);
			}
			// Fire the _onshow for all the controls
			var i,
				control;
			for (i = 0; i < this.children.length;i++) {
				control = this.children[i];
				if (control._onshow) {
					control._onshow();
				}
			}
      this._raiseInteractionEvent('data-interaction-screen-initialized');
		}.$bind(object);
		
		// Handle our internal update for theme changes
		object._onthemechange = function() {
			// Raise our onthemechange event
			if (this.onthemechange) {
				this.onthemechange();
			}
			// Fire the _onthemechange for all the controls
			var i,
				control;
			for (i = 0; i < this.children.length;i++) {
				control = this.children[i];
				if (control._onthemechange) {
					control._onthemechange();
				}
			}
		}.$bind(object);
		
		// Internal Resize event
		object._onresize = function() {
			// Fire the _onresize for all the controls
			var i,
				control;
			for (i = 0; i < this.children.length;i++) {
				control = this.children[i];
				if (control._onresize) {
					control._onresize();
				}
			}
		}.$bind(object);
		
		// Internal before pop event
		object.onbeforepop = function() {
			if (this._onbeforepop) {
				this._onbeforepop();
			}
			// Fire the _onbeforepop for all the controls
			var i,
				control;
			for (i = 0; i < this.children.length;i++) {
				control = this.children[i];
				if (control._onbeforepop) {
					control._onbeforepop();
				}
			}
		}.$bind(object);
		
		// Destroy screen
		object._destroy = function() {
			if (this.ondestroy) {
				this.ondestroy();
			}
			// Loop through all the children and call their destroy
			var i;
			for (i = 0; i < this.children.length; i++) {
				this.children[i].destroy();
			}
		}.$bind(object);
		
		return object.dom;
	}
}
/**
 * The DataEvent is used in a few places where an event needs to be fired an an optional data object passed to that event
 * @callback DataEvent
 * @param {object} [data] - The data that is being passed to this event
 */
 
 /**
 * The {@link $ui.CoreScreen} <b>oncheckreadystate</b> fires when the screen is asked about its ready state.  The screen has an opportunity to process its own state and then
 * fire the <b>readyCallback</b> function passed in as a paramenter when the screen is actually ready.  It may never fire the <b>readyCallback</b> if it is not ready.
 * @callback CheckReadyStateEvent
 * @param {GenericEvent} readyCallback - Callback function to be fired when the screen's state is ready
 * @param {GenericEvent} [cancelCallback] - Callback function to be fired when the screen says that it is <b>not</b> ready
 */
/**
 * The DataProvider component provides a data source that can be bound to controls on a screen. This provides the ability to both populate controls with data, as well as automatically save the data based on user interaction with the controls.<br><br>
 * <b>NOTE: The DataProvider should be attached to a screen or control using its [attachedObjects]{@link $ui.CoreComponent} property.</b><br><br>
 * <b>Sample Declaration</b>
 * <pre>
 * {
 *   component: $ui.DataProvider,
 *   id: 'myProvider',
 *   data_key: 'RATE_TYPE_CLASS_LIST',
 *   // highlight the first item in the list on load
 *   onload: function () {
 *     if (this.data && this.data.classes && this.data.classes.length > 0) {
 *       this.screen.rateTypeClassLayout.selectClass( this.data.classes[0]);
 *     }
 *   }
 *}
 * </pre>
 * @namespace
 * @name DataProvider
 * @memberof $ui
 * @property {object} component - The <b>required</b> component property defines what type of component is being defined. This property must be $ui.DataProvider
 * @property {string} id - The <b>required</b> id property is used to uniquely define the data provider in the scope of the screen in which it belongs. Providing an id for your data provider is required because you can easily access your provider through your javascript coding and also reference it as the provider for a control.
 * 
 * @property {string} [data_key] - A string reference to a unique, registered data service key; This is required by the <b>fetch</b> method
 * @property {string} [data_resource]  A string overriding the name of the resource to retrieve; For JSON file requests, the name is prefixed and .json is added as the extension
 * @property {string} [data_type]  A string overriding the type of resource to retrieve (see $data.data_service_types for valid options)
 * 
 * @property {object} [data] - The data property by default is undefined. You can populate the data property as any kind of object. The data property holds the object that represents the data for the provider
 * @property {GenericEvent} [onload] - This event will fire when the data has been successfully loaded into the provider and controls have been updated
 * @property {GenericEvent} [onbeforeupdate] - This event will fire when the data property has been successfully set, but has not yet been used to update any controls connected to the provider. This gives you an opportunity to manipulate the data property of the data provider <b>before</b> controls are updated
 */
function $ui_DataProvider(object, component, screen){
	// Create our protected area
	object._protected = {
		model: object,
		updates: []
	};
	
	// Attach the ID to the main screen object
	if (object.id && screen) {
		screen[object.id] = object;
	}
	
	// Component Property
	object._protected.component = object.component;
	Object.defineProperty(object, 'component', {
		get: function() {return this._protected.component;},
		set: function() {
			console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','component'));
		},
		configurable: false}
	);
	
	// Screen property
	object.screen = screen;
	object._protected.screen = object.screen;
	Object.defineProperty(object, 'screen', {
		get: function() {return this._protected.screen;},
		set: function() {
			console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','screen'));
		},
		configurable: false}
	);
	
	// Data property
	object._protected.data = object.data;
	Object.defineProperty(object, 'data', {
		get: function() {return this._protected.data;},
		set: function(value) {
			this._protected.data = value;
			this._protected.updates = [];
			if (this.onbeforeupdate) {
				this.onbeforeupdate();
			}
			this._raiseEvent();
			if (value == undefined) return;
			if (this.onload) {
				this.onload();
			}
		},
		configurable: false}
	);

  object.clear = function() {
    // iterate through data object and reset each property to undefined
    var data = object.data,
      clear_data = {};
    for (var property in data) {
      if (data.hasOwnProperty(property)) {
        clear_data[property] = undefined;
      }
    }
    object.data = clear_data;
  };

  /**
   * The fetch function retrieves and populates the DataProvider's data property.
   * The fetch function will only work if the global <b>$ui.init()</b> function has been passed an option parameter that has configured the <b>globalDataProvider</b> value
   * @function fetch
   * @memberof $ui.DataProvider
   * @param onfail - this callback function is invoked if unable to retrieve the requested data
   * @param transform - an optional data transformation function that takes the data as a parameter
   *  and returns the transformed data
   */
  object.fetch = function(onfail, transform) {
    if ($ui.options.globalDataProvider != undefined) {
      $ui.options.globalDataProvider._getData.call(this.screen, this, function(data) {
        if (transform) {
          data = transform(data);
        }
        object.data = data;}, onfail);
    }
  }.$bind(object);

	/** 
	 * The refresh function will send a signal out to all connected components to refresh their data from the current content in memory from the provider. <b>NOTE: No <i>onbeforeupdate</i> or <i>onload</i> event will fire on the provider</b>
	 * @function refresh
	 * @memberof $ui.DataProvider
	 */
	object.refresh = function() {
		this._raiseEvent();
	}.$bind(object);
	
	/** 
	 * The getUpdates function will return an array of field updates on the provider since its data property has been set.
	 * @function getUpdatedFields
	 * @memberof $ui.DataProvider
	 * @returns {ProviderUpdate[]}
	 */
	object.getUpdatedFields = function() {
		var i,
			result = [];
		for (i = 0; i < this._protected.updates.length; i++) {
			result.push(this._protected.updates[i]); 
		}
		return result;		
	}.$bind(object);
	
	// Maintain a list of updated data
	object._propertyUpdated = function(property, value) {
		var i,
			entry,
			found = false,
			newEntry = {
				property: property,
				value: value
			};
		// See if we just need to update an existing entry
		for (i = 0; i < this._protected.updates.length; i++) {
			entry = this._protected.updates[i];
			if (entry.property == property) {
				this._protected.updates[i] = newEntry;
				found = true;
				break;
			}
		}
		if (found == false) {
			this._protected.updates.push(newEntry);
		}
	}.$bind(object);
	
	// Raise our event to let the rest of the app know to refresh
	object._raiseEvent = function() {
		var evt = document.createEvent('Events');
		evt.initEvent(this.screen.guid+'-'+this.id+'-updated', true, true);
		window.dispatchEvent(evt);
	}.$bind(object);
	
	// Private function to handle clean-up
	object._destroy = function() {
		this._protected.data = undefined;
	}.$bind(object);
	
	// See if the data was pre-defined
	if (object.data != undefined) {
		if (object.onbeforeupdate) {
			object.onbeforeupdate();
		}
		if (object.onload) {
			object.onload();
		}
	}
	
	return undefined;
}

/**
 * A data provider link provides a binding between a [control]{@link $ui.CoreComponent} and a data provider. The path for the <b>property</b> attribute starts at the root of the object that is provided as the data source for the data provider.<br><br>
 * The type of object that the property path should point to is dependent on the control and the data it uses to display and/or edit. If the control also allows the user to edit data or change settings, these changes will be applied to the property value in the data provider.<br><br>
 * <b>Sample Code:</b><br>
 * <pre>provider: {
 *    id: 'myProvider',
 *    property: 'posts'
 * }
 * </pre>
 * <br>
 * To access sub objects in the object chain from the data provider you can use normal <b>dot</b> notation:<br><br>
 * <b>Sample Code:</b><br>
 * <pre>provider: {
 *    id: 'myProvider',
 *    property: 'posts.item.thingy'
 * }
 * </pre>
 * <br>
 * @namespace
 * @name DataProviderLink
 * @memberof $ui
 * @property {string} id - This is the <b>mandatory</b> id of the data provider belonging to the screen which will be linked to this control.  
 * @property {string} property - This is the property path/name of the object to be used as the bound data for this control. A nested property can be defined simply by providing a path using <b>.</b> dot separators just like you were referring to the object via JavaScript
 */
 
 
/**
 * The ProviderUpdate is a value that specifies a property name from a {@link $ui.DataProvider} and the new value of the property
 * @namespace ProviderUpdate
 * @memberof $ui.DataProvider
 * @property [string] property - The name of the property updated
 * @property [object] value - The new value of the property
 */
 
 /**
 * The GlobalDataProviderEvent is used when initializing the toolkit and 
 * @callback GlobalDataProviderEvent
 * @param {$ui.DataProvider} dataProvider - The DataProvider instance
 * @param {DataEvent} callback - The callback data event to be fired when data is ready
 * @param {GenericEvent} onfail - Callback to be triggered if there was an error during retrieval
 */
/**
 * Represents an interaction event from the user interface.  This event is raised when a user interacts with a part of the interface. All interation events are sent to the $ui.oninteraction 
 * assigned function.  If valid values are not passed in for all of the parameters no event will be raised.
 * @class InteractionEvent
 * @param {string} screenId - The <b>id</b> property of the screen which contains the control providing the interaction
 * @param {string} controlID - The <b>id</b> property of the control in which the user interacted
 * @param {string} interaction - The interaction which took place
 * @param {object} component - The component type definition for which this interaction took place.   An example could be the value $ui.List.  This is <b>not</b> a pointer to the control.
 */
function InteractionEvent(screenId, controlId, interaction, component) {
	/**
	 * The <b>id</b> property of the screen which contains the control providing the interaction
	 * @member {string} screenId
	 * @memberOf InteractionEvent
	 */
	this.screenId = screenId;
	
	 /**
	 * The <b>id</b> property of the control in which the user interacted
	 * @member {string} controlId
	 * @memberOf InteractionEvent
	 */
	this.controlId = controlId;
	
	 
	 /**
	 * The interaction which took place
	 * @member {string} interaction
	 * @memberOf InteractionEvent
	 */
	this.interaction = interaction;
	
	/**
	 * The component type definition for which this interaction took place.  An example could be the value $ui.List.  This is <b>not</b> a pointer to the control
	 * @member {object} component
	 * @memberOf InteractionEvent
	 */
	this.component = component;
}


 


/**
 * A List object will display multiple list items based on the data provided to the control.  The type of item objects that are used should match the declaration of the <b>style</b> of the list control.<br><br>
 * The type of data provider value for a list control should point to a property in the data provider that would follow the same rules as hard coding an array of items.<br><br>
 * <b>Sample Declaration</b><br>
 * <pre>
 * {
 *   component: $ui.List,
 *   style: $ui.GenericListItem,
 *   items: [
 *      {
 *         img: 'thumbnails/foo.png',
 *         title: 'This is my title',
 *         accent: '6 hours ago',
 *         caption: 'My summary description'
 *      }
 *   ]
 *}
 * @namespace
 * @name List
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {object[]} [items] - The items property is an array of objects who's definition matches that of the requirements of the <b>style</b> property of the list
 * @property {object} style - This is a list item decalaration so that the list knows how to render. For example this could be set to {@link $ui.GenericListItem}
 * @property {ListActionEvent} [onaction] - The onaction event will fire when an action from a list item is triggered. Some list items may have multiple actions that can be taken. When one of these actions is selected by the user the onaction event will fire.
 * @property {GenericEvent} [onitemschanged] - The onitemschanged event will fire when any items have been added or removed from the list.  This will also fire on data provider updates.
 */
function $ui_List(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom,'ui-list');
	
	// Set our items property
	if (object.items == undefined) {
		object.items = [];
	}
	object._protected.items = object.items;
	Object.defineProperty(object, 'items', {
		get: function() {return this._protected.items;},
		set: function() {
			console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','items'));
		},
		configurable: false}
	);

	// Broker the onaction from a list item
	object._onaction = function(item, event) {
		if (this.onaction) {
			this.onaction(event);
		}
	}.$bind(object);
	
	// Create the DOM for a list item depending on the list type
	object._createItemDom = function(item) {
		var dom;
		// See if the item is a header
		if (item.component && (item.component == $ui.Header)) {
			dom = $ui.createControl(item,this.screen);
		} else if (this._itemConstructor != undefined) {
			dom = new this._itemConstructor(item,this.screen);
		}
		return dom;
	}.$bind(object);
	
	// Private function to add a new item to the list
	object._addItem = function(item) {
		item.parent = this;
		itemDom = this._createItemDom(item);
		if (itemDom) {
			this.dom.appendChild(itemDom);
			if (item._onafterinsert) {
				item._onafterinsert();
			}
			return true;
		} else {
			return false;
		}
	}.$bind(object);
	
	/** 
	 * You can add an item to the end of the list by calling the addItem function and passing in an object that matches the a list item
	 * @function addItem
	 * @memberof $ui.List
	 * @param {object} item - Item to be added to the list
	 */
	object.addItem = function(item) {
		if (this._addItem(item)) {
			this.items.push(item);
			// Trigger our changed event
			if (this.onitemschanged) {
				this.onitemschanged();
			}
			if (item._onshow) {
				item._onshow();
			}
			return true;
		} else {
			return false;
		}
	}.$bind(object);
	
	/** 
	 * The remove item function will remove an existing item from a list. If an invalid item is specified the removal will fail
	 * @function removeItem
	 * @memberof $ui.List
	 * @param {object} item - Item to be removed from the list
	 */
	object.removeItem = function(item) {
		if (item == undefined) return false;
		var index = this.items.indexOf(item);
		if (index < 0) return false;
		try {
			this.dom.removeChild(item.dom);
		} catch (ex) {
			console.log('$ui.List: ' + ex);
		}
		this.items.splice(index, 1);
		item.destroy(); 
		// Trigger our changed event
		if (this.onitemschanged) {
			this.onitemschanged();
		}
	}.$bind(object);
	
	/** 
	 * Insert item works similar to addItem but instead will insert the item into the list at the index specified. If an invalid index is specified it will result in failure to insert the item. To insert an item at the top of a list call insert with the index of 0.
	 * @function insertItem
	 * @memberOf $ui.List
	 * @param {object} item - Item to be inserted into the list
	 * @param {number} index - Index to insert the item
	 */
	object.insertItem = function(item, index) {
		item.parent = this;
		if (index < 0) {
			return false;
		} else if (this.items.length == 0) {
			this.addItem(item);
			return true;
		} else if (index > this.items.length - 1) {
			this.addItem(item);
			return true;
		} else { // Insert it at the index
			var existingItem = this.items[index],
				itemDom = this._createItemDom(item);
			this.items.splice(index, 0, item);
			this.dom.insertBefore(itemDom, existingItem.dom);
			// Trigger our changed event
			if (this.onitemschanged) {
				this.onitemschanged();
			}
			if (item._onshow) {
				item._onshow();
			}
			return true;
		} 
		return false;
	}.$bind(object);
	
	/** 
	 * You can refresh all the items in a list by calling the refreshItems function with an array of new items
	 * @function refreshItems
	 * @memberof $ui.List
	 * @param {object[]} items - Array of items to refresh the list
	 */
	object.refreshItems = function(itemArray) {
		var i,
			item;
		if (this.items) {
			// Remove all existing items first
			for (i = this.items.length - 1; i >= 0; i--) {
				item = this.items[i];
				try {
					this.dom.removeChild(item.dom);
				} catch (ex) {
					console.log('$ui.List: ' + ex);
				}
				this.items.pop();
				item.destroy();
			}
		}
		if (itemArray == undefined) return; // No data provided
		this.addItemBatch(itemArray);
		// Trigger our changed event
		if (this.onitemschanged) {
			this.onitemschanged();
		}
	}.$bind(object);
	
	/** 
	 * This function is much like the refreshItems function but instead it loads a list of items to the end of the current list and does not replace the existing list items.
	 * @function addItemBatch
	 * @memberof $ui.List
	 * @param {object[]} items - Array of items to be added to the list
	 */
	object.addItemBatch = function(itemArray) {
		var i,
			item;
		// Add all new items into the list
		for (i = 0; i < itemArray.length; i++) {
			item = itemArray[i];
			this.addItem(item);
		}
	}.$bind(object);
	
	/** 
	 * This function will filter the list items based on the name value pairs of search criteria.  All search criteria will be AND'ed
	 * @function filter
	 * @memberof $ui.List
	 * @param {ListFilter[]} filters - Array of filters to be used for this list
	 */
	object.filter = function(filters) {
		if (filters == undefined || filters == null) return;
		var i,
			j,
			filter,
			item,
			pattern,
			match = true;;
		for (i = 0; i < this.items.length; i++) {
			item = this.items[i];
			match = true;
			for (j = 0; j < filters.length; j++) {
				filter = filters[j];
				if (item[filter.name] != undefined) {
					pattern = new RegExp(filter.expression, 'gi');
					if (pattern.test(item[filter.name]) == false) {
						match = false;
						break;
					}
				}
			}
			item.visible = match;
		}
	}.$bind(object);
	
	/** 
	 * This function will reset any filter applied to the List
	 * @function filterReset
	 * @memberof $ui.List
	 */
	object.filterReset = function(filter) {
		var i;
		for (i = 0; i < this.items.length; i++) {
			this.items[i].visible = true;
		}
		
	}.$bind(object);
	
	
	// Private function to handle provider updates
	object._providerUpdate = function(value) {
		this.refreshItems(value);
	}.$bind(object);
	
	
	var i,
		extension;
	// Determine our item constructor
	for (i = 0; i < $ui._protected.definitions.length; i++) {
		extension = $ui._protected.definitions[i];
		if (extension.type != $ui.UIExtensionType.LISTITEM) continue;
		if (extension.component == object.style) {
			object._itemConstructor = extension.constructor;
			break;
		}
	}

	// Cycle through list items
	var	item,
		index;
	if (object.items) {
		for (i = 0; i < object.items.length; i++) {
			item = object.items[i];
			object._addItem(item);
		}
		// Trigger our changed event
		if (object.onitemschanged) {
			object.onitemschanged();
		}
	}
	
	// Relay the _onshow to list items
	object._onshow = function() {
		var i,
			item;
		for (i = 0; i < this.items.length; i++) {
			item = this.items[i];
			if (item._onshow) {
				item._onshow();
			}
		}
	}.$bind(object);
	
	return object.dom;
}

/**
 * The {@link $ui.List} <b>onaction</b> event will fire when the user interacts with a list item
 * @callback ListActionEvent
 * @param {ListEvent} event - The list event which was raised
 */
 
 /**
 * The {@link $ui.List} <b>onaction</b> event will fire when the user interacts with a list item
 * @class ListFilter
 * @memberof $ui
 * @param {string} name - The name of the property to be filtered
 * @param {string} expression - The regular expression to use to evaluate against the value of the named list item property
 */
 $ui.ListFilter = function(name, expression) {
	 this.name = name;
	 this.expression = expression;
 }
/**
 * The list event is what is triggered when a user interacts with the List control. It contains the target list item that the user was interacting with, the type of event which was triggered 
 * and an optional data property that contains extra data about the event.
 * @class ListEvent
 * @param {object} target - Target list item where the event originated
 * @param {string} eventType - The type of event that was triggered. Each list item has its own set of possible events that can be raised
 * @param {object} [data] - Optional data that can be passed with a list event
 */
function ListEvent(target, eventType, data) {
	/** 
	 * Target list item where the event originated
	 * @member {object} target
	 * @memberOf ListEvent
	 */
	this.target = target;
	
	/** 
	 * The type of event that was triggered. Each list item has its own set of possible events that can be raised
	 * @member {string} eventType
	 * @memberOf ListEvent
	 */
	this.eventType = eventType;
	
	/** 
	 * Optional data that can be passed with a list event
	 * @member {object} [data]
	 * @memberOf ListEvent
	 */
	this.data = data;
}


/**
 * The spinner control provides you the ability to give a visual indicator when your content is loading. The spinner has one main property <b>size</b>. <br><br>
 * <b>Sample Declaration</b><br>
 * <pre>
 * {
 *   component: $ui.Spinner,
 *   size: $ui.Spinner.SpinnerSize.LARGE
 *}
 * @namespace Spinner
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {$ui.Size} [size=$ui.Size.NORMAL] - Represents the size of the spinner component.
 * @property {$ui.Spinner.SpinnerColor} [forceColor] - This property specifies if the color should be forced to be dark or light. By default the system figures this out and does not need to be set. However, if you want to force a color in a certain scenario you can use this property.
 */
function $ui_Spinner(object, screen){
	$ui_CoreComponent.call(this, object, screen);
	// Size property
	object.size = (object.size) ? object.size : $ui.Size.NORMAL;
	object._protected.size = object.size;
	Object.defineProperty(object, 'size', {
		get: function() {return this._protected.size;},
		set: function(value) {
			if (this._protected.size == value) return;
			$ui.removeClass(this.dom, this._protected.size);
			this._protected.size = value;
			$ui.addClass(this.dom,value);			
		},
		configurable: false}
	);
	
	$ui.addClass(object.dom, 'ui-spinner')
	$ui.addClass(object.dom, object.size);
	$ui.addClass(object.dom, 'center');
	
	// Create the inner div
	object.dom.innerDiv = document.createElement('div');
	$ui.addClass(object.dom.innerDiv, 'inner');
	object.dom.appendChild(object.dom.innerDiv);
	
	// forceColor property
	object._protected.forceColor = object.forceColor;
	if (object.forceColor) {
		$ui.addClass(object.dom.innerDiv, object.forceColor);
	} else {
		if ($ui.theme.rootClass && $ui.theme.rootClass.indexOf('ui-theme-dark') > -1)  {
			$ui.addClass(object.dom.innerDiv, 'light');
		} else {
			$ui.addClass(object.dom.innerDiv, 'dark');
		}
	}
	Object.defineProperty(object, 'forceColor', {
		get: function() {return this._protected.forceColor;},
		set: function() {
			console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','forceColor'));			
		},
		configurable: false}
	);
	
	return object.dom
}

$ui_Spinner.prototype = new $ui_CoreComponent();
/**
 * The definition of an extension to be used in extending the <b>$ui</b> framework.
 * @class
 * @param {string} name - This would be the value you set as the <b>component</b> property for your control
 * @param {function} constructor - The function to be used as your control constructor
 * @param {$ui.UIExtensionType} [type=$ui.UIExtensionType.CONTROL] - The type of extension you are registering
 * @param {object} [definition] - Class definition for your extension, you can include properties such as constants here
 */
function UIExtension(name, constructor, type, definition) {
	/** 
	 * This would be the value you set as the <b>component</b> property for your control
	 * @member {string} name
	 * @memberOf UIExtension
	 */
	if (name == null) throw new Error('UIExtension: name cannot be null');
	if (name == undefined) throw new Error('UIExtension: name cannot be undefined');
	this.name = name;
	/** 
	 * The function to be used as your control constructor
	 * @member {function} constructor
	 * @memberOf UIExtension
	 */
	if (constructor == null) throw new Error('UIExtension: constructor cannot be null');
	if (constructor == undefined) throw new Error('UIExtension: constructor cannot be undefined');
	this.constructor = constructor;
	/** 
	 * The type of extension you are registering
	 * @member {$ui.UIExtensionType} [type=$ui.UIExtensionType.CONTROL]
	 * @memberOf UIExtension
	 */
	if (type == null || type == undefined) {
		this.type = $ui.UIExtensionType.CONTROL;
	} else if ((type != $ui.UIExtensionType.CONTROL) && (type != $ui.UIExtensionType.SCREEN) && (type != $ui.UIExtensionType.LISTITEM) && (type != $ui.UIExtensionType.ATTACHED_OBJECT)) {
		throw new Error('UIExtension: type is an invalid value');
	} else {
		this.type = type;
	}
	/** 
	 * Class definition for your extension, you can include properties such as constants here
	 * @member {object} [definition]
	 * @memberOf UIExtension
	 */
	if (definition == null || definition == undefined) {
		this.definition = {};
	} else {
		this.definition = definition;
	}
}
function $ui_ExtendSDK() {
	// Remove scrollbars on mobile devices and in the emulator
	if (($ui.isMobileDevice() == true) || $ui.theme.inHeadUnit == true || $ui.options.isClientDevice == true) {
		var style = document.createElement('style');
		style.innerHTML = '::-webkit-scrollbar { width: 0 !important;height: 0 !important;}';
		document.head.appendChild(style);
	}
	
	// Play the touch sound
	$ui.playTouchSound = function() {
		if (true || $system && $system.audio && $system.config.isEmulator == true) { // TODO - fix
			$system.audio.playSoundEffect($system.SoundEffect.TOUCH);
		}
	}
	$ui.playTouchSound = $ui.playTouchSound.$bind($ui);
	
	var def = {
		/**
		 * Location of where to display docked content in a {@link $ui.DockLayout} 
		 * @namespace DockLocation
		 * @readonly
		 * @memberof $ui.DockLayout
		 */
		DockLocation: {
			/** Dock located at the top 
			* @memberof $ui.DockLayout.DockLocation
			*/
			TOP: 'top',
			/** Dock located at the bottom
			* @memberof $ui.DockLayout.DockLocation
			*/
			BOTTOM: 'bottom'
		}
	};
	$ui.addExtension(new UIExtension('DockLayout', $ui_DockLayout, undefined, def));
	$ui.addExtension(new UIExtension('CircleMenu', $ui_CircleMenu));
	$ui.addExtension(new UIExtension('SegmentedControl', $ui_SegmentedControl));
	$ui.addExtension(new UIExtension('Tab', $ui_Tab));
	$ui.addExtension(new UIExtension('TabbedPane', $ui_TabbedPane));
	$ui.addExtension(new UIExtension('SplitView', $ui_SplitView));
	$ui.addExtension(new UIExtension('ControlGroup', $ui_ControlGroup));
	$ui.addExtension(new UIExtension('Header', $ui_Header));
	$ui.addExtension(new UIExtension('ColumnLayout', $ui_ColumnLayout, $ui.UIExtensionType.CONTROL));
	$ui.addExtension(new UIExtension('Column', $ui_Column, $ui.UIExtensionType.CONTROL));
	$ui.addExtension(new UIExtension('TileGroup', $ui_TileGroup));
	$ui.addExtension(new UIExtension('CoreTileGauge', $ui_CoreTileGauge));
	$ui.addExtension(new UIExtension('CoreTileDonutChart', $ui_CoreTileDonutChart));
	$ui.addExtension(new UIExtension('Button', $ui_Button));
	
	// Add our input type
	def = { 
		/**
		 * Style of switch to be used with a toggle
		 * @namespace InputType
		 * @readonly
		 * @memberof $ui.Input
		 * @property INTEGER {string} Allow integers only in this input.
		 * @property FLOAT {string} Allow floats (simple - without E) in this input.
		 */
		InputType: {
			INTEGER: 'integer',
			FLOAT: 'float'
		}
	};
	$ui.addExtension(new UIExtension('Input', $ui_Input, undefined, def));
	
	// Add our toggle style
	def = { 
		/**
		 * Style of switch to be used with a toggle
		 * @namespace Style
		 * @readonly
		 * @memberof $ui.Toggle
		 */
		Style: {
			/** The switch is momentary 
			* @memberof $ui.Toggle.Style
			*/
			Momentary: 'momentary',
			/** The switch is an on-off style.  This is the default style.
			* @memberof $ui.Toggle.Style
			*/
			OnOff: 'on-off',
			/** The switch is an on-off-on style 
			* @memberof $ui.Toggle.Style
			*/
			OnOffOn: 'on-off-on'
		}
	};
	$ui.addExtension(new UIExtension('Toggle', $ui_Toggle,undefined, def));
	// Add our list item extensions
	def = { 
		/**
		 * Event type of an event raised from a {@link $ui.GenericListItem} 
		 * @namespace GenericListEvent
		 * @readonly
		 * @memberof $ui.GenericListItem
		 */
		GenericListEvent: {
			/** Click of a generic list item 
			* @memberof $ui.GenericListItem.GenericListEvent
			*/
			ONCLICK:'onclick' 
		}
	};
	$ui.addExtension(new UIExtension('GenericListItem', $ui_GenericListItem, $ui.UIExtensionType.LISTITEM, def));
	def = { 
		/**
		 * Event type of an event raised from a {@link $ui.ImageListItem} 
		 * @namespace ImageListEvent
		 * @readonly
		 * @memberof $ui.ImageListItem
		 */
		ImageListEvent: {
			/** Click of an image list item 
			* @memberof $ui.ImageListItem.ImageListEvent
			*/
			ONCLICK:'onclick' 
		}
	};
	$ui.addExtension(new UIExtension('ImageListItem', $ui_ImageListItem, $ui.UIExtensionType.LISTITEM, def));
	// Add our screen extensions
	$ui.addExtension(new UIExtension('WindowPane', $ui_WindowPane, $ui.UIExtensionType.SCREEN));
}

$ui.extend($ui_ExtendSDK);

/**
 * Internal Tile sizing used with {@link $ui.CoreTile} 
 * @namespace TileSize
 * @readonly
 * @memberof $ui
 */
$ui.TileSize = {
	/** Standard 1 x 1 tile size */
	STANDARD: 'standard',
	/** Wide 1 x 2 tile size */
	WIDE: 'wide',
	/** Tall 2 x 1 tile size */
	TALL: 'tall',
	/** Square 2 x 2 tile size */
	SQUARE: 'square'
};

/** 
 * This function will calculate the datetime value in the past. It takes in a date represented by a string and returns a text interpretation of that value
 * @function calculateTimeInPast
 * @memberof $ui
 * @param {string|date} currentDate - Date you wish to use as the current date
 * @param {string|date} dateInPast - Date you wish to compare to the current date
 * */
$ui.calculateTimeInPast = function(currentDate, dateInPast) {
	try {
		if (currentDate == undefined) return '?';
		if (dateInPast == undefined) return '?';
		
		/* Make sure the parameters are Date Objects */
		if(!(currentDate instanceof Date)) currentDate = new Date(currentDate);
		if(!(dateInPast instanceof Date)) dateInPast = new Date(dateInPast);

		/* Change the dateInPast time to client timezone. */
		var localTime = dateInPast.getTime();
		var localOffset = dateInPast.getTimezoneOffset() * 60000;
		var utc = localTime + localOffset;
		
		var offset = -(currentDate.getTimezoneOffset() / 60);
		var dateInPastReal = utc + (3600000 * offset);
		dateInPast = new Date(dateInPastReal);

		/* timezone conversion is complete. Now just calculate the time.*/
		var milliseconds = Date.parse(dateInPast),
			currentDateMilliseconds = Date.parse(currentDate);
		if (isNaN(milliseconds)) return '?';
		if (isNaN(currentDateMilliseconds)) return '?';
		var millisecondsPassed = currentDateMilliseconds - milliseconds;
		
		if(millisecondsPassed / 1000 > 1) {
			if(millisecondsPassed / 1000 / 60 > 1) {
				if(millisecondsPassed / 1000 / 60 / 60 > 1) {
					if(millisecondsPassed / 1000 / 60 / 60 / 24 > 1) {
						if(millisecondsPassed / 1000 / 60 / 60 / 24 / 7 > 1) {
							if(millisecondsPassed / 1000 / 60 / 60 / 24 / 30 > 1) {
								if(millisecondsPassed / 1000 / 60 / 60 / 24 / 365 > 1) {
									return Math.floor(millisecondsPassed / 1000 / 60 / 60 / 24 / 365) + 'y';
								} else {
									return Math.floor(millisecondsPassed / 1000 / 60 / 60 / 24 / 30) == 12? '1y': Math.floor(millisecondsPassed / 1000 / 60 / 60 / 24 / 30) + 'mo';
								}
							} else {
								return Math.floor(millisecondsPassed / 1000 / 60 / 60 / 24 / 7) + 'w';
							}
						} else {
							return Math.floor(millisecondsPassed / 1000 / 60 / 60 / 24) == 7? '1w': Math.floor(millisecondsPassed / 1000 / 60 / 60 / 24) + 'd';
						}
					} else {
						return Math.floor(millisecondsPassed / 1000 / 60 / 60) == 24? '1d': Math.floor(millisecondsPassed / 1000 / 60 / 60) + 'h';
					}
				} else {
					return Math.floor(millisecondsPassed / 1000 / 60) == 60? '1h': Math.floor(millisecondsPassed / 1000 / 60) + 'm';
				}
			} else {
				return Math.floor(millisecondsPassed / 1000) == 60? '1m': Math.floor(millisecondsPassed / 1000) + 's';
			}
		} else {
			return '1s';
		}
	} catch (exception) {
		console.log(exception.message);
		return '?';
	}
}.$bind($ui);
/**
 * DataEvent class allows you to create an event that can be passed over the global event handler.
 * @class DataEvent
 * @memberof $ui
 * @param {number} id - Identifier for the event being raised
 * @param {object} data - The data to be passed with the event
 */
$ui.DataEvent = function(id, data) {
	/**
	* Numeric identifier for the event 
	* @name id
	* @type {number}
	* @memberof $ui.DataEvent
	*/
	if (id == undefined || id == null) throw 'DataEvent - The identifier "id" must be supplied';
	this.id = id;
	/**
	* Data payload for the event 
	* @name data
	* @type {object}
	* @memberof $ui.DataEvent
	*/
	this.data = data;
}

/**
 * The callback signature for the <i>addEventListner</i> function from {@link $ui}
 * @callback TriggeredEvent
 * @param {$ui.DataEvent} event - The event which was just received
 */
/**
 * @preserve FastClick: polyfill to remove click delays on browsers with touch UIs.
 *
 * @version 1.0.0
 * @codingstandard ftlabs-jsv2
 * @copyright The Financial Times Limited [All Rights Reserved]
 * @license MIT License (see LICENSE.txt)
 */

/*jslint browser:true, node:true*/
/*global define, Event, Node*/


/**
 * Instantiate fast-clicking listeners on the specificed layer.
 *
 * @constructor
 * @param {Element} layer The layer to listen on
 * @param {Object} options The options to override the defaults
 */
function FastClick(layer, options) {
	'use strict';
	var oldOnClick;

	options = options || {};

	/**
	 * Whether a click is currently being tracked.
	 *
	 * @type boolean
	 */
	this.trackingClick = false;


	/**
	 * Timestamp for when click tracking started.
	 *
	 * @type number
	 */
	this.trackingClickStart = 0;


	/**
	 * The element being tracked for a click.
	 *
	 * @type EventTarget
	 */
	this.targetElement = null;


	/**
	 * X-coordinate of touch start event.
	 *
	 * @type number
	 */
	this.touchStartX = 0;


	/**
	 * Y-coordinate of touch start event.
	 *
	 * @type number
	 */
	this.touchStartY = 0;


	/**
	 * ID of the last touch, retrieved from Touch.identifier.
	 *
	 * @type number
	 */
	this.lastTouchIdentifier = 0;


	/**
	 * Touchmove boundary, beyond which a click will be cancelled.
	 *
	 * @type number
	 */
	this.touchBoundary = options.touchBoundary || 10;


	/**
	 * The FastClick layer.
	 *
	 * @type Element
	 */
	this.layer = layer;
	
	/**
	 * The minimum time between tap(touchstart and touchend) events
	 * 
	 * @type number
	 */
	this.tapDelay = options.tapDelay || 200;

	if (FastClick.notNeeded(layer)) {
		return;
	}

	// Some old versions of Android don't have Function.prototype.bind
	function bind(method, context) {
		return function() { return method.apply(context, arguments); };
	}

	// Set up event handlers as required
	if (deviceIsAndroid) {
		layer.addEventListener('mouseover', bind(this.onMouse, this), true);
		layer.addEventListener('mousedown', bind(this.onMouse, this), true);
		layer.addEventListener('mouseup', bind(this.onMouse, this), true);
	}

	layer.addEventListener('click', bind(this.onClick, this), true);
	layer.addEventListener('touchstart', bind(this.onTouchStart, this), false);
	layer.addEventListener('touchmove', bind(this.onTouchMove, this), false);
	layer.addEventListener('touchend', bind(this.onTouchEnd, this), false);
	layer.addEventListener('touchcancel', bind(this.onTouchCancel, this), false);

	// Hack is required for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
	// which is how FastClick normally stops click events bubbling to callbacks registered on the FastClick
	// layer when they are cancelled.
	if (!Event.prototype.stopImmediatePropagation) {
		layer.removeEventListener = function(type, callback, capture) {
			var rmv = Node.prototype.removeEventListener;
			if (type === 'click') {
				rmv.call(layer, type, callback.hijacked || callback, capture);
			} else {
				rmv.call(layer, type, callback, capture);
			}
		};

		layer.addEventListener = function(type, callback, capture) {
			var adv = Node.prototype.addEventListener;
			if (type === 'click') {
				adv.call(layer, type, callback.hijacked || (callback.hijacked = function(event) {
					if (!event.propagationStopped) {
						callback(event);
					}
				}), capture);
			} else {
				adv.call(layer, type, callback, capture);
			}
		};
	}

	// If a handler is already declared in the element's onclick attribute, it will be fired before
	// FastClick's onClick handler. Fix this by pulling out the user-defined handler function and
	// adding it as listener.
	if (typeof layer.onclick === 'function') {

		// Android browser on at least 3.2 requires a new reference to the function in layer.onclick
		// - the old one won't work if passed to addEventListener directly.
		oldOnClick = layer.onclick;
		layer.addEventListener('click', function(event) {
			oldOnClick(event);
		}, false);
		layer.onclick = null;
	}
}


/**
 * Android requires exceptions.
 *
 * @type boolean
 */
var deviceIsAndroid = navigator.userAgent.indexOf('Android') > 0;


/**
 * iOS requires exceptions.
 *
 * @type boolean
 */
var deviceIsIOS = /iP(ad|hone|od)/.test(navigator.userAgent);


/**
 * iOS 4 requires an exception for select elements.
 *
 * @type boolean
 */
var deviceIsIOS4 = deviceIsIOS && (/OS 4_\d(_\d)?/).test(navigator.userAgent);


/**
 * iOS 6.0(+?) requires the target element to be manually derived
 *
 * @type boolean
 */
var deviceIsIOSWithBadTarget = deviceIsIOS && (/OS ([6-9]|\d{2})_\d/).test(navigator.userAgent);


/**
 * Determine whether a given element requires a native click.
 *
 * @param {EventTarget|Element} target Target DOM element
 * @returns {boolean} Returns true if the element needs a native click
 */
FastClick.prototype.needsClick = function(target) {
	'use strict';
	switch (target.nodeName.toLowerCase()) {

	// Don't send a synthetic click to disabled inputs (issue #62)
	case 'button':
	case 'select':
	case 'textarea':
		if (target.disabled) {
			return true;
		}

		break;
	case 'input':

		// File inputs need real clicks on iOS 6 due to a browser bug (issue #68)
		if ((deviceIsIOS && target.type === 'file') || target.disabled) {
			return true;
		}

		break;
	case 'label':
	case 'video':
		return true;
	}

	return (/\bneedsclick\b/).test(target.className);
};


/**
 * Determine whether a given element requires a call to focus to simulate click into element.
 *
 * @param {EventTarget|Element} target Target DOM element
 * @returns {boolean} Returns true if the element requires a call to focus to simulate native click.
 */
FastClick.prototype.needsFocus = function(target) {
	'use strict';
	switch (target.nodeName.toLowerCase()) {
	case 'textarea':
		return true;
	case 'select':
		return !deviceIsAndroid;
	case 'input':
		switch (target.type) {
		case 'button':
		case 'checkbox':
		case 'file':
		case 'image':
		case 'radio':
		case 'submit':
			return false;
		}

		// No point in attempting to focus disabled inputs
		return !target.disabled && !target.readOnly;
	default:
		return (/\bneedsfocus\b/).test(target.className);
	}
};


/**
 * Send a click event to the specified element.
 *
 * @param {EventTarget|Element} targetElement
 * @param {Event} event
 */
FastClick.prototype.sendClick = function(targetElement, event) {
	'use strict';
	var clickEvent, touch;

	// On some Android devices activeElement needs to be blurred otherwise the synthetic click will have no effect (#24)
	if (document.activeElement && document.activeElement !== targetElement) {
		document.activeElement.blur();
	}

	touch = event.changedTouches[0];

	// Synthesise a click event, with an extra attribute so it can be tracked
	clickEvent = document.createEvent('MouseEvents');
	clickEvent.initMouseEvent(this.determineEventType(targetElement), true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null);
	clickEvent.forwardedTouchEvent = true;
	targetElement.dispatchEvent(clickEvent);
};

FastClick.prototype.determineEventType = function(targetElement) {
	'use strict';

	//Issue #159: Android Chrome Select Box does not open with a synthetic click event
	if (deviceIsAndroid && targetElement.tagName.toLowerCase() === 'select') {
		return 'mousedown';
	}

	return 'click';
};


/**
 * @param {EventTarget|Element} targetElement
 */
FastClick.prototype.focus = function(targetElement) {
	'use strict';
	var length;

	// Issue #160: on iOS 7, some input elements (e.g. date datetime) throw a vague TypeError on setSelectionRange. These elements don't have an integer value for the selectionStart and selectionEnd properties, but unfortunately that can't be used for detection because accessing the properties also throws a TypeError. Just check the type instead. Filed as Apple bug #15122724.
	if (deviceIsIOS && targetElement.setSelectionRange && targetElement.type.indexOf('date') !== 0 && targetElement.type !== 'time') {
		length = targetElement.value.length;
		targetElement.setSelectionRange(length, length);
	} else {
		targetElement.focus();
	}
};


/**
 * Check whether the given target element is a child of a scrollable layer and if so, set a flag on it.
 *
 * @param {EventTarget|Element} targetElement
 */
FastClick.prototype.updateScrollParent = function(targetElement) {
	'use strict';
	var scrollParent, parentElement;

	scrollParent = targetElement.fastClickScrollParent;

	// Attempt to discover whether the target element is contained within a scrollable layer. Re-check if the
	// target element was moved to another parent.
	if (!scrollParent || !scrollParent.contains(targetElement)) {
		parentElement = targetElement;
		do {
			if (parentElement.scrollHeight > parentElement.offsetHeight) {
				scrollParent = parentElement;
				targetElement.fastClickScrollParent = parentElement;
				break;
			}

			parentElement = parentElement.parentElement;
		} while (parentElement);
	}

	// Always update the scroll top tracker if possible.
	if (scrollParent) {
		scrollParent.fastClickLastScrollTop = scrollParent.scrollTop;
	}
};


/**
 * @param {EventTarget} targetElement
 * @returns {Element|EventTarget}
 */
FastClick.prototype.getTargetElementFromEventTarget = function(eventTarget) {
	'use strict';

	// On some older browsers (notably Safari on iOS 4.1 - see issue #56) the event target may be a text node.
	if (eventTarget.nodeType === Node.TEXT_NODE) {
		return eventTarget.parentNode;
	}

	return eventTarget;
};


/**
 * On touch start, record the position and scroll offset.
 *
 * @param {Event} event
 * @returns {boolean}
 */
FastClick.prototype.onTouchStart = function(event) {
	'use strict';
	var targetElement, touch, selection;
	
	// Ignore multiple touches, otherwise pinch-to-zoom is prevented if both fingers are on the FastClick element (issue #111).
	if (event.targetTouches.length > 1) {
		return true;
	}

	targetElement = this.getTargetElementFromEventTarget(event.target);
	touch = event.targetTouches[0];

	
	
	if (deviceIsIOS) {

		// Only trusted events will deselect text on iOS (issue #49)
		selection = window.getSelection();
		if (selection.rangeCount && !selection.isCollapsed) {
			return true;
		}

		if (!deviceIsIOS4 && soloUI.isPhoneGap === true) {

			// Weird things happen on iOS when an alert or confirm dialog is opened from a click event callback (issue #23):
			// when the user next taps anywhere else on the page, new touchstart and touchend events are dispatched
			// with the same identifier as the touch event that previously triggered the click that triggered the alert.
			// Sadly, there is an issue on iOS 4 that causes some normal touch events to have the same identifier as an
			// immediately preceeding touch event (issue #52), so this fix is unavailable on that platform.
			if (touch.identifier === this.lastTouchIdentifier) {
				event.preventDefault();
				return false;
			}

			this.lastTouchIdentifier = touch.identifier;

			// If the target element is a child of a scrollable layer (using -webkit-overflow-scrolling: touch) and:
			// 1) the user does a fling scroll on the scrollable layer
			// 2) the user stops the fling scroll with another tap
			// then the event.target of the last 'touchend' event will be the element that was under the user's finger
			// when the fling scroll was started, causing FastClick to send a click event to that layer - unless a check
			// is made to ensure that a parent layer was not scrolled before sending a synthetic click (issue #42).
			this.updateScrollParent(targetElement);
		}
	}

	this.trackingClick = true;
	this.trackingClickStart = event.timeStamp;
	this.targetElement = targetElement;

	this.touchStartX = touch.pageX;
	this.touchStartY = touch.pageY;

	// Prevent phantom clicks on fast double-tap (issue #36)
	if ((event.timeStamp - this.lastClickTime) < this.tapDelay) {
		event.preventDefault();
	}
	
	return true;
};


/**
 * Based on a touchmove event object, check whether the touch has moved past a boundary since it started.
 *
 * @param {Event} event
 * @returns {boolean}
 */
FastClick.prototype.touchHasMoved = function(event) {
	'use strict';
	var touch = event.changedTouches[0], boundary = this.touchBoundary;

	if (Math.abs(touch.pageX - this.touchStartX) > boundary || Math.abs(touch.pageY - this.touchStartY) > boundary) {
		return true;
	}

	return false;
};


/**
 * Update the last position.
 *
 * @param {Event} event
 * @returns {boolean}
 */
FastClick.prototype.onTouchMove = function(event) {
	'use strict';
	
	if (!this.trackingClick) {
		return true;
	}

	// If the touch has moved, cancel the click tracking
	if (this.targetElement !== this.getTargetElementFromEventTarget(event.target) || this.touchHasMoved(event)) {
		this.trackingClick = false;
		this.targetElement = null;
	}
	
	
	
	return true;
};


/**
 * Attempt to find the labelled control for the given label element.
 *
 * @param {EventTarget|HTMLLabelElement} labelElement
 * @returns {Element|null}
 */
FastClick.prototype.findControl = function(labelElement) {
	'use strict';

	// Fast path for newer browsers supporting the HTML5 control attribute
	if (labelElement.control !== undefined) {
		return labelElement.control;
	}

	// All browsers under test that support touch events also support the HTML5 htmlFor attribute
	if (labelElement.htmlFor) {
		return document.getElementById(labelElement.htmlFor);
	}

	// If no for attribute exists, attempt to retrieve the first labellable descendant element
	// the list of which is defined here: http://www.w3.org/TR/html5/forms.html#category-label
	return labelElement.querySelector('button, input:not([type=hidden]), keygen, meter, output, progress, select, textarea');
};


/**
 * On touch end, determine whether to send a click event at once.
 *
 * @param {Event} event
 * @returns {boolean}
 */
FastClick.prototype.onTouchEnd = function(event) {
	'use strict';
	var forElement, trackingClickStart, targetTagName, scrollParent, touch, targetElement = this.targetElement;

	if (!this.trackingClick) {
		return true;
	}

	// Prevent phantom clicks on fast double-tap (issue #36)
	if ((event.timeStamp - this.lastClickTime) < this.tapDelay) {
		this.cancelNextClick = true;
		return true;
	}

	// Reset to prevent wrong click cancel on input (issue #156).
	this.cancelNextClick = false;

	this.lastClickTime = event.timeStamp;

	trackingClickStart = this.trackingClickStart;
	this.trackingClick = false;
	this.trackingClickStart = 0;

	
	// On some iOS devices, the targetElement supplied with the event is invalid if the layer
	// is performing a transition or scroll, and has to be re-detected manually. Note that
	// for this to function correctly, it must be called *after* the event target is checked!
	// See issue #57; also filed as rdar://13048589 .
	if (deviceIsIOSWithBadTarget) {
		touch = event.changedTouches[0];
		// In certain cases arguments of elementFromPoint can be negative, so prevent setting targetElement to null
		targetElement = document.elementFromPoint(touch.pageX - window.pageXOffset, touch.pageY - window.pageYOffset) || targetElement;
		targetElement.fastClickScrollParent = this.targetElement.fastClickScrollParent;
	}

	targetTagName = targetElement.tagName.toLowerCase();
	if (targetTagName === 'label') {
		forElement = this.findControl(targetElement);
		if (forElement) {
			this.focus(targetElement);
			if (deviceIsAndroid) {
				return false;
			}

			targetElement = forElement;
		}
	} else if (this.needsFocus(targetElement)) {

		// Case 1: If the touch started a while ago (best guess is 100ms based on tests for issue #36) then focus will be triggered anyway. Return early and unset the target element reference so that the subsequent click will be allowed through.
		// Case 2: Without this exception for input elements tapped when the document is contained in an iframe, then any inputted text won't be visible even though the value attribute is updated as the user types (issue #37).
		if ((event.timeStamp - trackingClickStart) > 100 || (deviceIsIOS && window.top !== window && targetTagName === 'input')) {
			this.targetElement = null;
			return false;
		}

		this.focus(targetElement);
		this.sendClick(targetElement, event);

		// Select elements need the event to go through on iOS 4, otherwise the selector menu won't open.
		if (!deviceIsIOS4 || targetTagName !== 'select') {
			this.targetElement = null;
			event.preventDefault();
		}

		return false;
	}

	if (deviceIsIOS && !deviceIsIOS4) {

		// Don't send a synthetic click event if the target element is contained within a parent layer that was scrolled
		// and this tap is being used to stop the scrolling (usually initiated by a fling - issue #42).
		scrollParent = targetElement.fastClickScrollParent;
		if (scrollParent && scrollParent.fastClickLastScrollTop !== scrollParent.scrollTop) {
			return true;
		}
	}
	

	// Prevent the actual click from going though - unless the target node is marked as requiring
	// real clicks or if it is in the whitelist in which case only non-programmatic clicks are permitted.
	if (!this.needsClick(targetElement)) {
		event.preventDefault();
		this.sendClick(targetElement, event);
	}

	return false;
};


/**
 * On touch cancel, stop tracking the click.
 *
 * @returns {void}
 */
FastClick.prototype.onTouchCancel = function() {
	'use strict';
	
	this.trackingClick = false;
	this.targetElement = null;
};


/**
 * Determine mouse events which should be permitted.
 *
 * @param {Event} event
 * @returns {boolean}
 */
FastClick.prototype.onMouse = function(event) {
	'use strict';

	// If a target element was never set (because a touch event was never fired) allow the event
	if (!this.targetElement) {
		return true;
	}

	if (event.forwardedTouchEvent) {
		return true;
	}

	// Programmatically generated events targeting a specific element should be permitted
	if (!event.cancelable) {
		return true;
	}

	// Derive and check the target element to see whether the mouse event needs to be permitted;
	// unless explicitly enabled, prevent non-touch click events from triggering actions,
	// to prevent ghost/doubleclicks.
	if (!this.needsClick(this.targetElement) || this.cancelNextClick) {

		// Prevent any user-added listeners declared on FastClick element from being fired.
		if (event.stopImmediatePropagation) {
			event.stopImmediatePropagation();
		} else {

			// Part of the hack for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
			event.propagationStopped = true;
		}

		// Cancel the event
		event.stopPropagation();
		event.preventDefault();

		return false;
	}

	// If the mouse event is permitted, return true for the action to go through.
	return true;
};


/**
 * On actual clicks, determine whether this is a touch-generated click, a click action occurring
 * naturally after a delay after a touch (which needs to be cancelled to avoid duplication), or
 * an actual click which should be permitted.
 *
 * @param {Event} event
 * @returns {boolean}
 */
FastClick.prototype.onClick = function(event) {
	'use strict';
	var permitted;

	// It's possible for another FastClick-like library delivered with third-party code to fire a click event before FastClick does (issue #44). In that case, set the click-tracking flag back to false and return early. This will cause onTouchEnd to return early.
	if (this.trackingClick) {
		this.targetElement = null;
		this.trackingClick = false;
		return true;
	}

	// Very odd behaviour on iOS (issue #18): if a submit element is present inside a form and the user hits enter in the iOS simulator or clicks the Go button on the pop-up OS keyboard the a kind of 'fake' click event will be triggered with the submit-type input element as the target.
	if (event.target.type === 'submit' && event.detail === 0) {
		return true;
	}

	permitted = this.onMouse(event);

	// Only unset targetElement if the click is not permitted. This will ensure that the check for !targetElement in onMouse fails and the browser's click doesn't go through.
	if (!permitted) {
		this.targetElement = null;
	}

	// If clicks are permitted, return true for the action to go through.
	return permitted;
};


/**
 * Remove all FastClick's event listeners.
 *
 * @returns {void}
 */
FastClick.prototype.destroy = function() {
	'use strict';
	var layer = this.layer;

	if (deviceIsAndroid) {
		layer.removeEventListener('mouseover', this.onMouse, true);
		layer.removeEventListener('mousedown', this.onMouse, true);
		layer.removeEventListener('mouseup', this.onMouse, true);
	}

	layer.removeEventListener('click', this.onClick, true);
	layer.removeEventListener('touchstart', this.onTouchStart, false);
	layer.removeEventListener('touchmove', this.onTouchMove, false);
	layer.removeEventListener('touchend', this.onTouchEnd, false);
	layer.removeEventListener('touchcancel', this.onTouchCancel, false);
};


/**
 * Check whether FastClick is needed.
 *
 * @param {Element} layer The layer to listen on
 */
FastClick.notNeeded = function(layer) {
	'use strict';
	var metaViewport;
	var chromeVersion;

	// Devices that don't support touch don't need FastClick
	if (typeof window.ontouchstart === 'undefined') {
		return true;
	}

	// Chrome version - zero for other browsers
	chromeVersion = +(/Chrome\/([0-9]+)/.exec(navigator.userAgent) || [,0])[1];

	if (chromeVersion) {

		if (deviceIsAndroid) {
			metaViewport = document.querySelector('meta[name=viewport]');

			if (metaViewport) {
				// Chrome on Android with user-scalable="no" doesn't need FastClick (issue #89)
				if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
					return true;
				}
				// Chrome 32 and above with width=device-width or less don't need FastClick
				if (chromeVersion > 31 && window.innerWidth <= window.screen.width) {
					return true;
				}
			}

		// Chrome desktop doesn't need FastClick (issue #15)
		} else {
			return true;
		}
	}

	// IE10 with -ms-touch-action: none, which disables double-tap-to-zoom (issue #97)
	if (layer.style.msTouchAction === 'none') {
		return true;
	}

	return false;
};


/**
 * Factory method for creating a FastClick object
 *
 * @param {Element} layer The layer to listen on
 * @param {Object} options The options to override the defaults
 */
FastClick.attach = function(layer, options) {
	'use strict';
	return new FastClick(layer, options);
};


if (typeof define !== 'undefined' && define.amd) {

	// AMD. Register as an anonymous module.
	define(function() {
		'use strict';
		return FastClick;
	});
} else if (typeof module !== 'undefined' && module.exports) {
	module.exports = FastClick.attach;
	module.exports.FastClick = FastClick;
} else {
	window.FastClick = FastClick;
}
/**
 * Every component in the UI follows the same general patterns. This is to keep consistency and make coding easier.
 * <br><br><b>NOTE: The core component is an abstract base class and cannot be created as an instance on its own</b>
 * @namespace
 * @name CoreComponent
 * @memberof $ui
 * @property {namespace} component - The <b>mandatory</b> component property defines what type of component is being defined. This property always starts with a <b>$ui.</b> defining the component to be used for generating the UI.
 * @property {string} [id] - The id property is used to uniquely define the control in the screen for which it belongs. <br><br>Providing an id for your control is very convenient because you can easily access your control through your javascript coding. Each id is added as a direct handle on the screen object for access.
 * @property {boolean} [animated=false] - Set this value to <b>true</b> for the control to have animation.  NOTE: Each derivative control is responsible for their animation styling. Setting this property to true will add the ".animated" CSS class to the root element of the control.  Feel free to define your own CSS for the ".animated" property
 * @property {boolean} [visible=true] - The visible property specifies the visibility of the control. 
 * @property {boolean} [enabled=true] - The enabled property specifies the initial enabled state of the control.  <i>NOTE: Not all controls will render a disabled state. If you wish to render a disabled state simply override the ".disabled" CSS for the root of your control</i>
 * @property {$ui.CoreScreen} screen - This <b>readonly</b> property allows for you to reference the screen from the control. This will be the screen in which the control is embedded
 * @property {$ui.DataProviderLink} [provider] - This property allows you to bind the control to a [data provider]{@link $ui.DataProvider} in the application. 
 * @property {object[]} attachedObjects - This property specifies an array of objects that can be attached to the control. These could be objects such as data providers and usually entail a component that does not provide a user interface.
 * @property {boolean} [marginTop=false] - A boolean property which when set to true will place a standard margin on the top of the control. 
 * @property {boolean} [marginBottom=false] - A boolean property which when set to true will place a standard margin on the bottom of the control.
 * @property {boolean} [marginLeft=false] - A boolean property which when set to true will place a standard margin on the left of the control
 * @property {boolean} [marginRight=false] - A boolean property which when set to true will place a standard margin on the right of the control.
 */
function $ui_CoreComponent(object, screen) {
	try {
	if (object) {
		this.object = object;
		// The protected object is where we store our dynamic object variables
		object._protected = {
			model: object
		};
		
		// Create our base container for the control 
		object.dom = document.createElement('div');
		object.dom.model = object;
		$ui.addClass(object.dom, 'ui-core-component');
		
		// Assign our control name for automation & analytics
		if (object.id) {
			object.dom.setAttribute('data-id',object.id);
		}
		
		// Component Property
		object._protected.component = object.component;
		Object.defineProperty(object, 'component', {
			get: function() {return this._protected.component;},
			set: function() {
				console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','component'));
			},
			configurable: false} 
		);
		
		// Screen Property
		if (screen != undefined) {
			object.screen = screen;
			screen.children.push(object);
			if (object.id) {
        if (screen[object.id] != undefined) {
          var text = 'WARNING: You have used a non-unique id: "'+ object.id+'"';
          if (screen.id != undefined) {
            text = text + ' on screen "'+screen.id+'"';
          }
          console.log(text);
        }
				screen[object.id] = object;
			}
		}
		object._protected.screen = object.screen;
		Object.defineProperty(object, 'screen', {
			get: function() {return this._protected.screen;},
			set: function() {
				console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','screen'));
			},
			configurable: false}
		);
		
		// id property
		object._protected.id = object.id;
		Object.defineProperty(object, 'id', {
			get: function() {return this._protected.id;},
			set: function() {
				console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','id'));
			},
			configurable: false}
		);
		
		// Enabled Property
		if (object.enabled != false) {
			object.enabled = true;
		} else {
			$ui.addClass(object.dom, 'disabled');
		}
		object._protected.enabled = object.enabled;
		Object.defineProperty(object, 'enabled', {
			get: function() {return this._protected.enabled;},
			set: function(value) {
				if (value == this._protected.enabled) return;
				if (this._protected.enabled && (value == false)) {
					this._protected.enabled = false;
					$ui.addClass(this.dom, 'disabled');
				} else if ((this._protected.enabled == false) && (value == true)) {
					this._protected.enabled = true;
					$ui.removeClass(this.dom, 'disabled');
				}
				// Call a child class' protected function if they need
				// to do special handling for enabling
				if (this._setEnabled) {
					this._setEnabled(value);
				}
			},
			configurable: false}
		);		

		
		// Animated property
		if (object.animated == true) {
			$ui.addClass(object.dom, 'animated');
		} else {
			object.animated = false;
		}
		object._protected.animated = object.animated;
		Object.defineProperty(object, 'animated', {
			get: function() {return this._protected.animated;},
			set: function() {
				console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','animated'));
			},
			configurable: false}
		);
		
		// Set our initial visibility
		if ((object.visible != undefined) && (object.visible == false)) {
			object.dom.style.display = 'none';
		} else {
			object.visible = true;
		}
		object._protected.visible = object.visible;
		// Set our modification rules for 'visible'
		Object.defineProperty(object, 'visible', {
			get: function() {return this._protected.visible;},
			set: function(value) {
				if (value != this._protected.visible) {
					if (value == true) {
						this._protected.visible = true;
						if (this.dom != undefined) {
							this.dom.style.display = '';
						}
					} else {
						this._protected.visible = false;
						if (this.dom != undefined) {
							this.dom.style.display = 'none';
						}
					}
					// Allow of the top level control to also react to the visibility change
					if (this._setVisible) {
						this._setVisible(value);
					}
				} 
			},
			configurable: false}
		);
		
		// Attached Objects Property
		if (object.attachedObjects) {
			var i,
        j,
				control,
        extension,
				controlDom,
				targetScreen = (object.screen != undefined) ? object.screen : object; // The only control without a screen is a screen
			for (i = 0; i < object.attachedObjects.length; i++) {
				control = object.attachedObjects[i];
        if (control == undefined) {
    			throw 'CoreComponent.attachedObject: "control" is not defined';
    		} 
    		if (targetScreen == undefined) {
    			throw 'CoreComponent.attachedObject: "screen" is not defined';
    		}
    		// Find and create the attached object extension
    		for (j = 0; j < $ui._protected.definitions.length; j++) {
    			extension = $ui._protected.definitions[j];
    			if (extension.type != $ui.UIExtensionType.ATTACHED_OBJECT) continue;
    			if (extension.component == control.component) {
    				controlDom = new extension.constructor(control, object, targetScreen);
    				break;
    			}
    		}
				// If this control needs to be in the DOM add it
				if (controlDom instanceof HTMLElement) {
					object.dom.appendChild(controlDom);
				}
			}
		} else {
			object.attachedObjects = [];
		}
		object._protected.attachedObjects = object.attachedObjects;
		Object.defineProperty(object, 'attachedObjects', {
			get: function() {return this._protected.attachedObjects;},
			set: function(value) {
				console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','attachedObjects'));
			},
			configurable: false}
		);
		
		/** 
		 * This protected function will raise an interaction event for the <b>oninteraction</b> callback assigned to the {@link $ui} object.
		 * @memberof $ui.CoreComponent
		 * @protected 
		 * @function _raiseInteractionEvent
		 * @param {string} interaction - Desired interaction to raise
		 */
		object._raiseInteractionEvent = function(interaction) {
			var event = new InteractionEvent(this.screen.id, this.id, interaction, this.component);
			$ui._raiseInteractionEvent(event);
		}.$bind(object);
		
		
		// Private function to animate scrolling the control into view 
		object._scrollIntoView = function() {
			var step = 20,
				rect = this.dom.getBoundingClientRect(),
				scrollArea = this.dom.parentNode;
				
			this._scrollIterationCounter = this._scrollIterationCounter + 1;
			// See if it has reached the top of the screen
			if (rect.top == scrollArea.offsetTop) { 
				return;
			}
			
			// If the bottom and top of the control is visible
			if ((rect.bottom < (scrollArea.offsetTop + scrollArea.offsetHeight)) && (rect.top > scrollArea.offsetTop)) {
				return;
			}
				
			if (rect.top > scrollArea.offsetTop) { // Need to scroll down
				if (rect.top - scrollArea.offsetTop < step) {
					step = 1;
				}
				scrollArea.scrollTop = scrollArea.scrollTop + step;
			} else { // Need to scroll up
				if (scrollArea.offsetTop - rect.top < step) {
					step = 1;
				}
				scrollArea.scrollTop = scrollArea.scrollTop - step;
			}
			
			if (this._scrollIterationCounter > 100) { // Equivalent to moving something 2000 pixels
				console.log('fail safe scroll counter exceeded');
				return;
			}
			requestAnimationFrame(this._scrollIntoView);
		}.$bind(object);
		
		/** 
		 * This function will scroll the control into view for the user.
		 * @memberof $ui.CoreComponent
		 * @function scrollIntoView
		 */
		object.scrollIntoView = function() {
			if (this.dom) {
				this._scrollIterationCounter = 0;
				requestAnimationFrame(this._scrollIntoView);
			}
		}.$bind(object);
		
		// Public base destructor for the component
		object.destroy = function() {	
			// Call private destructor of control if it is there
			if (object._destroy) {
				object._destroy();
			}
			// Remove the provider listener
			if (this.provider != undefined) {
				if (this.provider.id != undefined) {
					window.removeEventListener(this.screen.guid+'-'+this.provider.id+'-updated', this._providerRefresh, false);
				}
			}	
      // Remove screen reference
      if (this.id != undefined && this.id.length > 0) {
				this.screen[this.id] = undefined;
			}
			// Clean-up any attached objects
			var i,
				attachedObject;
			if (this.attachedObjects && this.attachedObjects.length > 0) {
				for (i = 0; i < this.attachedObjects.length; i++) {
					attachedObject = this.attachedObjects[i];
					if (attachedObject._destroy) {
						attachedObject._destroy();
					}
				}
			}
			this.dom = undefined;
		}.$bind(object);
		
		// Handle a provider update
		object._providerRefresh = function() {
			// Find the data provider
			var dataProvider = this.screen[this.provider.id];
			if (dataProvider != undefined) {
				// Make sure it has some data assigned to it
				if (dataProvider.data != undefined) {
					var properties = this.provider.property.split('.'),
						i,
						data = dataProvider.data,
						found = true;
					// traverse it's hierarchy for our data value	
					for (i = 0; i < properties.length; i++) {
						data = data[properties[i]];
						if (data == undefined) {
							found = false;
							break;
						}
					}
					if (found) {
						if (this._providerUpdate) {
							this._providerUpdate(data);
						}
						return;
					} else {
						if (this._providerUpdate) {
							this._providerUpdate(undefined);
						}
					}
				} else {
					// If there was data we would not reach this point other wise it is undefined
					// so we have to check to see if it is an initial load so that we don't trigger 
					// the control's update unnecessarily 
					if (this._providerUpdate) {
						this._providerUpdate(undefined);
					}
				}
			} 
		}.$bind(object);
		
		
    // This function will remove the control from the screen
    object._remove = function() {
      if (this._onremove) {
        this._onremove();
      }
      // Remove node
      if (this.dom && this.dom.parentNode) {
        this.dom.parentNode.removeChild(this.dom);
      }
      if (this.screen) {
        var index = this.screen.children.indexOf(this);
        if (index >= 0) {
          this.screen.children.splice(index, 1);
        }
      }
      this.destroy();
    }.$bind(object);
    
		// This function will update the provider data source with new data from the control
		object._updateData = function(value) {
			// Find the data provider
			var dataProvider = (this.provider == undefined) ? undefined : this.screen[this.provider.id];
			if (dataProvider != undefined) {
				// Mark the property as updated
				dataProvider._propertyUpdated(this.provider.property, value);
				// Make sure it has some data assigned to it
				if (dataProvider.data != undefined) {
					var properties = this.provider.property.split('.'),
						i,
						data = dataProvider.data,
						currentValue;
					// traverse it's hierarchy for our data value	
					for (i = 0; i < properties.length; i++) {
						currentValue = data[properties[i]];
						if ((currentValue == undefined) && (i < (properties.length -1))) {
							break;
						} else if (i == (properties.length -1)) {
							data[properties[i]] = value;
							break;
						}
						data = currentValue;
					}
				}
			}
		}.$bind(object);
		
		// Data Provider Property
		if (object.provider != undefined) {
			if (object.provider.id != undefined) {
				// unique event listener for this provider on this screen
				window.addEventListener(object.screen.guid+'-'+object.provider.id+'-updated', object._providerRefresh, false);
				// Evaluate our bindings 
				object._providerRefresh();
			}
		}
		object._protected.provider = object.provider;
		Object.defineProperty(object, 'provider', {
			get: function() {return this._protected.provider;},
			set: function(value) {
				console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','provider'));
			},
			configurable: false}
		);
	}
	} catch (error) {
		console.log("RPW error in core component: " + error);
	}
}

/** 
 * The function assigned to this member will fire when the component has been asked to be removed from its parent. This is an <b>internal protected</b> member to be used by derivative controls and should not be bound to by application code
 * @name _onremove
 * @memberof $ui.CoreComponent
 * @protected
 * @type {function} 
 */

/** 
 * The function assigned to this member will fire when the screen the component belongs to receives an onshow event. This is an <b>internal protected</b> member to be used by derivative controls and should not be bound to by application code
 * @name _onshow
 * @memberof $ui.CoreComponent
 * @protected
 * @type {function} 
 */
 
 /** 
 * The function assigned to this member will fire when the toolkit has updated its theme. This is an <b>internal protected</b> member to be used by derivative controls and should not be bound to by application code
 * @name _onthemechange
 * @memberof $ui.CoreComponent
 * @protected
 * @type {function} 
 */

 
/** 
 * The function assigned to this member will fire when the screen that the component belongs to has it's viewport size changed. This is an <b>internal protected</b> member to be used by derivative controls and should not be bound to by application code
 * @name _onresize
 * @memberof $ui.CoreComponent
 * @protected
 * @type {function} 
 */

/** 
 * The function assigned to this member will fire when the screen that the component belongs to is just about to be popped. This will only fire if the screen is the top most screen in the stack. It allows for any clean-up that might need to be done before animating. This is an <b>internal protected</b> member to be used by derivative controls and should not be bound to by application code
 * @name _onbeforepop
 * @memberof $ui.CoreComponent
 * @protected
 * @type {function} 
 */

/**
 * This is the abstract base class that represents a component instance which contains other components. It derives from {@link $ui.CoreComponent}. 
 * <br><br><b>NOTE: This is an abstract class </b>
 * @namespace
 * @name CoreContainerComponent
 * @memberof $ui
 * @extends $ui.CoreComponent 
 * @property {boolean} [modified] - This property will cascade the <b>modified</b> value to all child controls contained in the control group <b>IF</b> the value is false.  Otherwise it will simply mark itself as modified.
 */
function $ui_CoreContainerComponent(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	if (object) {
		
		/**
		* Protected internal function for derivative controls to implement to return the control list array
		* @function _getControlListProperty
		* @memberof $ui.CoreContainerComponent
		* @returns {$ui.CoreComponent[]}
		* @protected
		*/
		
		/**
		* Protected internal function for derivative controls to implement to return the DOM element that contains the controls
		* @function _getControlListDom
		* @memberof $ui.CoreContainerComponent
		* @returns {HTMLElement}
		* @protected
		*/
		
		/**
		* Protected internal function for derivative controls to implement to react if there is a cascading of visibility
		* @function _oncascadevisibility
		* @memberof $ui.CoreContainerComponent
		* @protected
		*/
    
    /**
		* Protected internal function for derivative controls to implement to react to the results of the validation of the control
		* @function _onvalidate
    * @param {boolean} result
		* @memberof $ui.CoreContainerComponent
		* @protected
		*/
    
    /**
		* Protected internal function for derivative controls to implement to react to the change of the modified flag
		* @function _onmodified
		* @memberof $ui.CoreContainerComponent
		* @protected
		*/
		
		// modified property
		if (object.modified == undefined) {
			object.modified = false;
		} 
		object._protected.modified = object.modified;
		Object.defineProperty(object, 'modified', {
			get: function() {return this._protected.modified;},
			set: function(value) {
				if (value == undefined) value = false;
				this._protected.modified = value;
				if (this._getControlListProperty == undefined) {
					console.log('ERROR: _getControlListProperty not defined for CoreContainerComponent');
					return;
				}
        if (value == false) {
          var i,
  					control,
  					controlList = this._getControlListProperty();
  				for (i = 0; i < controlList.length; i++) {
  					control = controlList[i];
  					control.modified = value;
  				}
        }
        if (this._onmodified) {
          this._onmodified();
        }
			},
			configurable: false}
		);
		
		/** 
		 * Validate all the controls contained in this column (including nested controls) and return the boolean result
		 * @function validate
		 * @memberof $ui.CoreContainerComponent
		 * @returns {boolean}
		 */
		object.validate = function() {
			if (this._getControlListProperty == undefined) {
				console.log('ERROR: _getControlListProperty not defined for CoreContainerComponent');
				return false;
			}
			var i,
				control,
				controlList = this._getControlListProperty(),
				result = true;
			for (i = 0; i < controlList.length; i++) {
				control = controlList[i];
				if (control.validate)  {
					if (control.validate() == false) {
						result = false;
					}
				}
			}
      if (this._onvalidate) {
        this._onvalidate(result);
      }
			return result;
		}.$bind(object);
		
		// This function is called to cascade down a visibility change to child controls
		object._cascadeVisibility = function() {
			if (this._getControlListProperty == undefined) {
				console.log('ERROR: _getControlListProperty not defined for CoreContainerComponent');
				return;
			}
			var i,
				controlList = this._getControlListProperty(),
				control;			
			for (i = 0; i < controlList.length; i++) {
				control = controlList[i];
				if (control._cascadeVisibility) {
					control._cascadeVisibility();
				} else {
					if (control._onshow) {
						control._onshow();
					}
				}
			}
			if (this._oncascadevisibility) {
				this._oncascadevisibility();
			}
		}.$bind(object);
		
		
		// Internal function to create the component
		object._addComponent = function(control) {
			if (control == undefined) return;
			if (this._getControlListDom == undefined) {
				console.log('ERROR: _getControlListDom not defined for CoreContainerComponent');
				return;
			}
			var dom = this._getControlListDom();
			if (dom == undefined) {
				console.log('ERROR: _getControlListDom did not return a valid DOM element');
				return;
			}
			if (this.modified != undefined) {
				control.modified = this.modified;
			}
			$ui.createControl(control, this.screen);
			if (control.dom) {
				dom.appendChild(control.dom);
			}
		}.$bind(object);
		
		/** 
		 * Add a new control to the end of this container control
		 * @function addComponent
		 * @memberof $ui.CoreContainerComponent
		 * @param {$ui.CoreComponent} control - The control that you wish to add to the container control
		 */
		object.addComponent = function(control) {
			if (control == undefined) return;
			this._addComponent(control);
			if (this._getControlListProperty == undefined) {
				console.log('ERROR: _getControlListProperty not defined for CoreContainerComponent');
				return;
			}
			var list = this._getControlListProperty();
			if (list == undefined) {
				console.log('ERROR: _getControlListProperty did not return a valid object');
				return;
			}
			list.push(control);
			if (control._onshow) {
				control._onshow();
			}
			if (control.provider != undefined) {
				control._providerRefresh();
			}
		}.$bind(object);
		
		/** 
		 * Insert a new control into this container control before the targetControl
		 * @function insertComponentBefore
		 * @memberof $ui.CoreContainerComponent
		 * @param {$ui.CoreComponent} control - The control that you wish to insert to the container control
		 * @param {$ui.CoreComponent} targetControl - The target control that you wish to insert before 
		 */
		object.insertComponentBefore = function(control, targetControl) {
			if (control == undefined) return;
			if (targetControl == undefined) return;
			if (this._getControlListProperty == undefined) {
				console.log('ERROR: _getControlListProperty not defined for CoreContainerComponent');
				return;
			}
			var list = this._getControlListProperty();
			if (list == undefined) {
				console.log('ERROR: _getControlListProperty did not return a valid object');
				return;
			}
			if (this._getControlListDom == undefined) {
				console.log('ERROR: _getControlListDom not defined for CoreContainerComponent');
				return;
			}
			var dom = this._getControlListDom();
			if (dom == undefined) {
				console.log('ERROR: _getControlListDom did not return a valid DOM element');
				return;
			}
			// See if we can find the target control
			var i,
				item;
			for (i = 0; i < list.length; i++) {
				item = list[i];
				if (item == targetControl && item.dom && item.dom.parentNode) {
					if (this.modified != undefined) {
						control.modified = this.modified;
					}
					$ui.createControl(control, this.screen);
					if (control.dom) {
						item.dom.parentNode.insertBefore(control.dom, item.dom);
						list.splice(i, 0, control);
						if (control._onshow) {
							control._onshow();
						}
						if (control.provider != undefined) {
							control._providerRefresh();
						}
					}
					break;
				}
			}
			
			
		}.$bind(object);
		
		/** 
		 * Remove an existing control from this container control
		 * @function removeComponent
		 * @memberof $ui.CoreContainerComponent
		 * @param {$ui.CoreComponent} control - The control that you wish to remove from the screen
		 */
		object.removeComponent = function(control) {
			if (control == undefined) return;
			if (this._getControlListDom == undefined) {
				console.log('ERROR: _getControlListDom not defined for CoreContainerComponent');
				return;
			}
			if (this._getControlListProperty == undefined) {
				console.log('ERROR: _getControlListProperty not defined for CoreContainerComponent');
				return;
			}
			var dom = this._getControlListDom();
			if (dom == undefined) {
				console.log('ERROR: _getControlListDom did not return a valid DOM element');
				return;
			}
			var list = this._getControlListProperty();
			if (list == undefined) {
				console.log('ERROR: _getControlListProperty did not return a valid object');
				return;
			}
			var i,
				item;
			for (i = 0; i < list.length; i ++) {
				item = list[i];
				if (item == control) {
					list.splice(i,1);
          if (item.clearComponents) {
            item.clearComponents();
          }
          item._remove();
					break;
				}
			}
		}.$bind(object);
		
		/** 
		 * Remove all the child controls from this container control
		 * @function clearComponents
		 * @memberof $ui.CoreContainerComponent
		 */
		object.clearComponents = function() {
			if (this._getControlListProperty == undefined) {
				console.log('ERROR: _getControlListProperty not defined for CoreContainerComponent');
				return;
			}
			var list = this._getControlListProperty();
			if (list == undefined) {
				console.log('ERROR: _getControlListProperty did not return a valid object');
				return;
			}
			for (var i = list.length - 1; i >= 0; i--) {
				this.removeComponent(list[i]);
			}
				
		}.$bind(object);
		
		return object.dom;
	}
}
/**
 * This is the abstract base class that represents a screen instance. It derives from {@link $ui.CoreComponent}. 
 * A screen is declared as a JavaScript function and has various different properties. When a screen is pushed onto the stack a new instance of the screen will be created and rendered.<br><br>
 * If a derivative screen is using the <b>animated</b> property to animate a screen transition to show the screen, it must also provide a reverse animation effect within its <b>_onbeforepop</b> event.
 * <br><br><b>NOTE: This is an abstract class </b>
 * @namespace
 * @name CoreScreen
 * @memberof $ui
 * @extends $ui.CoreContainerComponent 
 * @property {GenericEvent} [onresize] - This event will fire when the viewport of the screen changes size
 * @property {boolean} [floatOnTop=false] - When set to <b>true</b> the screens below this screen will remain visible and have this screen float on top.
 * @property {DataEvent} [onshow] - This event will fire when the screen has been displayed
 * @property {DataEvent} [oncreate] - This event will when the screen has been initialized but has not yet been processed.  This allows you to make any changes to the screens properties before any of the controls are created.
 * @property {GenericEvent} [ondestroy] - This event will fire when the screen is about to be destroyed. Allowing for any memory clean-up routines
 * @property {GenericEvent} [onthemechange] - This event will fire when the theme for the toolkit has been updated
 * @property {CheckReadyStateEvent} [oncheckreadystate] - This event will fire when the screen is asked about its dirty state.  It allows the screen to manage its own state and can call the <b>readyCallback<b> function passed as a parameter when the screen is ready.  Being ready means that whomever asked about your state can be assured that everything is ok with the screen's state.
 */
function $ui_CoreScreen(object, data) {
	$ui_CoreContainerComponent.call(this, object);
	if (object) {
		object.data = data;
		object._protected.screen = object;
		// Guid Property
		object.guid = $ui.guid();
		object._protected.guid = object.guid;
		Object.defineProperty(object, 'guid', {
			get: function() {return this._protected.guid;},
			set: function() {
				console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','guid'));
			},
			configurable: false}
		);
		
		// floatOnTop Property
		if (object.floatOnTop != true) {
			object.floatOnTop = false;
		}
		object._protected.floatOnTop = object.floatOnTop;
		Object.defineProperty(object, 'floatOnTop', {
			get: function() {return this._protected.floatOnTop;},
			set: function() {
				console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','floatOnTop'));
			},
			configurable: false}
		);
		
		object.children = []; // Contains all child controls in the screen
		$ui.addClass(object.dom,'ui-core-screen');
		
		/**
		* Protected internal function for derivative screens to implement if they have specific functionality they wish to
		* do when the screen initializes.  This function will fire just before the <b>onshow</b> event is triggered for the screen.
		* @function _intitialize
		* @memberof $ui.CoreScreen
		* @protected
		*/
     
    /**
		* This function allows for querying the ready state of the screen which in turn will fire the <b>oncheckreadystate</b> event.  This can be useful when someone wishes to navigate away from the screen but a 
    * user has not yet saved their changes. It allows the screen to determine if it is safe to leave the screen or if some action needs to be handled.
		* @function checkReadyState
		* @memberof $ui.CoreScreen
		* @param {GenericEvent} readyCallback - Callback function to be fired when the screen is ready
    * @param {GenericEvent} [cancelCallback] - Callback function to be fired when the screen says that it is not ready
		*/
    object.checkReadyState = function(readyCallback, cancelCallback) {
      if (readyCallback == undefined) {
        console.log('ERROR: Cannot pass an undefined readyCallback to CoreScreen.checkReadyState()');
        return;
      }
      if (this.oncheckreadystate) {
        this.oncheckreadystate(readyCallback, cancelCallback);
      } else {
        readyCallback();
      }
    }.$bind(object);
		
		// Initialize the screen
		object.initialize = function() {
      this.dom.style['z-index'] = $ui.screens.length+1;
			$ui._protected.inScreenTransition = false;
			$ui._blockAllTapEvent(false);
			// See if there is an internal implementation of _initialize
			if (this._initialize) {
				this._initialize();
			}
			// Raise our onshow event
			if (this.onshow) {
				this.onshow(this.data);
			}
			// Fire the _onshow for all the controls
			var i,
				control;
			for (i = 0; i < this.children.length;i++) {
				control = this.children[i];
				if (control._onshow) {
					control._onshow();
				}
			}
      this._raiseInteractionEvent('data-interaction-screen-initialized');
		}.$bind(object);
		
		// Handle our internal update for theme changes
		object._onthemechange = function() {
			// Raise our onthemechange event
			if (this.onthemechange) {
				this.onthemechange();
			}
			// Fire the _onthemechange for all the controls
			var i,
				control;
			for (i = 0; i < this.children.length;i++) {
				control = this.children[i];
				if (control._onthemechange) {
					control._onthemechange();
				}
			}
		}.$bind(object);
		
		// Internal Resize event
		object._onresize = function() {
			// Fire the _onresize for all the controls
			var i,
				control;
			for (i = 0; i < this.children.length;i++) {
				control = this.children[i];
				if (control._onresize) {
					control._onresize();
				}
			}
		}.$bind(object);
		
		// Internal before pop event
		object.onbeforepop = function() {
			if (this._onbeforepop) {
				this._onbeforepop();
			}
			// Fire the _onbeforepop for all the controls
			var i,
				control;
			for (i = 0; i < this.children.length;i++) {
				control = this.children[i];
				if (control._onbeforepop) {
					control._onbeforepop();
				}
			}
		}.$bind(object);
		
		// Destroy screen
		object._destroy = function() {
			if (this.ondestroy) {
				this.ondestroy();
			}
			// Loop through all the children and call their destroy
			var i;
			for (i = 0; i < this.children.length; i++) {
				this.children[i].destroy();
			}
		}.$bind(object);
		
		return object.dom;
	}
}
/**
 * The DataEvent is used in a few places where an event needs to be fired an an optional data object passed to that event
 * @callback DataEvent
 * @param {object} [data] - The data that is being passed to this event
 */
 
 /**
 * The {@link $ui.CoreScreen} <b>oncheckreadystate</b> fires when the screen is asked about its ready state.  The screen has an opportunity to process its own state and then
 * fire the <b>readyCallback</b> function passed in as a paramenter when the screen is actually ready.  It may never fire the <b>readyCallback</b> if it is not ready.
 * @callback CheckReadyStateEvent
 * @param {GenericEvent} readyCallback - Callback function to be fired when the screen's state is ready
 * @param {GenericEvent} [cancelCallback] - Callback function to be fired when the screen says that it is <b>not</b> ready
 */
/**
 * The DataProvider component provides a data source that can be bound to controls on a screen. This provides the ability to both populate controls with data, as well as automatically save the data based on user interaction with the controls.<br><br>
 * <b>NOTE: The DataProvider should be attached to a screen or control using its [attachedObjects]{@link $ui.CoreComponent} property.</b><br><br>
 * <b>Sample Declaration</b>
 * <pre>
 * {
 *   component: $ui.DataProvider,
 *   id: 'myProvider',
 *   data_key: 'RATE_TYPE_CLASS_LIST',
 *   // highlight the first item in the list on load
 *   onload: function () {
 *     if (this.data && this.data.classes && this.data.classes.length > 0) {
 *       this.screen.rateTypeClassLayout.selectClass( this.data.classes[0]);
 *     }
 *   }
 *}
 * </pre>
 * @namespace
 * @name DataProvider
 * @memberof $ui
 * @property {object} component - The <b>required</b> component property defines what type of component is being defined. This property must be $ui.DataProvider
 * @property {string} id - The <b>required</b> id property is used to uniquely define the data provider in the scope of the screen in which it belongs. Providing an id for your data provider is required because you can easily access your provider through your javascript coding and also reference it as the provider for a control.
 * 
 * @property {string} [data_key] - A string reference to a unique, registered data service key; This is required by the <b>fetch</b> method
 * @property {string} [data_resource]  A string overriding the name of the resource to retrieve; For JSON file requests, the name is prefixed and .json is added as the extension
 * @property {string} [data_type]  A string overriding the type of resource to retrieve (see $data.data_service_types for valid options)
 * 
 * @property {object} [data] - The data property by default is undefined. You can populate the data property as any kind of object. The data property holds the object that represents the data for the provider
 * @property {GenericEvent} [onload] - This event will fire when the data has been successfully loaded into the provider and controls have been updated
 * @property {GenericEvent} [onbeforeupdate] - This event will fire when the data property has been successfully set, but has not yet been used to update any controls connected to the provider. This gives you an opportunity to manipulate the data property of the data provider <b>before</b> controls are updated
 */
function $ui_DataProvider(object, component, screen){
	// Create our protected area
	object._protected = {
		model: object,
		updates: []
	};
	
	// Attach the ID to the main screen object
	if (object.id && screen) {
		screen[object.id] = object;
	}
	
	// Component Property
	object._protected.component = object.component;
	Object.defineProperty(object, 'component', {
		get: function() {return this._protected.component;},
		set: function() {
			console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','component'));
		},
		configurable: false}
	);
	
	// Screen property
	object.screen = screen;
	object._protected.screen = object.screen;
	Object.defineProperty(object, 'screen', {
		get: function() {return this._protected.screen;},
		set: function() {
			console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','screen'));
		},
		configurable: false}
	);
	
	// Data property
	object._protected.data = object.data;
	Object.defineProperty(object, 'data', {
		get: function() {return this._protected.data;},
		set: function(value) {
			this._protected.data = value;
			this._protected.updates = [];
			if (this.onbeforeupdate) {
				this.onbeforeupdate();
			}
			this._raiseEvent();
			if (value == undefined) return;
			if (this.onload) {
				this.onload();
			}
		},
		configurable: false}
	);

  object.clear = function() {
    // iterate through data object and reset each property to undefined
    var data = object.data,
      clear_data = {};
    for (var property in data) {
      if (data.hasOwnProperty(property)) {
        clear_data[property] = undefined;
      }
    }
    object.data = clear_data;
  };

  /**
   * The fetch function retrieves and populates the DataProvider's data property.
   * The fetch function will only work if the global <b>$ui.init()</b> function has been passed an option parameter that has configured the <b>globalDataProvider</b> value
   * @function fetch
   * @memberof $ui.DataProvider
   * @param onfail - this callback function is invoked if unable to retrieve the requested data
   * @param transform - an optional data transformation function that takes the data as a parameter
   *  and returns the transformed data
   */
  object.fetch = function(onfail, transform) {
    if ($ui.options.globalDataProvider != undefined) {
      $ui.options.globalDataProvider._getData.call(this.screen, this, function(data) {
        if (transform) {
          data = transform(data);
        }
        object.data = data;}, onfail);
    }
  }.$bind(object);

	/** 
	 * The refresh function will send a signal out to all connected components to refresh their data from the current content in memory from the provider. <b>NOTE: No <i>onbeforeupdate</i> or <i>onload</i> event will fire on the provider</b>
	 * @function refresh
	 * @memberof $ui.DataProvider
	 */
	object.refresh = function() {
		this._raiseEvent();
	}.$bind(object);
	
	/** 
	 * The getUpdates function will return an array of field updates on the provider since its data property has been set.
	 * @function getUpdatedFields
	 * @memberof $ui.DataProvider
	 * @returns {ProviderUpdate[]}
	 */
	object.getUpdatedFields = function() {
		var i,
			result = [];
		for (i = 0; i < this._protected.updates.length; i++) {
			result.push(this._protected.updates[i]); 
		}
		return result;		
	}.$bind(object);
	
	// Maintain a list of updated data
	object._propertyUpdated = function(property, value) {
		var i,
			entry,
			found = false,
			newEntry = {
				property: property,
				value: value
			};
		// See if we just need to update an existing entry
		for (i = 0; i < this._protected.updates.length; i++) {
			entry = this._protected.updates[i];
			if (entry.property == property) {
				this._protected.updates[i] = newEntry;
				found = true;
				break;
			}
		}
		if (found == false) {
			this._protected.updates.push(newEntry);
		}
	}.$bind(object);
	
	// Raise our event to let the rest of the app know to refresh
	object._raiseEvent = function() {
		var evt = document.createEvent('Events');
		evt.initEvent(this.screen.guid+'-'+this.id+'-updated', true, true);
		window.dispatchEvent(evt);
	}.$bind(object);
	
	// Private function to handle clean-up
	object._destroy = function() {
		this._protected.data = undefined;
	}.$bind(object);
	
	// See if the data was pre-defined
	if (object.data != undefined) {
		if (object.onbeforeupdate) {
			object.onbeforeupdate();
		}
		if (object.onload) {
			object.onload();
		}
	}
	
	return undefined;
}

/**
 * A data provider link provides a binding between a [control]{@link $ui.CoreComponent} and a data provider. The path for the <b>property</b> attribute starts at the root of the object that is provided as the data source for the data provider.<br><br>
 * The type of object that the property path should point to is dependent on the control and the data it uses to display and/or edit. If the control also allows the user to edit data or change settings, these changes will be applied to the property value in the data provider.<br><br>
 * <b>Sample Code:</b><br>
 * <pre>provider: {
 *    id: 'myProvider',
 *    property: 'posts'
 * }
 * </pre>
 * <br>
 * To access sub objects in the object chain from the data provider you can use normal <b>dot</b> notation:<br><br>
 * <b>Sample Code:</b><br>
 * <pre>provider: {
 *    id: 'myProvider',
 *    property: 'posts.item.thingy'
 * }
 * </pre>
 * <br>
 * @namespace
 * @name DataProviderLink
 * @memberof $ui
 * @property {string} id - This is the <b>mandatory</b> id of the data provider belonging to the screen which will be linked to this control.  
 * @property {string} property - This is the property path/name of the object to be used as the bound data for this control. A nested property can be defined simply by providing a path using <b>.</b> dot separators just like you were referring to the object via JavaScript
 */
 
 
/**
 * The ProviderUpdate is a value that specifies a property name from a {@link $ui.DataProvider} and the new value of the property
 * @namespace ProviderUpdate
 * @memberof $ui.DataProvider
 * @property [string] property - The name of the property updated
 * @property [object] value - The new value of the property
 */
 
 /**
 * The GlobalDataProviderEvent is used when initializing the toolkit and 
 * @callback GlobalDataProviderEvent
 * @param {$ui.DataProvider} dataProvider - The DataProvider instance
 * @param {DataEvent} callback - The callback data event to be fired when data is ready
 * @param {GenericEvent} onfail - Callback to be triggered if there was an error during retrieval
 */
/**
 * Represents an interaction event from the user interface.  This event is raised when a user interacts with a part of the interface. All interation events are sent to the $ui.oninteraction 
 * assigned function.  If valid values are not passed in for all of the parameters no event will be raised.
 * @class InteractionEvent
 * @param {string} screenId - The <b>id</b> property of the screen which contains the control providing the interaction
 * @param {string} controlID - The <b>id</b> property of the control in which the user interacted
 * @param {string} interaction - The interaction which took place
 * @param {object} component - The component type definition for which this interaction took place.   An example could be the value $ui.List.  This is <b>not</b> a pointer to the control.
 */
function InteractionEvent(screenId, controlId, interaction, component) {
	/**
	 * The <b>id</b> property of the screen which contains the control providing the interaction
	 * @member {string} screenId
	 * @memberOf InteractionEvent
	 */
	this.screenId = screenId;
	
	 /**
	 * The <b>id</b> property of the control in which the user interacted
	 * @member {string} controlId
	 * @memberOf InteractionEvent
	 */
	this.controlId = controlId;
	
	 
	 /**
	 * The interaction which took place
	 * @member {string} interaction
	 * @memberOf InteractionEvent
	 */
	this.interaction = interaction;
	
	/**
	 * The component type definition for which this interaction took place.  An example could be the value $ui.List.  This is <b>not</b> a pointer to the control
	 * @member {object} component
	 * @memberOf InteractionEvent
	 */
	this.component = component;
}


 


/**
 * A List object will display multiple list items based on the data provided to the control.  The type of item objects that are used should match the declaration of the <b>style</b> of the list control.<br><br>
 * The type of data provider value for a list control should point to a property in the data provider that would follow the same rules as hard coding an array of items.<br><br>
 * <b>Sample Declaration</b><br>
 * <pre>
 * {
 *   component: $ui.List,
 *   style: $ui.GenericListItem,
 *   items: [
 *      {
 *         img: 'thumbnails/foo.png',
 *         title: 'This is my title',
 *         accent: '6 hours ago',
 *         caption: 'My summary description'
 *      }
 *   ]
 *}
 * @namespace
 * @name List
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {object[]} [items] - The items property is an array of objects who's definition matches that of the requirements of the <b>style</b> property of the list
 * @property {object} style - This is a list item decalaration so that the list knows how to render. For example this could be set to {@link $ui.GenericListItem}
 * @property {ListActionEvent} [onaction] - The onaction event will fire when an action from a list item is triggered. Some list items may have multiple actions that can be taken. When one of these actions is selected by the user the onaction event will fire.
 * @property {GenericEvent} [onitemschanged] - The onitemschanged event will fire when any items have been added or removed from the list.  This will also fire on data provider updates.
 */
function $ui_List(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom,'ui-list');
	
	// Set our items property
	if (object.items == undefined) {
		object.items = [];
	}
	object._protected.items = object.items;
	Object.defineProperty(object, 'items', {
		get: function() {return this._protected.items;},
		set: function() {
			console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','items'));
		},
		configurable: false}
	);

	// Broker the onaction from a list item
	object._onaction = function(item, event) {
		if (this.onaction) {
			this.onaction(event);
		}
	}.$bind(object);
	
	// Create the DOM for a list item depending on the list type
	object._createItemDom = function(item) {
		var dom;
		// See if the item is a header
		if (item.component && (item.component == $ui.Header)) {
			dom = $ui.createControl(item,this.screen);
		} else if (this._itemConstructor != undefined) {
			dom = new this._itemConstructor(item,this.screen);
		}
		return dom;
	}.$bind(object);
	
	// Private function to add a new item to the list
	object._addItem = function(item) {
		item.parent = this;
		itemDom = this._createItemDom(item);
		if (itemDom) {
			this.dom.appendChild(itemDom);
			if (item._onafterinsert) {
				item._onafterinsert();
			}
			return true;
		} else {
			return false;
		}
	}.$bind(object);
	
	/** 
	 * You can add an item to the end of the list by calling the addItem function and passing in an object that matches the a list item
	 * @function addItem
	 * @memberof $ui.List
	 * @param {object} item - Item to be added to the list
	 */
	object.addItem = function(item) {
		if (this._addItem(item)) {
			this.items.push(item);
			// Trigger our changed event
			if (this.onitemschanged) {
				this.onitemschanged();
			}
			if (item._onshow) {
				item._onshow();
			}
			return true;
		} else {
			return false;
		}
	}.$bind(object);
	
	/** 
	 * The remove item function will remove an existing item from a list. If an invalid item is specified the removal will fail
	 * @function removeItem
	 * @memberof $ui.List
	 * @param {object} item - Item to be removed from the list
	 */
	object.removeItem = function(item) {
		if (item == undefined) return false;
		var index = this.items.indexOf(item);
		if (index < 0) return false;
		try {
			this.dom.removeChild(item.dom);
		} catch (ex) {
			console.log('$ui.List: ' + ex);
		}
		this.items.splice(index, 1);
		item.destroy(); 
		// Trigger our changed event
		if (this.onitemschanged) {
			this.onitemschanged();
		}
	}.$bind(object);
	
	/** 
	 * Insert item works similar to addItem but instead will insert the item into the list at the index specified. If an invalid index is specified it will result in failure to insert the item. To insert an item at the top of a list call insert with the index of 0.
	 * @function insertItem
	 * @memberOf $ui.List
	 * @param {object} item - Item to be inserted into the list
	 * @param {number} index - Index to insert the item
	 */
	object.insertItem = function(item, index) {
		item.parent = this;
		if (index < 0) {
			return false;
		} else if (this.items.length == 0) {
			this.addItem(item);
			return true;
		} else if (index > this.items.length - 1) {
			this.addItem(item);
			return true;
		} else { // Insert it at the index
			var existingItem = this.items[index],
				itemDom = this._createItemDom(item);
			this.items.splice(index, 0, item);
			this.dom.insertBefore(itemDom, existingItem.dom);
			// Trigger our changed event
			if (this.onitemschanged) {
				this.onitemschanged();
			}
			if (item._onshow) {
				item._onshow();
			}
			return true;
		} 
		return false;
	}.$bind(object);
	
	/** 
	 * You can refresh all the items in a list by calling the refreshItems function with an array of new items
	 * @function refreshItems
	 * @memberof $ui.List
	 * @param {object[]} items - Array of items to refresh the list
	 */
	object.refreshItems = function(itemArray) {
		var i,
			item;
		if (this.items) {
			// Remove all existing items first
			for (i = this.items.length - 1; i >= 0; i--) {
				item = this.items[i];
				try {
					this.dom.removeChild(item.dom);
				} catch (ex) {
					console.log('$ui.List: ' + ex);
				}
				this.items.pop();
				item.destroy();
			}
		}
		if (itemArray == undefined) return; // No data provided
		this.addItemBatch(itemArray);
		// Trigger our changed event
		if (this.onitemschanged) {
			this.onitemschanged();
		}
	}.$bind(object);
	
	/** 
	 * This function is much like the refreshItems function but instead it loads a list of items to the end of the current list and does not replace the existing list items.
	 * @function addItemBatch
	 * @memberof $ui.List
	 * @param {object[]} items - Array of items to be added to the list
	 */
	object.addItemBatch = function(itemArray) {
		var i,
			item;
		// Add all new items into the list
		for (i = 0; i < itemArray.length; i++) {
			item = itemArray[i];
			this.addItem(item);
		}
	}.$bind(object);
	
	/** 
	 * This function will filter the list items based on the name value pairs of search criteria.  All search criteria will be AND'ed
	 * @function filter
	 * @memberof $ui.List
	 * @param {ListFilter[]} filters - Array of filters to be used for this list
	 */
	object.filter = function(filters) {
		if (filters == undefined || filters == null) return;
		var i,
			j,
			filter,
			item,
			pattern,
			match = true;;
		for (i = 0; i < this.items.length; i++) {
			item = this.items[i];
			match = true;
			for (j = 0; j < filters.length; j++) {
				filter = filters[j];
				if (item[filter.name] != undefined) {
					pattern = new RegExp(filter.expression, 'gi');
					if (pattern.test(item[filter.name]) == false) {
						match = false;
						break;
					}
				}
			}
			item.visible = match;
		}
	}.$bind(object);
	
	/** 
	 * This function will reset any filter applied to the List
	 * @function filterReset
	 * @memberof $ui.List
	 */
	object.filterReset = function(filter) {
		var i;
		for (i = 0; i < this.items.length; i++) {
			this.items[i].visible = true;
		}
		
	}.$bind(object);
	
	
	// Private function to handle provider updates
	object._providerUpdate = function(value) {
		this.refreshItems(value);
	}.$bind(object);
	
	
	var i,
		extension;
	// Determine our item constructor
	for (i = 0; i < $ui._protected.definitions.length; i++) {
		extension = $ui._protected.definitions[i];
		if (extension.type != $ui.UIExtensionType.LISTITEM) continue;
		if (extension.component == object.style) {
			object._itemConstructor = extension.constructor;
			break;
		}
	}

	// Cycle through list items
	var	item,
		index;
	if (object.items) {
		for (i = 0; i < object.items.length; i++) {
			item = object.items[i];
			object._addItem(item);
		}
		// Trigger our changed event
		if (object.onitemschanged) {
			object.onitemschanged();
		}
	}
	
	// Relay the _onshow to list items
	object._onshow = function() {
		var i,
			item;
		for (i = 0; i < this.items.length; i++) {
			item = this.items[i];
			if (item._onshow) {
				item._onshow();
			}
		}
	}.$bind(object);
	
	return object.dom;
}

/**
 * The {@link $ui.List} <b>onaction</b> event will fire when the user interacts with a list item
 * @callback ListActionEvent
 * @param {ListEvent} event - The list event which was raised
 */
 
 /**
 * The {@link $ui.List} <b>onaction</b> event will fire when the user interacts with a list item
 * @class ListFilter
 * @memberof $ui
 * @param {string} name - The name of the property to be filtered
 * @param {string} expression - The regular expression to use to evaluate against the value of the named list item property
 */
 $ui.ListFilter = function(name, expression) {
	 this.name = name;
	 this.expression = expression;
 }
/**
 * The list event is what is triggered when a user interacts with the List control. It contains the target list item that the user was interacting with, the type of event which was triggered 
 * and an optional data property that contains extra data about the event.
 * @class ListEvent
 * @param {object} target - Target list item where the event originated
 * @param {string} eventType - The type of event that was triggered. Each list item has its own set of possible events that can be raised
 * @param {object} [data] - Optional data that can be passed with a list event
 */
function ListEvent(target, eventType, data) {
	/** 
	 * Target list item where the event originated
	 * @member {object} target
	 * @memberOf ListEvent
	 */
	this.target = target;
	
	/** 
	 * The type of event that was triggered. Each list item has its own set of possible events that can be raised
	 * @member {string} eventType
	 * @memberOf ListEvent
	 */
	this.eventType = eventType;
	
	/** 
	 * Optional data that can be passed with a list event
	 * @member {object} [data]
	 * @memberOf ListEvent
	 */
	this.data = data;
}


/**
 * The spinner control provides you the ability to give a visual indicator when your content is loading. The spinner has one main property <b>size</b>. <br><br>
 * <b>Sample Declaration</b><br>
 * <pre>
 * {
 *   component: $ui.Spinner,
 *   size: $ui.Spinner.SpinnerSize.LARGE
 *}
 * @namespace Spinner
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {$ui.Size} [size=$ui.Size.NORMAL] - Represents the size of the spinner component.
 * @property {$ui.Spinner.SpinnerColor} [forceColor] - This property specifies if the color should be forced to be dark or light. By default the system figures this out and does not need to be set. However, if you want to force a color in a certain scenario you can use this property.
 */
function $ui_Spinner(object, screen){
	$ui_CoreComponent.call(this, object, screen);
	// Size property
	object.size = (object.size) ? object.size : $ui.Size.NORMAL;
	object._protected.size = object.size;
	Object.defineProperty(object, 'size', {
		get: function() {return this._protected.size;},
		set: function(value) {
			if (this._protected.size == value) return;
			$ui.removeClass(this.dom, this._protected.size);
			this._protected.size = value;
			$ui.addClass(this.dom,value);			
		},
		configurable: false}
	);
	
	$ui.addClass(object.dom, 'ui-spinner')
	$ui.addClass(object.dom, object.size);
	$ui.addClass(object.dom, 'center');
	
	// Create the inner div
	object.dom.innerDiv = document.createElement('div');
	$ui.addClass(object.dom.innerDiv, 'inner');
	object.dom.appendChild(object.dom.innerDiv);
	
	// forceColor property
	object._protected.forceColor = object.forceColor;
	if (object.forceColor) {
		$ui.addClass(object.dom.innerDiv, object.forceColor);
	} else {
		if ($ui.theme.rootClass && $ui.theme.rootClass.indexOf('ui-theme-dark') > -1)  {
			$ui.addClass(object.dom.innerDiv, 'light');
		} else {
			$ui.addClass(object.dom.innerDiv, 'dark');
		}
	}
	Object.defineProperty(object, 'forceColor', {
		get: function() {return this._protected.forceColor;},
		set: function() {
			console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','forceColor'));			
		},
		configurable: false}
	);
	
	return object.dom
}

$ui_Spinner.prototype = new $ui_CoreComponent();
/**
 * The definition of an extension to be used in extending the <b>$ui</b> framework.
 * @class
 * @param {string} name - This would be the value you set as the <b>component</b> property for your control
 * @param {function} constructor - The function to be used as your control constructor
 * @param {$ui.UIExtensionType} [type=$ui.UIExtensionType.CONTROL] - The type of extension you are registering
 * @param {object} [definition] - Class definition for your extension, you can include properties such as constants here
 */
function UIExtension(name, constructor, type, definition) {
	/** 
	 * This would be the value you set as the <b>component</b> property for your control
	 * @member {string} name
	 * @memberOf UIExtension
	 */
	if (name == null) throw new Error('UIExtension: name cannot be null');
	if (name == undefined) throw new Error('UIExtension: name cannot be undefined');
	this.name = name;
	/** 
	 * The function to be used as your control constructor
	 * @member {function} constructor
	 * @memberOf UIExtension
	 */
	if (constructor == null) throw new Error('UIExtension: constructor cannot be null');
	if (constructor == undefined) throw new Error('UIExtension: constructor cannot be undefined');
	this.constructor = constructor;
	/** 
	 * The type of extension you are registering
	 * @member {$ui.UIExtensionType} [type=$ui.UIExtensionType.CONTROL]
	 * @memberOf UIExtension
	 */
	if (type == null || type == undefined) {
		this.type = $ui.UIExtensionType.CONTROL;
	} else if ((type != $ui.UIExtensionType.CONTROL) && (type != $ui.UIExtensionType.SCREEN) && (type != $ui.UIExtensionType.LISTITEM) && (type != $ui.UIExtensionType.ATTACHED_OBJECT)) {
		throw new Error('UIExtension: type is an invalid value');
	} else {
		this.type = type;
	}
	/** 
	 * Class definition for your extension, you can include properties such as constants here
	 * @member {object} [definition]
	 * @memberOf UIExtension
	 */
	if (definition == null || definition == undefined) {
		this.definition = {};
	} else {
		this.definition = definition;
	}
}
/**
 * The Button represents a standard button in the UI. 
 * <br><br><b>Sample Declaration</b>
 * <pre>
 * {
 *   component: $ui.Button,
 *   caption: 'Click Me'
 * }
 * </pre>
 * @namespace Button
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {string} caption - Represents the main text to show in the list item
 */
function $ui_Button(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom, 'ui-button theme-brand-background-color theme-highlight-text-color theme-border-color');
	if ($ui.theme.inHeadUnit == true) {
		$ui.addClass(object.dom, 'in-head-unit');
	}

	// Caption
	//object.dom.captionDiv = document.createElement('div');
	//$ui.addClass(object.dom.captionDiv,'caption theme-text-color');
	//object.dom.appendChild(object.dom.captionDiv);
	
	// caption property
	if (object.caption == undefined) {
		object.caption = '';
	}
	object.dom.textContent = object.caption;
	object._protected.caption = object.caption;
	Object.defineProperty(object, 'caption', {
		get: function() {return this._protected.caption;},
		set: function(value) {
			if (value == undefined) value = '';
			if (value == this._protected.caption) return;
			this._protected.caption = value;
			this.dom.textContent = value;
		},
		configurable: false}
	);
	
	
	// Handle our touch events
	object.dom.ontouchstart = function() {
		this.style.opacity = 0.7;
	}
	object.dom.ontouchend = function() {
		this.style.opacity = 1;
	}
	object.dom.ontouchcancel = object.dom.ontouchend;
	if (!$ui.isMobileDevice()) {
		object.dom.onmousedown = object.dom.ontouchstart;
		object.dom.onmouseup = object.dom.ontouchend;
		object.dom.onmouseleave = object.dom.ontouchend;
	}

	// Pass the onclick back to the list
	object.dom.onclick = function() {
		$ui.playTouchSound();
		if (this.model.onclick) {
			this.model.onclick();
		}
	};

	return object.dom;
}
/*!
 * Chart.js
 * http://chartjs.org/
 * Version: 1.0.1
 *
 * Copyright 2015 Nick Downie
 * Released under the MIT license
 * https://github.com/nnnick/Chart.js/blob/master/LICENSE.md
 */
(function(){"use strict";var t=this,i=t.Chart,e=function(t){this.canvas=t.canvas,this.ctx=t;this.width=t.canvas.width,this.height=t.canvas.height;return this.aspectRatio=this.width/this.height,s.retinaScale(this),this};e.defaults={global:{animation:!0,animationSteps:60,animationEasing:"easeOutQuart",showScale:!0,scaleOverride:!1,scaleSteps:null,scaleStepWidth:null,scaleStartValue:null,scaleLineColor:"rgba(0,0,0,.1)",scaleLineWidth:1,scaleShowLabels:!0,scaleLabel:"<%=value%>",scaleIntegersOnly:!0,scaleBeginAtZero:!1,scaleFontFamily:"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",scaleFontSize:12,scaleFontStyle:"normal",scaleFontColor:"#666",responsive:!1,maintainAspectRatio:!0,showTooltips:!0,customTooltips:!1,tooltipEvents:["mousemove","touchstart","touchmove","mouseout"],tooltipFillColor:"rgba(0,0,0,0.8)",tooltipFontFamily:"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",tooltipFontSize:14,tooltipFontStyle:"normal",tooltipFontColor:"#fff",tooltipTitleFontFamily:"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",tooltipTitleFontSize:14,tooltipTitleFontStyle:"bold",tooltipTitleFontColor:"#fff",tooltipYPadding:6,tooltipXPadding:6,tooltipCaretSize:8,tooltipCornerRadius:6,tooltipXOffset:10,tooltipTemplate:"<%if (label){%><%=label%>: <%}%><%= value %>",multiTooltipTemplate:"<%= value %>",multiTooltipKeyBackground:"#fff",onAnimationProgress:function(){},onAnimationComplete:function(){}}},e.types={};var s=e.helpers={},n=s.each=function(t,i,e){var s=Array.prototype.slice.call(arguments,3);if(t)if(t.length===+t.length){var n;for(n=0;n<t.length;n++)i.apply(e,[t[n],n].concat(s))}else for(var o in t)i.apply(e,[t[o],o].concat(s))},o=s.clone=function(t){var i={};return n(t,function(e,s){t.hasOwnProperty(s)&&(i[s]=e)}),i},a=s.extend=function(t){return n(Array.prototype.slice.call(arguments,1),function(i){n(i,function(e,s){i.hasOwnProperty(s)&&(t[s]=e)})}),t},h=s.merge=function(){var t=Array.prototype.slice.call(arguments,0);return t.unshift({}),a.apply(null,t)},l=s.indexOf=function(t,i){if(Array.prototype.indexOf)return t.indexOf(i);for(var e=0;e<t.length;e++)if(t[e]===i)return e;return-1},r=(s.where=function(t,i){var e=[];return s.each(t,function(t){i(t)&&e.push(t)}),e},s.findNextWhere=function(t,i,e){e||(e=-1);for(var s=e+1;s<t.length;s++){var n=t[s];if(i(n))return n}},s.findPreviousWhere=function(t,i,e){e||(e=t.length);for(var s=e-1;s>=0;s--){var n=t[s];if(i(n))return n}},s.inherits=function(t){var i=this,e=t&&t.hasOwnProperty("constructor")?t.constructor:function(){return i.apply(this,arguments)},s=function(){this.constructor=e};return s.prototype=i.prototype,e.prototype=new s,e.extend=r,t&&a(e.prototype,t),e.__super__=i.prototype,e}),c=s.noop=function(){},u=s.uid=function(){var t=0;return function(){return"chart-"+t++}}(),d=s.warn=function(t){window.console&&"function"==typeof window.console.warn&&console.warn(t)},p=s.amd="function"==typeof define&&define.amd,f=s.isNumber=function(t){return!isNaN(parseFloat(t))&&isFinite(t)},g=s.max=function(t){return Math.max.apply(Math,t)},m=s.min=function(t){return Math.min.apply(Math,t)},v=(s.cap=function(t,i,e){if(f(i)){if(t>i)return i}else if(f(e)&&e>t)return e;return t},s.getDecimalPlaces=function(t){return t%1!==0&&f(t)?t.toString().split(".")[1].length:0}),S=s.radians=function(t){return t*(Math.PI/180)},x=(s.getAngleFromPoint=function(t,i){var e=i.x-t.x,s=i.y-t.y,n=Math.sqrt(e*e+s*s),o=2*Math.PI+Math.atan2(s,e);return 0>e&&0>s&&(o+=2*Math.PI),{angle:o,distance:n}},s.aliasPixel=function(t){return t%2===0?0:.5}),y=(s.splineCurve=function(t,i,e,s){var n=Math.sqrt(Math.pow(i.x-t.x,2)+Math.pow(i.y-t.y,2)),o=Math.sqrt(Math.pow(e.x-i.x,2)+Math.pow(e.y-i.y,2)),a=s*n/(n+o),h=s*o/(n+o);return{inner:{x:i.x-a*(e.x-t.x),y:i.y-a*(e.y-t.y)},outer:{x:i.x+h*(e.x-t.x),y:i.y+h*(e.y-t.y)}}},s.calculateOrderOfMagnitude=function(t){return Math.floor(Math.log(t)/Math.LN10)}),C=(s.calculateScaleRange=function(t,i,e,s,n){var o=2,a=Math.floor(i/(1.5*e)),h=o>=a,l=g(t),r=m(t);l===r&&(l+=.5,r>=.5&&!s?r-=.5:l+=.5);for(var c=Math.abs(l-r),u=y(c),d=Math.ceil(l/(1*Math.pow(10,u)))*Math.pow(10,u),p=s?0:Math.floor(r/(1*Math.pow(10,u)))*Math.pow(10,u),f=d-p,v=Math.pow(10,u),S=Math.round(f/v);(S>a||a>2*S)&&!h;)if(S>a)v*=2,S=Math.round(f/v),S%1!==0&&(h=!0);else if(n&&u>=0){if(v/2%1!==0)break;v/=2,S=Math.round(f/v)}else v/=2,S=Math.round(f/v);return h&&(S=o,v=f/S),{steps:S,stepValue:v,min:p,max:p+S*v}},s.template=function(t,i){function e(t,i){return i.value;var e=/\W/.test(t)?new Function("obj","var p=[],print=function(){p.push.apply(p,arguments);};with(obj){p.push('"+t.replace(/[\r\t\n]/g," ").split("<%").join("	").replace(/((^|%>)[^\t]*)'/g,"$1\r").replace(/\t=(.*?)%>/g,"',$1,'").split("	").join("');").split("%>").join("p.push('").split("\r").join("\\'")+"');}return p.join('');"):s[t]=s[t];return i?e(i):e}if(t instanceof Function)return t(i);var s={};return e(t,i)}),w=(s.generateLabels=function(t,i,e,s){var o=new Array(i);return labelTemplateString&&n(o,function(i,n){o[n]=C(t,{value:e+s*(n+1)})}),o},s.easingEffects={linear:function(t){return t},easeInQuad:function(t){return t*t},easeOutQuad:function(t){return-1*t*(t-2)},easeInOutQuad:function(t){return(t/=.5)<1?.5*t*t:-0.5*(--t*(t-2)-1)},easeInCubic:function(t){return t*t*t},easeOutCubic:function(t){return 1*((t=t/1-1)*t*t+1)},easeInOutCubic:function(t){return(t/=.5)<1?.5*t*t*t:.5*((t-=2)*t*t+2)},easeInQuart:function(t){return t*t*t*t},easeOutQuart:function(t){return-1*((t=t/1-1)*t*t*t-1)},easeInOutQuart:function(t){return(t/=.5)<1?.5*t*t*t*t:-0.5*((t-=2)*t*t*t-2)},easeInQuint:function(t){return 1*(t/=1)*t*t*t*t},easeOutQuint:function(t){return 1*((t=t/1-1)*t*t*t*t+1)},easeInOutQuint:function(t){return(t/=.5)<1?.5*t*t*t*t*t:.5*((t-=2)*t*t*t*t+2)},easeInSine:function(t){return-1*Math.cos(t/1*(Math.PI/2))+1},easeOutSine:function(t){return 1*Math.sin(t/1*(Math.PI/2))},easeInOutSine:function(t){return-0.5*(Math.cos(Math.PI*t/1)-1)},easeInExpo:function(t){return 0===t?1:1*Math.pow(2,10*(t/1-1))},easeOutExpo:function(t){return 1===t?1:1*(-Math.pow(2,-10*t/1)+1)},easeInOutExpo:function(t){return 0===t?0:1===t?1:(t/=.5)<1?.5*Math.pow(2,10*(t-1)):.5*(-Math.pow(2,-10*--t)+2)},easeInCirc:function(t){return t>=1?t:-1*(Math.sqrt(1-(t/=1)*t)-1)},easeOutCirc:function(t){return 1*Math.sqrt(1-(t=t/1-1)*t)},easeInOutCirc:function(t){return(t/=.5)<1?-0.5*(Math.sqrt(1-t*t)-1):.5*(Math.sqrt(1-(t-=2)*t)+1)},easeInElastic:function(t){var i=1.70158,e=0,s=1;return 0===t?0:1==(t/=1)?1:(e||(e=.3),s<Math.abs(1)?(s=1,i=e/4):i=e/(2*Math.PI)*Math.asin(1/s),-(s*Math.pow(2,10*(t-=1))*Math.sin(2*(1*t-i)*Math.PI/e)))},easeOutElastic:function(t){var i=1.70158,e=0,s=1;return 0===t?0:1==(t/=1)?1:(e||(e=.3),s<Math.abs(1)?(s=1,i=e/4):i=e/(2*Math.PI)*Math.asin(1/s),s*Math.pow(2,-10*t)*Math.sin(2*(1*t-i)*Math.PI/e)+1)},easeInOutElastic:function(t){var i=1.70158,e=0,s=1;return 0===t?0:2==(t/=.5)?1:(e||(e=.3*1.5),s<Math.abs(1)?(s=1,i=e/4):i=e/(2*Math.PI)*Math.asin(1/s),1>t?-.5*s*Math.pow(2,10*(t-=1))*Math.sin(2*(1*t-i)*Math.PI/e):s*Math.pow(2,-10*(t-=1))*Math.sin(2*(1*t-i)*Math.PI/e)*.5+1)},easeInBack:function(t){var i=1.70158;return 1*(t/=1)*t*((i+1)*t-i)},easeOutBack:function(t){var i=1.70158;return 1*((t=t/1-1)*t*((i+1)*t+i)+1)},easeInOutBack:function(t){var i=1.70158;return(t/=.5)<1?.5*t*t*(((i*=1.525)+1)*t-i):.5*((t-=2)*t*(((i*=1.525)+1)*t+i)+2)},easeInBounce:function(t){return 1-w.easeOutBounce(1-t)},easeOutBounce:function(t){return(t/=1)<1/2.75?7.5625*t*t:2/2.75>t?1*(7.5625*(t-=1.5/2.75)*t+.75):2.5/2.75>t?1*(7.5625*(t-=2.25/2.75)*t+.9375):1*(7.5625*(t-=2.625/2.75)*t+.984375)},easeInOutBounce:function(t){return.5>t?.5*w.easeInBounce(2*t):.5*w.easeOutBounce(2*t-1)+.5}}),b=s.requestAnimFrame=function(){return window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame||function(t){return window.setTimeout(t,1e3/60)}}(),P=(s.cancelAnimFrame=function(){return window.cancelAnimationFrame||window.webkitCancelAnimationFrame||window.mozCancelAnimationFrame||window.oCancelAnimationFrame||window.msCancelAnimationFrame||function(t){return window.clearTimeout(t,1e3/60)}}(),s.animationLoop=function(t,i,e,s,n,o){var a=0,h=w[e]||w.linear,l=function(){a++;var e=a/i,r=h(e);t.call(o,r,e,a),s.call(o,r,e),i>a?o.animationFrame=b(l):n.apply(o)};b(l)},s.getRelativePosition=function(t){var i,e,s=t.originalEvent||t,n=t.currentTarget||t.srcElement,o=n.getBoundingClientRect();return s.touches?(i=s.touches[0].clientX-o.left,e=s.touches[0].clientY-o.top):(i=s.clientX-o.left,e=s.clientY-o.top),{x:i,y:e}},s.addEvent=function(t,i,e){t.addEventListener?t.addEventListener(i,e):t.attachEvent?t.attachEvent("on"+i,e):t["on"+i]=e}),L=s.removeEvent=function(t,i,e){t.removeEventListener?t.removeEventListener(i,e,!1):t.detachEvent?t.detachEvent("on"+i,e):t["on"+i]=c},k=(s.bindEvents=function(t,i,e){t.events||(t.events={}),n(i,function(i){t.events[i]=function(){e.apply(t,arguments)},P(t.chart.canvas,i,t.events[i])})},s.unbindEvents=function(t,i){n(i,function(i,e){L(t.chart.canvas,e,i)})}),F=s.getMaximumWidth=function(t){var i=t.parentNode;return i.clientWidth},R=s.getMaximumHeight=function(t){var i=t.parentNode;return i.clientHeight},T=(s.getMaximumSize=s.getMaximumWidth,s.retinaScale=function(t){var i=t.ctx,e=t.canvas.width,s=t.canvas.height;window.devicePixelRatio&&(i.canvas.style.width=e+"px",i.canvas.style.height=s+"px",i.canvas.height=s*window.devicePixelRatio,i.canvas.width=e*window.devicePixelRatio,i.scale(window.devicePixelRatio,window.devicePixelRatio))}),A=s.clear=function(t){t.ctx.clearRect(0,0,t.width,t.height)},M=s.fontString=function(t,i,e){return i+" "+t+"px "+e},W=s.longestText=function(t,i,e){t.font=i;var s=0;return n(e,function(i){var e=t.measureText(i).width;s=e>s?e:s}),s},z=s.drawRoundedRectangle=function(t,i,e,s,n,o){t.beginPath(),t.moveTo(i+o,e),t.lineTo(i+s-o,e),t.quadraticCurveTo(i+s,e,i+s,e+o),t.lineTo(i+s,e+n-o),t.quadraticCurveTo(i+s,e+n,i+s-o,e+n),t.lineTo(i+o,e+n),t.quadraticCurveTo(i,e+n,i,e+n-o),t.lineTo(i,e+o),t.quadraticCurveTo(i,e,i+o,e),t.closePath()};e.instances={},e.Type=function(t,i,s){this.options=i,this.chart=s,this.id=u(),e.instances[this.id]=this,i.responsive&&this.resize(),this.initialize.call(this,t)},a(e.Type.prototype,{initialize:function(){return this},clear:function(){return A(this.chart),this},stop:function(){return s.cancelAnimFrame.call(t,this.animationFrame),this},resize:function(t){this.stop();var i=this.chart.canvas,e=F(this.chart.canvas),s=this.options.maintainAspectRatio?e/this.chart.aspectRatio:R(this.chart.canvas);return i.width=this.chart.width=e,i.height=this.chart.height=s,T(this.chart),"function"==typeof t&&t.apply(this,Array.prototype.slice.call(arguments,1)),this},reflow:c,render:function(t){return t&&this.reflow(),this.options.animation&&!t?s.animationLoop(this.draw,this.options.animationSteps,this.options.animationEasing,this.options.onAnimationProgress,this.options.onAnimationComplete,this):(this.draw(),this.options.onAnimationComplete.call(this)),this},generateLegend:function(){return C(this.options.legendTemplate,this)},destroy:function(){this.clear(),k(this,this.events);var t=this.chart.canvas;t.width=this.chart.width,t.height=this.chart.height,t.style.removeProperty?(t.style.removeProperty("width"),t.style.removeProperty("height")):(t.style.removeAttribute("width"),t.style.removeAttribute("height")),delete e.instances[this.id]},showTooltip:function(t,i){"undefined"==typeof this.activeElements&&(this.activeElements=[]);var o=function(t){var i=!1;return t.length!==this.activeElements.length?i=!0:(n(t,function(t,e){t!==this.activeElements[e]&&(i=!0)},this),i)}.call(this,t);if(o||i){if(this.activeElements=t,this.draw(),this.options.customTooltips&&this.options.customTooltips(!1),t.length>0)if(this.datasets&&this.datasets.length>1){for(var a,h,r=this.datasets.length-1;r>=0&&(a=this.datasets[r].points||this.datasets[r].bars||this.datasets[r].segments,h=l(a,t[0]),-1===h);r--);var c=[],u=[],d=function(){var t,i,e,n,o,a=[],l=[],r=[];return s.each(this.datasets,function(i){t=i.points||i.bars||i.segments,t[h]&&t[h].hasValue()&&a.push(t[h])}),s.each(a,function(t){l.push(t.x),r.push(t.y),c.push(s.template(this.options.multiTooltipTemplate,t)),u.push({fill:t._saved.fillColor||t.fillColor,stroke:t._saved.strokeColor||t.strokeColor})},this),o=m(r),e=g(r),n=m(l),i=g(l),{x:n>this.chart.width/2?n:i,y:(o+e)/2}}.call(this,h);new e.MultiTooltip({x:d.x,y:d.y,xPadding:this.options.tooltipXPadding,yPadding:this.options.tooltipYPadding,xOffset:this.options.tooltipXOffset,fillColor:this.options.tooltipFillColor,textColor:this.options.tooltipFontColor,fontFamily:this.options.tooltipFontFamily,fontStyle:this.options.tooltipFontStyle,fontSize:this.options.tooltipFontSize,titleTextColor:this.options.tooltipTitleFontColor,titleFontFamily:this.options.tooltipTitleFontFamily,titleFontStyle:this.options.tooltipTitleFontStyle,titleFontSize:this.options.tooltipTitleFontSize,cornerRadius:this.options.tooltipCornerRadius,labels:c,legendColors:u,legendColorBackground:this.options.multiTooltipKeyBackground,title:t[0].label,chart:this.chart,ctx:this.chart.ctx,custom:this.options.customTooltips}).draw()}else n(t,function(t){var i=t.tooltipPosition();new e.Tooltip({x:Math.round(i.x),y:Math.round(i.y),xPadding:this.options.tooltipXPadding,yPadding:this.options.tooltipYPadding,fillColor:this.options.tooltipFillColor,textColor:this.options.tooltipFontColor,fontFamily:this.options.tooltipFontFamily,fontStyle:this.options.tooltipFontStyle,fontSize:this.options.tooltipFontSize,caretHeight:this.options.tooltipCaretSize,cornerRadius:this.options.tooltipCornerRadius,text:C(this.options.tooltipTemplate,t),chart:this.chart,custom:this.options.customTooltips}).draw()},this);return this}},toBase64Image:function(){return this.chart.canvas.toDataURL.apply(this.chart.canvas,arguments)}}),e.Type.extend=function(t){var i=this,s=function(){return i.apply(this,arguments)};if(s.prototype=o(i.prototype),a(s.prototype,t),s.extend=e.Type.extend,t.name||i.prototype.name){var n=t.name||i.prototype.name,l=e.defaults[i.prototype.name]?o(e.defaults[i.prototype.name]):{};e.defaults[n]=a(l,t.defaults),e.types[n]=s,e.prototype[n]=function(t,i){var o=h(e.defaults.global,e.defaults[n],i||{});return new s(t,o,this)}}else d("Name not provided for this chart, so it hasn't been registered");return i},e.Element=function(t){a(this,t),this.initialize.apply(this,arguments),this.save()},a(e.Element.prototype,{initialize:function(){},restore:function(t){return t?n(t,function(t){this[t]=this._saved[t]},this):a(this,this._saved),this},save:function(){return this._saved=o(this),delete this._saved._saved,this},update:function(t){return n(t,function(t,i){this._saved[i]=this[i],this[i]=t},this),this},transition:function(t,i){return n(t,function(t,e){this[e]=(t-this._saved[e])*i+this._saved[e]},this),this},tooltipPosition:function(){return{x:this.x,y:this.y}},hasValue:function(){return f(this.value)}}),e.Element.extend=r,e.Point=e.Element.extend({display:!0,inRange:function(t,i){var e=this.hitDetectionRadius+this.radius;return Math.pow(t-this.x,2)+Math.pow(i-this.y,2)<Math.pow(e,2)},draw:function(){if(this.display){var t=this.ctx;t.beginPath(),t.arc(this.x,this.y,this.radius,0,2*Math.PI),t.closePath(),t.strokeStyle=this.strokeColor,t.lineWidth=this.strokeWidth,t.fillStyle=this.fillColor,t.fill(),t.stroke()}}}),e.Arc=e.Element.extend({inRange:function(t,i){var e=s.getAngleFromPoint(this,{x:t,y:i}),n=e.angle>=this.startAngle&&e.angle<=this.endAngle,o=e.distance>=this.innerRadius&&e.distance<=this.outerRadius;return n&&o},tooltipPosition:function(){var t=this.startAngle+(this.endAngle-this.startAngle)/2,i=(this.outerRadius-this.innerRadius)/2+this.innerRadius;return{x:this.x+Math.cos(t)*i,y:this.y+Math.sin(t)*i}},draw:function(t){var i=this.ctx;i.beginPath(),i.arc(this.x,this.y,this.outerRadius,this.startAngle,this.endAngle),i.arc(this.x,this.y,this.innerRadius,this.endAngle,this.startAngle,!0),i.closePath(),i.strokeStyle=this.strokeColor,i.lineWidth=this.strokeWidth,i.fillStyle=this.fillColor,i.fill(),i.lineJoin="bevel",this.showStroke&&i.stroke()}}),e.Rectangle=e.Element.extend({draw:function(){var t=this.ctx,i=this.width/2,e=this.x-i,s=this.x+i,n=this.base-(this.base-this.y),o=this.strokeWidth/2;this.showStroke&&(e+=o,s-=o,n+=o),t.beginPath(),t.fillStyle=this.fillColor,t.strokeStyle=this.strokeColor,t.lineWidth=this.strokeWidth,t.moveTo(e,this.base),t.lineTo(e,n),t.lineTo(s,n),t.lineTo(s,this.base),t.fill(),this.showStroke&&t.stroke()},height:function(){return this.base-this.y},inRange:function(t,i){return t>=this.x-this.width/2&&t<=this.x+this.width/2&&i>=this.y&&i<=this.base}}),e.Tooltip=e.Element.extend({draw:function(){var t=this.chart.ctx;t.font=M(this.fontSize,this.fontStyle,this.fontFamily),this.xAlign="center",this.yAlign="above";var i=this.caretPadding=2,e=t.measureText(this.text).width+2*this.xPadding,s=this.fontSize+2*this.yPadding,n=s+this.caretHeight+i;this.x+e/2>this.chart.width?this.xAlign="left":this.x-e/2<0&&(this.xAlign="right"),this.y-n<0&&(this.yAlign="below");var o=this.x-e/2,a=this.y-n;if(t.fillStyle=this.fillColor,this.custom)this.custom(this);else{switch(this.yAlign){case"above":t.beginPath(),t.moveTo(this.x,this.y-i),t.lineTo(this.x+this.caretHeight,this.y-(i+this.caretHeight)),t.lineTo(this.x-this.caretHeight,this.y-(i+this.caretHeight)),t.closePath(),t.fill();break;case"below":a=this.y+i+this.caretHeight,t.beginPath(),t.moveTo(this.x,this.y+i),t.lineTo(this.x+this.caretHeight,this.y+i+this.caretHeight),t.lineTo(this.x-this.caretHeight,this.y+i+this.caretHeight),t.closePath(),t.fill()}switch(this.xAlign){case"left":o=this.x-e+(this.cornerRadius+this.caretHeight);break;case"right":o=this.x-(this.cornerRadius+this.caretHeight)}z(t,o,a,e,s,this.cornerRadius),t.fill(),t.fillStyle=this.textColor,t.textAlign="center",t.textBaseline="middle",t.fillText(this.text,o+e/2,a+s/2)}}}),e.MultiTooltip=e.Element.extend({initialize:function(){this.font=M(this.fontSize,this.fontStyle,this.fontFamily),this.titleFont=M(this.titleFontSize,this.titleFontStyle,this.titleFontFamily),this.height=this.labels.length*this.fontSize+(this.labels.length-1)*(this.fontSize/2)+2*this.yPadding+1.5*this.titleFontSize,this.ctx.font=this.titleFont;var t=this.ctx.measureText(this.title).width,i=W(this.ctx,this.font,this.labels)+this.fontSize+3,e=g([i,t]);this.width=e+2*this.xPadding;var s=this.height/2;this.y-s<0?this.y=s:this.y+s>this.chart.height&&(this.y=this.chart.height-s),this.x>this.chart.width/2?this.x-=this.xOffset+this.width:this.x+=this.xOffset},getLineHeight:function(t){var i=this.y-this.height/2+this.yPadding,e=t-1;return 0===t?i+this.titleFontSize/2:i+(1.5*this.fontSize*e+this.fontSize/2)+1.5*this.titleFontSize},draw:function(){if(this.custom)this.custom(this);else{z(this.ctx,this.x,this.y-this.height/2,this.width,this.height,this.cornerRadius);var t=this.ctx;t.fillStyle=this.fillColor,t.fill(),t.closePath(),t.textAlign="left",t.textBaseline="middle",t.fillStyle=this.titleTextColor,t.font=this.titleFont,t.fillText(this.title,this.x+this.xPadding,this.getLineHeight(0)),t.font=this.font,s.each(this.labels,function(i,e){t.fillStyle=this.textColor,t.fillText(i,this.x+this.xPadding+this.fontSize+3,this.getLineHeight(e+1)),t.fillStyle=this.legendColorBackground,t.fillRect(this.x+this.xPadding,this.getLineHeight(e+1)-this.fontSize/2,this.fontSize,this.fontSize),t.fillStyle=this.legendColors[e].fill,t.fillRect(this.x+this.xPadding,this.getLineHeight(e+1)-this.fontSize/2,this.fontSize,this.fontSize)},this)}}}),e.Scale=e.Element.extend({initialize:function(){this.fit()},buildYLabels:function(){this.yLabels=[];for(var t=v(this.stepValue),i=0;i<=this.steps;i++)this.yLabels.push(C(this.templateString,{value:(this.min+i*this.stepValue).toFixed(t)}));this.yLabelWidth=this.display&&this.showLabels?W(this.ctx,this.font,this.yLabels):0},addXLabel:function(t){this.xLabels.push(t),this.valuesCount++,this.fit()},removeXLabel:function(){this.xLabels.shift(),this.valuesCount--,this.fit()},fit:function(){this.startPoint=this.display?this.fontSize:0,this.endPoint=this.display?this.height-1.5*this.fontSize-5:this.height,this.startPoint+=this.padding,this.endPoint-=this.padding;var t,i=this.endPoint-this.startPoint;for(this.calculateYRange(i),this.buildYLabels(),this.calculateXLabelRotation();i>this.endPoint-this.startPoint;)i=this.endPoint-this.startPoint,t=this.yLabelWidth,this.calculateYRange(i),this.buildYLabels(),t<this.yLabelWidth&&this.calculateXLabelRotation()},calculateXLabelRotation:function(){this.ctx.font=this.font;var t,i,e=this.ctx.measureText(this.xLabels[0]).width,s=this.ctx.measureText(this.xLabels[this.xLabels.length-1]).width;if(this.xScalePaddingRight=s/2+3,this.xScalePaddingLeft=e/2>this.yLabelWidth+10?e/2:this.yLabelWidth+10,this.xLabelRotation=0,this.display){var n,o=W(this.ctx,this.font,this.xLabels);this.xLabelWidth=o;for(var a=Math.floor(this.calculateX(1)-this.calculateX(0))-6;this.xLabelWidth>a&&0===this.xLabelRotation||this.xLabelWidth>a&&this.xLabelRotation<=90&&this.xLabelRotation>0;)n=Math.cos(S(this.xLabelRotation)),t=n*e,i=n*s,t+this.fontSize/2>this.yLabelWidth+8&&(this.xScalePaddingLeft=t+this.fontSize/2),this.xScalePaddingRight=this.fontSize/2,this.xLabelRotation++,this.xLabelWidth=n*o;this.xLabelRotation>0&&(this.endPoint-=Math.sin(S(this.xLabelRotation))*o+3)}else this.xLabelWidth=0,this.xScalePaddingRight=this.padding,this.xScalePaddingLeft=this.padding},calculateYRange:c,drawingArea:function(){return this.startPoint-this.endPoint},calculateY:function(t){var i=this.drawingArea()/(this.min-this.max);return this.endPoint-i*(t-this.min)},calculateX:function(t){var i=(this.xLabelRotation>0,this.width-(this.xScalePaddingLeft+this.xScalePaddingRight)),e=i/(this.valuesCount-(this.offsetGridLines?0:1)),s=e*t+this.xScalePaddingLeft;return this.offsetGridLines&&(s+=e/2),Math.round(s)},update:function(t){s.extend(this,t),this.fit()},draw:function(){var t=this.ctx,i=(this.endPoint-this.startPoint)/this.steps,e=Math.round(this.xScalePaddingLeft);this.display&&(t.fillStyle=this.textColor,t.font=this.font,n(this.yLabels,function(n,o){var a=this.endPoint-i*o,h=Math.round(a),l=this.showHorizontalLines;t.textAlign="right",t.textBaseline="middle",this.showLabels&&t.fillText(n,e-10,a),0!==o||l||(l=!0),l&&t.beginPath(),o>0?(t.lineWidth=this.gridLineWidth,t.strokeStyle=this.gridLineColor):(t.lineWidth=this.lineWidth,t.strokeStyle=this.lineColor),h+=s.aliasPixel(t.lineWidth),l&&(t.moveTo(e,h),t.lineTo(this.width,h),t.stroke(),t.closePath()),t.lineWidth=this.lineWidth,t.strokeStyle=this.lineColor,t.beginPath(),t.moveTo(e-5,h),t.lineTo(e,h),t.stroke(),t.closePath()},this),n(this.xLabels,function(i,e){var s=this.calculateX(e)+x(this.lineWidth),n=this.calculateX(e-(this.offsetGridLines?.5:0))+x(this.lineWidth),o=this.xLabelRotation>0,a=this.showVerticalLines;0!==e||a||(a=!0),a&&t.beginPath(),e>0?(t.lineWidth=this.gridLineWidth,t.strokeStyle=this.gridLineColor):(t.lineWidth=this.lineWidth,t.strokeStyle=this.lineColor),a&&(t.moveTo(n,this.endPoint),t.lineTo(n,this.startPoint-3),t.stroke(),t.closePath()),t.lineWidth=this.lineWidth,t.strokeStyle=this.lineColor,t.beginPath(),t.moveTo(n,this.endPoint),t.lineTo(n,this.endPoint+5),t.stroke(),t.closePath(),t.save(),t.translate(s,o?this.endPoint+12:this.endPoint+8),t.rotate(-1*S(this.xLabelRotation)),t.font=this.font,t.textAlign=o?"right":"center",t.textBaseline=o?"middle":"top",t.fillText(i,0,0),t.restore()},this))}}),e.RadialScale=e.Element.extend({initialize:function(){this.size=m([this.height,this.width]),this.drawingArea=this.display?this.size/2-(this.fontSize/2+this.backdropPaddingY):this.size/2},calculateCenterOffset:function(t){var i=this.drawingArea/(this.max-this.min);return(t-this.min)*i},update:function(){this.lineArc?this.drawingArea=this.display?this.size/2-(this.fontSize/2+this.backdropPaddingY):this.size/2:this.setScaleSize(),this.buildYLabels()},buildYLabels:function(){this.yLabels=[];for(var t=v(this.stepValue),i=0;i<=this.steps;i++)this.yLabels.push(C(this.templateString,{value:(this.min+i*this.stepValue).toFixed(t)}))},getCircumference:function(){return 2*Math.PI/this.valuesCount},setScaleSize:function(){var t,i,e,s,n,o,a,h,l,r,c,u,d=m([this.height/2-this.pointLabelFontSize-5,this.width/2]),p=this.width,g=0;for(this.ctx.font=M(this.pointLabelFontSize,this.pointLabelFontStyle,this.pointLabelFontFamily),i=0;i<this.valuesCount;i++)t=this.getPointPosition(i,d),e=this.ctx.measureText(C(this.templateString,{value:this.labels[i]})).width+5,0===i||i===this.valuesCount/2?(s=e/2,t.x+s>p&&(p=t.x+s,n=i),t.x-s<g&&(g=t.x-s,a=i)):i<this.valuesCount/2?t.x+e>p&&(p=t.x+e,n=i):i>this.valuesCount/2&&t.x-e<g&&(g=t.x-e,a=i);l=g,r=Math.ceil(p-this.width),o=this.getIndexAngle(n),h=this.getIndexAngle(a),c=r/Math.sin(o+Math.PI/2),u=l/Math.sin(h+Math.PI/2),c=f(c)?c:0,u=f(u)?u:0,this.drawingArea=d-(u+c)/2,this.setCenterPoint(u,c)},setCenterPoint:function(t,i){var e=this.width-i-this.drawingArea,s=t+this.drawingArea;this.xCenter=(s+e)/2,this.yCenter=this.height/2},getIndexAngle:function(t){var i=2*Math.PI/this.valuesCount;return t*i-Math.PI/2},getPointPosition:function(t,i){var e=this.getIndexAngle(t);return{x:Math.cos(e)*i+this.xCenter,y:Math.sin(e)*i+this.yCenter}},draw:function(){if(this.display){var t=this.ctx;if(n(this.yLabels,function(i,e){if(e>0){var s,n=e*(this.drawingArea/this.steps),o=this.yCenter-n;if(this.lineWidth>0)if(t.strokeStyle=this.lineColor,t.lineWidth=this.lineWidth,this.lineArc)t.beginPath(),t.arc(this.xCenter,this.yCenter,n,0,2*Math.PI),t.closePath(),t.stroke();else{t.beginPath();for(var a=0;a<this.valuesCount;a++)s=this.getPointPosition(a,this.calculateCenterOffset(this.min+e*this.stepValue)),0===a?t.moveTo(s.x,s.y):t.lineTo(s.x,s.y);t.closePath(),t.stroke()}if(this.showLabels){if(t.font=M(this.fontSize,this.fontStyle,this.fontFamily),this.showLabelBackdrop){var h=t.measureText(i).width;t.fillStyle=this.backdropColor,t.fillRect(this.xCenter-h/2-this.backdropPaddingX,o-this.fontSize/2-this.backdropPaddingY,h+2*this.backdropPaddingX,this.fontSize+2*this.backdropPaddingY)}t.textAlign="center",t.textBaseline="middle",t.fillStyle=this.fontColor,t.fillText(i,this.xCenter,o)}}},this),!this.lineArc){t.lineWidth=this.angleLineWidth,t.strokeStyle=this.angleLineColor;for(var i=this.valuesCount-1;i>=0;i--){if(this.angleLineWidth>0){var e=this.getPointPosition(i,this.calculateCenterOffset(this.max));t.beginPath(),t.moveTo(this.xCenter,this.yCenter),t.lineTo(e.x,e.y),t.stroke(),t.closePath()}var s=this.getPointPosition(i,this.calculateCenterOffset(this.max)+5);t.font=M(this.pointLabelFontSize,this.pointLabelFontStyle,this.pointLabelFontFamily),t.fillStyle=this.pointLabelFontColor;var o=this.labels.length,a=this.labels.length/2,h=a/2,l=h>i||i>o-h,r=i===h||i===o-h;t.textAlign=0===i?"center":i===a?"center":a>i?"left":"right",t.textBaseline=r?"middle":l?"bottom":"top",t.fillText(this.labels[i],s.x,s.y)}}}}}),s.addEvent(window,"resize",function(){var t;return function(){clearTimeout(t),t=setTimeout(function(){n(e.instances,function(t){t.options.responsive&&t.resize(t.render,!0)})},50)}}()),p?define(function(){return e}):"object"==typeof module&&module.exports&&(module.exports=e),t.Chart=e,e.noConflict=function(){return t.Chart=i,e}}).call(this),function(){"use strict";var t=this,i=t.Chart,e=i.helpers,s={scaleBeginAtZero:!0,scaleShowGridLines:!0,scaleGridLineColor:"rgba(0,0,0,.05)",scaleGridLineWidth:1,scaleShowHorizontalLines:!0,scaleShowVerticalLines:!0,barShowStroke:!0,barStrokeWidth:2,barValueSpacing:5,barDatasetSpacing:1,legendTemplate:'<ul class="<%=name.toLowerCase()%>-legend"><% for (var i=0; i<datasets.length; i++){%><li><span style="background-color:<%=datasets[i].fillColor%>"></span><%if(datasets[i].label){%><%=datasets[i].label%><%}%></li><%}%></ul>'};i.Type.extend({name:"Bar",defaults:s,initialize:function(t){var s=this.options;this.ScaleClass=i.Scale.extend({offsetGridLines:!0,calculateBarX:function(t,i,e){var n=this.calculateBaseWidth(),o=this.calculateX(e)-n/2,a=this.calculateBarWidth(t);return o+a*i+i*s.barDatasetSpacing+a/2},calculateBaseWidth:function(){return this.calculateX(1)-this.calculateX(0)-2*s.barValueSpacing},calculateBarWidth:function(t){var i=this.calculateBaseWidth()-(t-1)*s.barDatasetSpacing;return i/t}}),this.datasets=[],this.options.showTooltips&&e.bindEvents(this,this.options.tooltipEvents,function(t){var i="mouseout"!==t.type?this.getBarsAtEvent(t):[];this.eachBars(function(t){t.restore(["fillColor","strokeColor"])}),e.each(i,function(t){t.fillColor=t.highlightFill,t.strokeColor=t.highlightStroke}),this.showTooltip(i)}),this.BarClass=i.Rectangle.extend({strokeWidth:this.options.barStrokeWidth,showStroke:this.options.barShowStroke,ctx:this.chart.ctx}),e.each(t.datasets,function(i){var s={label:i.label||null,fillColor:i.fillColor,strokeColor:i.strokeColor,bars:[]};this.datasets.push(s),e.each(i.data,function(e,n){s.bars.push(new this.BarClass({value:e,label:t.labels[n],datasetLabel:i.label,strokeColor:i.strokeColor,fillColor:i.fillColor,highlightFill:i.highlightFill||i.fillColor,highlightStroke:i.highlightStroke||i.strokeColor}))},this)},this),this.buildScale(t.labels),this.BarClass.prototype.base=this.scale.endPoint,this.eachBars(function(t,i,s){e.extend(t,{width:this.scale.calculateBarWidth(this.datasets.length),x:this.scale.calculateBarX(this.datasets.length,s,i),y:this.scale.endPoint}),t.save()},this),this.render()},update:function(){this.scale.update(),e.each(this.activeElements,function(t){t.restore(["fillColor","strokeColor"])}),this.eachBars(function(t){t.save()}),this.render()},eachBars:function(t){e.each(this.datasets,function(i,s){e.each(i.bars,t,this,s)},this)},getBarsAtEvent:function(t){for(var i,s=[],n=e.getRelativePosition(t),o=function(t){s.push(t.bars[i])},a=0;a<this.datasets.length;a++)for(i=0;i<this.datasets[a].bars.length;i++)if(this.datasets[a].bars[i].inRange(n.x,n.y))return e.each(this.datasets,o),s;return s},buildScale:function(t){var i=this,s=function(){var t=[];return i.eachBars(function(i){t.push(i.value)}),t},n={templateString:this.options.scaleLabel,height:this.chart.height,width:this.chart.width,ctx:this.chart.ctx,textColor:this.options.scaleFontColor,fontSize:this.options.scaleFontSize,fontStyle:this.options.scaleFontStyle,fontFamily:this.options.scaleFontFamily,valuesCount:t.length,beginAtZero:this.options.scaleBeginAtZero,integersOnly:this.options.scaleIntegersOnly,calculateYRange:function(t){var i=e.calculateScaleRange(s(),t,this.fontSize,this.beginAtZero,this.integersOnly);e.extend(this,i)},xLabels:t,font:e.fontString(this.options.scaleFontSize,this.options.scaleFontStyle,this.options.scaleFontFamily),lineWidth:this.options.scaleLineWidth,lineColor:this.options.scaleLineColor,showHorizontalLines:this.options.scaleShowHorizontalLines,showVerticalLines:this.options.scaleShowVerticalLines,gridLineWidth:this.options.scaleShowGridLines?this.options.scaleGridLineWidth:0,gridLineColor:this.options.scaleShowGridLines?this.options.scaleGridLineColor:"rgba(0,0,0,0)",padding:this.options.showScale?0:this.options.barShowStroke?this.options.barStrokeWidth:0,showLabels:this.options.scaleShowLabels,display:this.options.showScale};this.options.scaleOverride&&e.extend(n,{calculateYRange:e.noop,steps:this.options.scaleSteps,stepValue:this.options.scaleStepWidth,min:this.options.scaleStartValue,max:this.options.scaleStartValue+this.options.scaleSteps*this.options.scaleStepWidth}),this.scale=new this.ScaleClass(n)},addData:function(t,i){e.each(t,function(t,e){this.datasets[e].bars.push(new this.BarClass({value:t,label:i,x:this.scale.calculateBarX(this.datasets.length,e,this.scale.valuesCount+1),y:this.scale.endPoint,width:this.scale.calculateBarWidth(this.datasets.length),base:this.scale.endPoint,strokeColor:this.datasets[e].strokeColor,fillColor:this.datasets[e].fillColor}))},this),this.scale.addXLabel(i),this.update()},removeData:function(){this.scale.removeXLabel(),e.each(this.datasets,function(t){t.bars.shift()},this),this.update()},reflow:function(){e.extend(this.BarClass.prototype,{y:this.scale.endPoint,base:this.scale.endPoint});
var t=e.extend({height:this.chart.height,width:this.chart.width});this.scale.update(t)},draw:function(t){var i=t||1;this.clear();this.chart.ctx;this.scale.draw(i),e.each(this.datasets,function(t,s){e.each(t.bars,function(t,e){t.hasValue()&&(t.base=this.scale.endPoint,t.transition({x:this.scale.calculateBarX(this.datasets.length,s,e),y:this.scale.calculateY(t.value),width:this.scale.calculateBarWidth(this.datasets.length)},i).draw())},this)},this)}})}.call(this),function(){"use strict";var t=this,i=t.Chart,e=i.helpers,s={segmentShowStroke:!0,segmentStrokeColor:"#fff",segmentStrokeWidth:2,percentageInnerCutout:50,animationSteps:100,animationEasing:"easeOutBounce",animateRotate:!0,animateScale:!1,legendTemplate:'<ul class="<%=name.toLowerCase()%>-legend"><% for (var i=0; i<segments.length; i++){%><li><span style="background-color:<%=segments[i].fillColor%>"></span><%if(segments[i].label){%><%=segments[i].label%><%}%></li><%}%></ul>'};i.Type.extend({name:"Doughnut",defaults:s,initialize:function(t){this.segments=[],this.outerRadius=(e.min([this.chart.width,this.chart.height])-this.options.segmentStrokeWidth/2)/2,this.SegmentArc=i.Arc.extend({ctx:this.chart.ctx,x:this.chart.width/2,y:this.chart.height/2}),this.options.showTooltips&&e.bindEvents(this,this.options.tooltipEvents,function(t){var i="mouseout"!==t.type?this.getSegmentsAtEvent(t):[];e.each(this.segments,function(t){t.restore(["fillColor"])}),e.each(i,function(t){t.fillColor=t.highlightColor}),this.showTooltip(i)}),this.calculateTotal(t),e.each(t,function(t,i){this.addData(t,i,!0)},this),this.render()},getSegmentsAtEvent:function(t){var i=[],s=e.getRelativePosition(t);return e.each(this.segments,function(t){t.inRange(s.x,s.y)&&i.push(t)},this),i},addData:function(t,i,e){var s=i||this.segments.length;this.segments.splice(s,0,new this.SegmentArc({value:t.value,outerRadius:this.options.animateScale?0:this.outerRadius,innerRadius:this.options.animateScale?0:this.outerRadius/100*this.options.percentageInnerCutout,fillColor:t.color,highlightColor:t.highlight||t.color,showStroke:this.options.segmentShowStroke,strokeWidth:this.options.segmentStrokeWidth,strokeColor:this.options.segmentStrokeColor,startAngle:1.5*Math.PI,circumference:this.options.animateRotate?0:this.calculateCircumference(t.value),label:t.label})),e||(this.reflow(),this.update())},calculateCircumference:function(t){return 2*Math.PI*(t/this.total)},calculateTotal:function(t){this.total=0,e.each(t,function(t){this.total+=t.value},this)},update:function(){this.calculateTotal(this.segments),e.each(this.activeElements,function(t){t.restore(["fillColor"])}),e.each(this.segments,function(t){t.save()}),this.render()},removeData:function(t){var i=e.isNumber(t)?t:this.segments.length-1;this.segments.splice(i,1),this.reflow(),this.update()},reflow:function(){e.extend(this.SegmentArc.prototype,{x:this.chart.width/2,y:this.chart.height/2}),this.outerRadius=(e.min([this.chart.width,this.chart.height])-this.options.segmentStrokeWidth/2)/2,e.each(this.segments,function(t){t.update({outerRadius:this.outerRadius,innerRadius:this.outerRadius/100*this.options.percentageInnerCutout})},this)},draw:function(t){var i=t?t:1;this.clear(),e.each(this.segments,function(t,e){t.transition({circumference:this.calculateCircumference(t.value),outerRadius:this.outerRadius,innerRadius:this.outerRadius/100*this.options.percentageInnerCutout},i),t.endAngle=t.startAngle+t.circumference,t.draw(),0===e&&(t.startAngle=1.5*Math.PI),e<this.segments.length-1&&(this.segments[e+1].startAngle=t.endAngle)},this)}}),i.types.Doughnut.extend({name:"Pie",defaults:e.merge(s,{percentageInnerCutout:0})})}.call(this),function(){"use strict";var t=this,i=t.Chart,e=i.helpers,s={scaleShowGridLines:!0,scaleGridLineColor:"rgba(0,0,0,.05)",scaleGridLineWidth:1,scaleShowHorizontalLines:!0,scaleShowVerticalLines:!0,bezierCurve:!0,bezierCurveTension:.4,pointDot:!0,pointDotRadius:4,pointDotStrokeWidth:1,pointHitDetectionRadius:20,datasetStroke:!0,datasetStrokeWidth:2,datasetFill:!0,legendTemplate:'<ul class="<%=name.toLowerCase()%>-legend"><% for (var i=0; i<datasets.length; i++){%><li><span style="background-color:<%=datasets[i].strokeColor%>"></span><%if(datasets[i].label){%><%=datasets[i].label%><%}%></li><%}%></ul>'};i.Type.extend({name:"Line",defaults:s,initialize:function(t){this.PointClass=i.Point.extend({strokeWidth:this.options.pointDotStrokeWidth,radius:this.options.pointDotRadius,display:this.options.pointDot,hitDetectionRadius:this.options.pointHitDetectionRadius,ctx:this.chart.ctx,inRange:function(t){return Math.pow(t-this.x,2)<Math.pow(this.radius+this.hitDetectionRadius,2)}}),this.datasets=[],this.options.showTooltips&&e.bindEvents(this,this.options.tooltipEvents,function(t){var i="mouseout"!==t.type?this.getPointsAtEvent(t):[];this.eachPoints(function(t){t.restore(["fillColor","strokeColor"])}),e.each(i,function(t){t.fillColor=t.highlightFill,t.strokeColor=t.highlightStroke}),this.showTooltip(i)}),e.each(t.datasets,function(i){var s={label:i.label||null,fillColor:i.fillColor,strokeColor:i.strokeColor,pointColor:i.pointColor,pointStrokeColor:i.pointStrokeColor,points:[]};this.datasets.push(s),e.each(i.data,function(e,n){s.points.push(new this.PointClass({value:e,label:t.labels[n],datasetLabel:i.label,strokeColor:i.pointStrokeColor,fillColor:i.pointColor,highlightFill:i.pointHighlightFill||i.pointColor,highlightStroke:i.pointHighlightStroke||i.pointStrokeColor}))},this),this.buildScale(t.labels),this.eachPoints(function(t,i){e.extend(t,{x:this.scale.calculateX(i),y:this.scale.endPoint}),t.save()},this)},this),this.render()},update:function(){this.scale.update(),e.each(this.activeElements,function(t){t.restore(["fillColor","strokeColor"])}),this.eachPoints(function(t){t.save()}),this.render()},eachPoints:function(t){e.each(this.datasets,function(i){e.each(i.points,t,this)},this)},getPointsAtEvent:function(t){var i=[],s=e.getRelativePosition(t);return e.each(this.datasets,function(t){e.each(t.points,function(t){t.inRange(s.x,s.y)&&i.push(t)})},this),i},buildScale:function(t){var s=this,n=function(){var t=[];return s.eachPoints(function(i){t.push(i.value)}),t},o={templateString:this.options.scaleLabel,height:this.chart.height,width:this.chart.width,ctx:this.chart.ctx,textColor:this.options.scaleFontColor,fontSize:this.options.scaleFontSize,fontStyle:this.options.scaleFontStyle,fontFamily:this.options.scaleFontFamily,valuesCount:t.length,beginAtZero:this.options.scaleBeginAtZero,integersOnly:this.options.scaleIntegersOnly,calculateYRange:function(t){var i=e.calculateScaleRange(n(),t,this.fontSize,this.beginAtZero,this.integersOnly);e.extend(this,i)},xLabels:t,font:e.fontString(this.options.scaleFontSize,this.options.scaleFontStyle,this.options.scaleFontFamily),lineWidth:this.options.scaleLineWidth,lineColor:this.options.scaleLineColor,showHorizontalLines:this.options.scaleShowHorizontalLines,showVerticalLines:this.options.scaleShowVerticalLines,gridLineWidth:this.options.scaleShowGridLines?this.options.scaleGridLineWidth:0,gridLineColor:this.options.scaleShowGridLines?this.options.scaleGridLineColor:"rgba(0,0,0,0)",padding:this.options.showScale?0:this.options.pointDotRadius+this.options.pointDotStrokeWidth,showLabels:this.options.scaleShowLabels,display:this.options.showScale};this.options.scaleOverride&&e.extend(o,{calculateYRange:e.noop,steps:this.options.scaleSteps,stepValue:this.options.scaleStepWidth,min:this.options.scaleStartValue,max:this.options.scaleStartValue+this.options.scaleSteps*this.options.scaleStepWidth}),this.scale=new i.Scale(o)},addData:function(t,i){e.each(t,function(t,e){this.datasets[e].points.push(new this.PointClass({value:t,label:i,x:this.scale.calculateX(this.scale.valuesCount+1),y:this.scale.endPoint,strokeColor:this.datasets[e].pointStrokeColor,fillColor:this.datasets[e].pointColor}))},this),this.scale.addXLabel(i),this.update()},removeData:function(){this.scale.removeXLabel(),e.each(this.datasets,function(t){t.points.shift()},this),this.update()},reflow:function(){var t=e.extend({height:this.chart.height,width:this.chart.width});this.scale.update(t)},draw:function(t){var i=t||1;this.clear();var s=this.chart.ctx,n=function(t){return null!==t.value},o=function(t,i,s){return e.findNextWhere(i,n,s)||t},a=function(t,i,s){return e.findPreviousWhere(i,n,s)||t};this.scale.draw(i),e.each(this.datasets,function(t){var h=e.where(t.points,n);e.each(t.points,function(t,e){t.hasValue()&&t.transition({y:this.scale.calculateY(t.value),x:this.scale.calculateX(e)},i)},this),this.options.bezierCurve&&e.each(h,function(t,i){var s=i>0&&i<h.length-1?this.options.bezierCurveTension:0;t.controlPoints=e.splineCurve(a(t,h,i),t,o(t,h,i),s),t.controlPoints.outer.y>this.scale.endPoint?t.controlPoints.outer.y=this.scale.endPoint:t.controlPoints.outer.y<this.scale.startPoint&&(t.controlPoints.outer.y=this.scale.startPoint),t.controlPoints.inner.y>this.scale.endPoint?t.controlPoints.inner.y=this.scale.endPoint:t.controlPoints.inner.y<this.scale.startPoint&&(t.controlPoints.inner.y=this.scale.startPoint)},this),s.lineWidth=this.options.datasetStrokeWidth,s.strokeStyle=t.strokeColor,s.beginPath(),e.each(h,function(t,i){if(0===i)s.moveTo(t.x,t.y);else if(this.options.bezierCurve){var e=a(t,h,i);s.bezierCurveTo(e.controlPoints.outer.x,e.controlPoints.outer.y,t.controlPoints.inner.x,t.controlPoints.inner.y,t.x,t.y)}else s.lineTo(t.x,t.y)},this),s.stroke(),this.options.datasetFill&&h.length>0&&(s.lineTo(h[h.length-1].x,this.scale.endPoint),s.lineTo(h[0].x,this.scale.endPoint),s.fillStyle=t.fillColor,s.closePath(),s.fill()),e.each(h,function(t){t.draw()})},this)}})}.call(this),function(){"use strict";var t=this,i=t.Chart,e=i.helpers,s={scaleShowLabelBackdrop:!0,scaleBackdropColor:"rgba(255,255,255,0.75)",scaleBeginAtZero:!0,scaleBackdropPaddingY:2,scaleBackdropPaddingX:2,scaleShowLine:!0,segmentShowStroke:!0,segmentStrokeColor:"#fff",segmentStrokeWidth:2,animationSteps:100,animationEasing:"easeOutBounce",animateRotate:!0,animateScale:!1,legendTemplate:'<ul class="<%=name.toLowerCase()%>-legend"><% for (var i=0; i<segments.length; i++){%><li><span style="background-color:<%=segments[i].fillColor%>"></span><%if(segments[i].label){%><%=segments[i].label%><%}%></li><%}%></ul>'};i.Type.extend({name:"PolarArea",defaults:s,initialize:function(t){this.segments=[],this.SegmentArc=i.Arc.extend({showStroke:this.options.segmentShowStroke,strokeWidth:this.options.segmentStrokeWidth,strokeColor:this.options.segmentStrokeColor,ctx:this.chart.ctx,innerRadius:0,x:this.chart.width/2,y:this.chart.height/2}),this.scale=new i.RadialScale({display:this.options.showScale,fontStyle:this.options.scaleFontStyle,fontSize:this.options.scaleFontSize,fontFamily:this.options.scaleFontFamily,fontColor:this.options.scaleFontColor,showLabels:this.options.scaleShowLabels,showLabelBackdrop:this.options.scaleShowLabelBackdrop,backdropColor:this.options.scaleBackdropColor,backdropPaddingY:this.options.scaleBackdropPaddingY,backdropPaddingX:this.options.scaleBackdropPaddingX,lineWidth:this.options.scaleShowLine?this.options.scaleLineWidth:0,lineColor:this.options.scaleLineColor,lineArc:!0,width:this.chart.width,height:this.chart.height,xCenter:this.chart.width/2,yCenter:this.chart.height/2,ctx:this.chart.ctx,templateString:this.options.scaleLabel,valuesCount:t.length}),this.updateScaleRange(t),this.scale.update(),e.each(t,function(t,i){this.addData(t,i,!0)},this),this.options.showTooltips&&e.bindEvents(this,this.options.tooltipEvents,function(t){var i="mouseout"!==t.type?this.getSegmentsAtEvent(t):[];e.each(this.segments,function(t){t.restore(["fillColor"])}),e.each(i,function(t){t.fillColor=t.highlightColor}),this.showTooltip(i)}),this.render()},getSegmentsAtEvent:function(t){var i=[],s=e.getRelativePosition(t);return e.each(this.segments,function(t){t.inRange(s.x,s.y)&&i.push(t)},this),i},addData:function(t,i,e){var s=i||this.segments.length;this.segments.splice(s,0,new this.SegmentArc({fillColor:t.color,highlightColor:t.highlight||t.color,label:t.label,value:t.value,outerRadius:this.options.animateScale?0:this.scale.calculateCenterOffset(t.value),circumference:this.options.animateRotate?0:this.scale.getCircumference(),startAngle:1.5*Math.PI})),e||(this.reflow(),this.update())},removeData:function(t){var i=e.isNumber(t)?t:this.segments.length-1;this.segments.splice(i,1),this.reflow(),this.update()},calculateTotal:function(t){this.total=0,e.each(t,function(t){this.total+=t.value},this),this.scale.valuesCount=this.segments.length},updateScaleRange:function(t){var i=[];e.each(t,function(t){i.push(t.value)});var s=this.options.scaleOverride?{steps:this.options.scaleSteps,stepValue:this.options.scaleStepWidth,min:this.options.scaleStartValue,max:this.options.scaleStartValue+this.options.scaleSteps*this.options.scaleStepWidth}:e.calculateScaleRange(i,e.min([this.chart.width,this.chart.height])/2,this.options.scaleFontSize,this.options.scaleBeginAtZero,this.options.scaleIntegersOnly);e.extend(this.scale,s,{size:e.min([this.chart.width,this.chart.height]),xCenter:this.chart.width/2,yCenter:this.chart.height/2})},update:function(){this.calculateTotal(this.segments),e.each(this.segments,function(t){t.save()}),this.render()},reflow:function(){e.extend(this.SegmentArc.prototype,{x:this.chart.width/2,y:this.chart.height/2}),this.updateScaleRange(this.segments),this.scale.update(),e.extend(this.scale,{xCenter:this.chart.width/2,yCenter:this.chart.height/2}),e.each(this.segments,function(t){t.update({outerRadius:this.scale.calculateCenterOffset(t.value)})},this)},draw:function(t){var i=t||1;this.clear(),e.each(this.segments,function(t,e){t.transition({circumference:this.scale.getCircumference(),outerRadius:this.scale.calculateCenterOffset(t.value)},i),t.endAngle=t.startAngle+t.circumference,0===e&&(t.startAngle=1.5*Math.PI),e<this.segments.length-1&&(this.segments[e+1].startAngle=t.endAngle),t.draw()},this),this.scale.draw()}})}.call(this),function(){"use strict";var t=this,i=t.Chart,e=i.helpers;i.Type.extend({name:"Radar",defaults:{scaleShowLine:!0,angleShowLineOut:!0,scaleShowLabels:!1,scaleBeginAtZero:!0,angleLineColor:"rgba(0,0,0,.1)",angleLineWidth:1,pointLabelFontFamily:"'Arial'",pointLabelFontStyle:"normal",pointLabelFontSize:10,pointLabelFontColor:"#666",pointDot:!0,pointDotRadius:3,pointDotStrokeWidth:1,pointHitDetectionRadius:20,datasetStroke:!0,datasetStrokeWidth:2,datasetFill:!0,legendTemplate:'<ul class="<%=name.toLowerCase()%>-legend"><% for (var i=0; i<datasets.length; i++){%><li><span style="background-color:<%=datasets[i].strokeColor%>"></span><%if(datasets[i].label){%><%=datasets[i].label%><%}%></li><%}%></ul>'},initialize:function(t){this.PointClass=i.Point.extend({strokeWidth:this.options.pointDotStrokeWidth,radius:this.options.pointDotRadius,display:this.options.pointDot,hitDetectionRadius:this.options.pointHitDetectionRadius,ctx:this.chart.ctx}),this.datasets=[],this.buildScale(t),this.options.showTooltips&&e.bindEvents(this,this.options.tooltipEvents,function(t){var i="mouseout"!==t.type?this.getPointsAtEvent(t):[];this.eachPoints(function(t){t.restore(["fillColor","strokeColor"])}),e.each(i,function(t){t.fillColor=t.highlightFill,t.strokeColor=t.highlightStroke}),this.showTooltip(i)}),e.each(t.datasets,function(i){var s={label:i.label||null,fillColor:i.fillColor,strokeColor:i.strokeColor,pointColor:i.pointColor,pointStrokeColor:i.pointStrokeColor,points:[]};this.datasets.push(s),e.each(i.data,function(e,n){var o;this.scale.animation||(o=this.scale.getPointPosition(n,this.scale.calculateCenterOffset(e))),s.points.push(new this.PointClass({value:e,label:t.labels[n],datasetLabel:i.label,x:this.options.animation?this.scale.xCenter:o.x,y:this.options.animation?this.scale.yCenter:o.y,strokeColor:i.pointStrokeColor,fillColor:i.pointColor,highlightFill:i.pointHighlightFill||i.pointColor,highlightStroke:i.pointHighlightStroke||i.pointStrokeColor}))},this)},this),this.render()},eachPoints:function(t){e.each(this.datasets,function(i){e.each(i.points,t,this)},this)},getPointsAtEvent:function(t){var i=e.getRelativePosition(t),s=e.getAngleFromPoint({x:this.scale.xCenter,y:this.scale.yCenter},i),n=2*Math.PI/this.scale.valuesCount,o=Math.round((s.angle-1.5*Math.PI)/n),a=[];return(o>=this.scale.valuesCount||0>o)&&(o=0),s.distance<=this.scale.drawingArea&&e.each(this.datasets,function(t){a.push(t.points[o])}),a},buildScale:function(t){this.scale=new i.RadialScale({display:this.options.showScale,fontStyle:this.options.scaleFontStyle,fontSize:this.options.scaleFontSize,fontFamily:this.options.scaleFontFamily,fontColor:this.options.scaleFontColor,showLabels:this.options.scaleShowLabels,showLabelBackdrop:this.options.scaleShowLabelBackdrop,backdropColor:this.options.scaleBackdropColor,backdropPaddingY:this.options.scaleBackdropPaddingY,backdropPaddingX:this.options.scaleBackdropPaddingX,lineWidth:this.options.scaleShowLine?this.options.scaleLineWidth:0,lineColor:this.options.scaleLineColor,angleLineColor:this.options.angleLineColor,angleLineWidth:this.options.angleShowLineOut?this.options.angleLineWidth:0,pointLabelFontColor:this.options.pointLabelFontColor,pointLabelFontSize:this.options.pointLabelFontSize,pointLabelFontFamily:this.options.pointLabelFontFamily,pointLabelFontStyle:this.options.pointLabelFontStyle,height:this.chart.height,width:this.chart.width,xCenter:this.chart.width/2,yCenter:this.chart.height/2,ctx:this.chart.ctx,templateString:this.options.scaleLabel,labels:t.labels,valuesCount:t.datasets[0].data.length}),this.scale.setScaleSize(),this.updateScaleRange(t.datasets),this.scale.buildYLabels()},updateScaleRange:function(t){var i=function(){var i=[];return e.each(t,function(t){t.data?i=i.concat(t.data):e.each(t.points,function(t){i.push(t.value)})}),i}(),s=this.options.scaleOverride?{steps:this.options.scaleSteps,stepValue:this.options.scaleStepWidth,min:this.options.scaleStartValue,max:this.options.scaleStartValue+this.options.scaleSteps*this.options.scaleStepWidth}:e.calculateScaleRange(i,e.min([this.chart.width,this.chart.height])/2,this.options.scaleFontSize,this.options.scaleBeginAtZero,this.options.scaleIntegersOnly);e.extend(this.scale,s)},addData:function(t,i){this.scale.valuesCount++,e.each(t,function(t,e){var s=this.scale.getPointPosition(this.scale.valuesCount,this.scale.calculateCenterOffset(t));this.datasets[e].points.push(new this.PointClass({value:t,label:i,x:s.x,y:s.y,strokeColor:this.datasets[e].pointStrokeColor,fillColor:this.datasets[e].pointColor}))},this),this.scale.labels.push(i),this.reflow(),this.update()},removeData:function(){this.scale.valuesCount--,this.scale.labels.shift(),e.each(this.datasets,function(t){t.points.shift()},this),this.reflow(),this.update()},update:function(){this.eachPoints(function(t){t.save()}),this.reflow(),this.render()},reflow:function(){e.extend(this.scale,{width:this.chart.width,height:this.chart.height,size:e.min([this.chart.width,this.chart.height]),xCenter:this.chart.width/2,yCenter:this.chart.height/2}),this.updateScaleRange(this.datasets),this.scale.setScaleSize(),this.scale.buildYLabels()},draw:function(t){var i=t||1,s=this.chart.ctx;this.clear(),this.scale.draw(),e.each(this.datasets,function(t){e.each(t.points,function(t,e){t.hasValue()&&t.transition(this.scale.getPointPosition(e,this.scale.calculateCenterOffset(t.value)),i)},this),s.lineWidth=this.options.datasetStrokeWidth,s.strokeStyle=t.strokeColor,s.beginPath(),e.each(t.points,function(t,i){0===i?s.moveTo(t.x,t.y):s.lineTo(t.x,t.y)},this),s.closePath(),s.stroke(),s.fillStyle=t.fillColor,s.fill(),e.each(t.points,function(t){t.hasValue()&&t.draw()})},this)}})}.call(this);

/**
 * The Circle Menu object represents a choice menu of multiple menu items. The type of data provider value for a circle menu control should point to a property in the data provider that would follow the same rules as hard coding an array of items.<br><br>
 * <b>Sample Declaration</b><br>
 * <pre>
 * {
 *   component: $ui.CircleMenu,
 *    items: [
 *    {
 *        caption: 'music',
 *        visible: false,
 *        img: 'img/music.png'
 *    },
 *    {
 *        caption: 'maps',
 *        img: 'img/maps.png'
 *    }],
 *    onclick: function(item) {
 *        console.log(item.caption + ' clicked');
 *    }
 *}
 * @namespace CircleMenu
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {$ui.CircleMenuItem[]} [items] - The items property is an array of menu items to be displayed in the control
 * @property {CircleMenuClickEvent} [onclick] - This event fires when an item in the menu is clicked. The parameter passed to the event is [the item]{@link $ui.CircleMenuItem} which was clicked.
 */
function $ui_CircleMenu(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom,'ui-circle-menu');
	
	// Holds our indicators
	object._protected.indicators = [];
	
	// Create our inner scrollable area
	object.dom.inner = document.createElement('div');
	$ui.addClass(object.dom.inner, 'inner');
	object.dom.appendChild(object.dom.inner);
	
	// Create indicator area
	object.dom.indicatorContainer = document.createElement('div');
	$ui.addClass(object.dom.indicatorContainer, 'indicator-container');
	object.dom.appendChild(object.dom.indicatorContainer);
	
	// Items property
	if (object.items == undefined) {
		object.items = [];
	}
	object._protected.items = object.items;
	Object.defineProperty(object, 'items', {
		get: function() {return this._protected.items;},
		set: function() {
			console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','items'));					
		},
		configurable: false}
	);
	
	// Re layout the menu items
	object._recalculateLayout = function() {
		if (this.items.length === 0) return;
		var i,
			x,
			y,
			item,
			coord,
			visibleItems = [],
			offsetHeight = this.dom.offsetHeight,
			offsetWidth = this.dom.offsetWidth,
			coordinates = [];
		// Gather only our visible items
		for (i = 0; i < this.items.length; i++) {
			item = this.items[i];
			if (item.visible == true) {
				visibleItems.push(item);
			}
		}
		var numItems = visibleItems.length,
			numIndicators = Math.ceil(numItems/6),
			indicator,
			size = visibleItems[0].getSize();
			
		// Clear old indicators
		for (i = 0; i < this._protected.indicators.length; i++) {
			indicator = this._protected.indicators[i];
			indicator.parentNode.removeChild(indicator);
		}
		this._protected.indicators = [];
			
		// Draw our page indicators if necessary
		if (numIndicators > 1) {
			this.dom.indicatorContainer.style.display = 'block';
			this.dom.inner.style.cursor = 'pointer';
			// Handle our gestures
			this._protected.hammer = new Hammer(this.dom.inner);
			this._protected.hammer.on('pan', this._onpan);
			this._protected.hammer.on('panend', this._onpanend);
			this._protected.hammer.on('pancancel', this._onpanend);
			this._protected.hammer.on('swipeleft', this._onswipeleft);
			this._protected.hammer.on('swiperight', this._onswiperight);
			// Set our indicators
			for (i = 0; i < numIndicators; i++) {
				indicator = document.createElement('div');
				indicator._index = i;
				$ui.addClass(indicator,'indicator');
				this.dom.indicatorContainer.appendChild(indicator);
				this._protected.indicators.push(indicator);
				indicator.inner = document.createElement('div');
				$ui.addClass(indicator.inner, 'inner theme-circle-menu-indicator');
				if (i == 0) {
					$ui.addClass(indicator.inner,'theme-circle-menu-indicator-selected');
				}
				indicator.appendChild(indicator.inner);
			}
			this._protected.selectedIndicator = this._protected.indicators[0];
			this.dom.indicatorContainer.style.width = (numIndicators * 40) + 'px';
			this.dom.inner.style['-webkit-transition'] = '-webkit-transform 0.1s ease-out';
			this.dom.inner.style['-webkit-transform'] = 'translate3d(0px,0px,0px)';
		} else {
			this.dom.indicatorContainer.style.display = 'none';
			this.dom.inner.style.cursor = 'default';
			this._protected.hammer = undefined;
			this._protected.selectedIndicator = undefined;
		}
		this.dom.inner.style.width = (numIndicators * 100) + '%';
			
		// Determine our layout
		if ($system && $system.isClientDevice) {
			var coord,
				row = 0,
				col = 0,
				maxItems = (numItems > 6) ? 6 : numItems,
				slot = Math.floor(offsetWidth/2),
				xOffset = Math.floor(slot/2 - size/2),
				rowHeight = Math.floor(offsetHeight/3),
				yOffset = Math.floor(rowHeight/2 - size/2);
			// Loop through and set our coordinates
			for (i = 0; i < maxItems; i++) {
				coord = {
					X: (col * slot) + xOffset,
					Y: (row * rowHeight) + yOffset
				};
				coordinates.push(coord);
				col++
				if (col > 1) {
					row++;
					col = 0;
				}
			}
		} else {
			switch (true) {
				case (numItems <= 3):
					var buffer = (numItems === 2) ? Math.floor(size/2) : 0, // This provides some spacing on the left/right
						slot = Math.floor((offsetWidth-(buffer*2))/numItems),
						xOffset = Math.floor(slot/2 - size/2);
					y = Math.floor(offsetHeight/2 - size/2);
					for (i = 0; i < numItems; i++) {
						coord = {
							X: (i * slot) + buffer + xOffset,
							Y: y
						};
						coordinates.push(coord);
					}
					break;
				case (numItems <= 6):
						var slot = Math.floor(offsetWidth/3),
							xOffset = Math.floor(slot/2 - size/2),
							row = Math.floor(offsetHeight/2),
							yOffset = Math.floor(row/2 - size/2);
						// Top row
						for (i = 0; i < 3; i++) {
							coord = {
								X: (i * slot) + xOffset,
								Y: yOffset
							};
							coordinates.push(coord);
						}
						// Now bottom row
						var buffer = ((numItems-3) === 2) ? Math.floor(size/2) : 0;
						slot = Math.floor((offsetWidth-(buffer*2))/(numItems-3));
						xOffset = Math.floor(slot/2 - size/2);
						for (i = 3; i < numItems; i++) {
							coord = {
								X: ((i-3) * slot) + buffer + xOffset,
								Y: row + yOffset
							};
							coordinates.push(coord);
						}
					break;				
				case (numItems > 6):
					var numInserted = 0,
						page = 0;
					while (numInserted < numItems) {
						var slot = Math.floor(offsetWidth/3),
							xOffset = Math.floor(slot/2 - size/2) + (page * offsetWidth),
							row = Math.floor(offsetHeight/2),
							yOffset = Math.floor(row/2 - size/2);
						// Top row
						for (i = 0; (i < 3) && (numInserted < numItems); i++) {
							coord = {
								X: (i * slot) + xOffset,
								Y: yOffset
							};
							coordinates.push(coord);
							numInserted++;
						}
						if (numInserted < numItems) {
							// Now bottom row
							var buffer = ((numItems - numInserted) === 2) ? Math.floor(size/2) : 0,
								numSlots = ((numItems - numInserted) >= 3) ? 3 : (numItems - numInserted);
							slot = Math.floor((offsetWidth-(buffer*2))/numSlots);
							xOffset = Math.floor(slot/2 - size/2) + (page * offsetWidth);
							for (i = 3; (i < numItems) && (numInserted < numItems) && (i < 6); i++) {
								coord = {
									X: ((i-3) * slot) + buffer + xOffset,
									Y: row + yOffset
								};
								coordinates.push(coord);
								numInserted++;
							}
						}
						page++;
					}
					break;
			}
		}
		// Set our coordinates
		for (i = 0; i < visibleItems.length; i++) {
			item = visibleItems[i];
			coord = coordinates[i];
			item.dom.style['-webkit-transform'] = 'translate('+coord.X+'px,'+coord.Y+'px)';
		}
	}.$bind(object);
	
	// Reset our transition flag for menu items to know not to click when in transition
	object._resetTransition = function() {
		this._protected.inTransition = false;
	}.$bind(object);
	
	// Handle the dragging of the menu
	object._onpan = function(event) {
		if (this._protected.selectedIndicator == undefined) return;
		this._protected.inTransition = true;
		if (this._protected.swiping == true) return;
		var location = 0;
		if (this._protected.selectedIndicator._index > 0) {
			location = (this._protected.selectedIndicator._index * this.dom.offsetWidth)*(-1);
		}
		this.dom.inner.style['-webkit-transition'] = '';
		this.dom.inner.style['-webkit-transform'] = 'translate3d('+ (location + event.deltaX) + 'px,0px,0px)';
	}.$bind(object);
	
	// Handle the drag end of the menu
	object._onpanend = function(event) {
		window.setTimeout(this._resetTransition,0);
		// Don't adjust if there was a swipe gesture
		if (this._protected.swiping == true) {
			this._protected.swiping = false;
			return;
		}
		if(Math.abs(event.deltaX) > (this.dom.offsetWidth / 2)) {
			if(event.deltaX > 0) {
				if (this._protected.selectedIndicator && this._protected.selectedIndicator._index > 0) {
					this._decreaseIndicator();
				} else {
					this.dom.inner.style['-webkit-transition'] = '-webkit-transform 0.1s ease-out';
					this.dom.inner.style['-webkit-transform'] = 'translate3d(-'+ (this._protected.selectedIndicator._index * this.dom.offsetWidth) +'px,0px,0px)';
				}
			} else {
				if (this._protected.selectedIndicator && this._protected.selectedIndicator._index < this._protected.indicators.length -1) {
					this._increaseIndicator();
				} else {
					this.dom.inner.style['-webkit-transition'] = '-webkit-transform 0.1s ease-out';
					this.dom.inner.style['-webkit-transform'] = 'translate3d(-'+ (this._protected.selectedIndicator._index * this.dom.offsetWidth) +'px,0px,0px)';
				}
			}	
		} else {
			this.dom.inner.style['-webkit-transition'] = '-webkit-transform 0.1s ease-out';
			this.dom.inner.style['-webkit-transform'] = 'translate3d(-'+ (this._protected.selectedIndicator._index * this.dom.offsetWidth) +'px,0px,0px)';
		}
	}.$bind(object);
	
	// Handle the swipe left of the menu
	object._onswipeleft = function(event) {
		this._protected.swiping = true;
		this._increaseIndicator();
	}.$bind(object);
	
	// Handle the swipe right of the menu
	object._onswiperight = function(event) {
		this._protected.swiping = true;
		this._decreaseIndicator();
	}.$bind(object);
	
	// Increases the indicator location and current selected indicator
	object._increaseIndicator = function() {
		if (this._protected.selectedIndicator == undefined) return;
		if (this._protected.selectedIndicator._index <= this._protected.indicators.length - 2) {
			this._protected.selectedIndicator = this._protected.indicators[this._protected.selectedIndicator._index + 1];
			$ui.addClass(this._protected.selectedIndicator.inner,'theme-circle-menu-indicator-selected');
			var i,
				indicator;
			for (i = 0; i < this._protected.indicators.length; i++) {
				indicator = this._protected.indicators[i];
				if (indicator != this._protected.selectedIndicator) {
					$ui.removeClass(indicator.inner,'theme-circle-menu-indicator-selected');
				}
			}
		} 	
		this.dom.inner.style['-webkit-transition'] = '-webkit-transform 0.1s ease-out';
		this.dom.inner.style['-webkit-transform'] = 'translate3d(-'+ (this._protected.selectedIndicator._index * this.dom.offsetWidth) +'px,0px,0px)';
	}.$bind(object);
	
	// Decreases the indicator location and current selected indicator
	object._decreaseIndicator = function() {
		if (this._protected.selectedIndicator == undefined) return;
		if (this._protected.selectedIndicator._index > 0) {
			this._protected.selectedIndicator = this._protected.indicators[this._protected.selectedIndicator._index - 1];
			$ui.addClass(this._protected.selectedIndicator.inner,'theme-circle-menu-indicator-selected');
			var i,
				indicator;
			for (i = 0; i < this._protected.indicators.length; i++) {
				indicator = this._protected.indicators[i];
				if (indicator != this._protected.selectedIndicator) {
					$ui.removeClass(indicator.inner,'theme-circle-menu-indicator-selected');
				}
			}
		} 	
		this.dom.inner.style['-webkit-transition'] = '-webkit-transform 0.1s ease-out';
		this.dom.inner.style['-webkit-transform'] = 'translate3d(-'+ (this._protected.selectedIndicator._index * this.dom.offsetWidth) +'px,0px,0px)';
	}.$bind(object);
	
	// Private function to add a new item to the list
	object._addItem = function(item) {
		item.parent = this;
		itemDom = new $ui_CircleMenuItem(item, this.screen);
		if (itemDom) {
			this.dom.inner.appendChild(itemDom);
			return true;
		} else {
			return false;
		}
	}.$bind(object);
	
	/** 
	 * You can add an item to the end of the menu by calling the addItem function and passing in an object that matches the a menu item
	 * @function addItem
	 * @memberof $ui.CircleMenu
	 * @param {$ui.CircleMenuItem} item - Item to be added to the menu
	 */
	object.addItem = function(item) {
		if (this._addItem(item)) {
			this.items.push(item);
			return true;
		} else {
			return false;
		}
		this._recalculateLayout();
	}.$bind(object);
	
	/** 
	 * You can refresh all the items in a menu by calling the refreshItems function with an array of new items
	 * @function refreshItems
	 * @memberof $ui.CircleMenu
	 * @param {$ui.CircleMenuItem[]} items - Array of items to refresh the menu
	 */
	object.refreshItems = function(itemArray) {
		if (itemArray == undefined) return; // No data provided
		var i,
			item;
		if (this.items) {
			// Remove all existing items first
			for (i = this.items.length - 1; i >= 0; i--) {
				item = this.items[i];
				try {
					if (item.dom && item.dom.parentNode) {
						item.dom.parentNode.removeChild(item.dom);
					}
				} catch (ex) {
					console.log('$ui.List: ' + ex);
				}
				this.items.pop();
				if (item._destroy) {
					item._destroy();
				}
			}
		}
		this.addItemBatch(itemArray);
	}.$bind(object);
	
	/** 
	 * This function is much like the refreshItems function but instead it loads a list of circle menu items to the end of the current menu and does not replace the existing menu items.
	 * @function addItemBatch
	 * @memberof $ui.CircleMenu
	 * @param {$ui.CircleMenuItem[]} items - Array of items to be added to the menu
	 */
	object.addItemBatch = function(itemArray) {
		var i,
			item;
		// Add all new items into the list
		for (i = 0; i < itemArray.length; i++) {
			item = itemArray[i];
			if (this._addItem(item)) {
				this.items.push(item);
			}
		}
		this._recalculateLayout();
	}.$bind(object);
	
	/** 
	 * Insert item works similar to addItem but instead will insert the item into the menu at the index specified. If an invalid index is specified it will result in failure to insert the item. To insert an item at the top of a menu call insert with the index of 0.
	 * @function insertItem
	 * @memberof $ui.CircleMenu
	 * @param {$ui.CircleMenuItem} item - Item to be inserted into the menu
	 * @param {number} index - Index to insert the item
	 */
	object.insertItem = function(item, index) {
		item.parent = this;
		if (index < 0) {
			return false;
		} else if (this.items.length == 0) {
			this.addItem(item);
			return true;
		} else if (index > this.items.length - 1) {
			this.addItem(item);
			return true;
		} else { // Insert it at the index
			var existingItem = this.items[index],
				itemDom = new $ui_CircleMenuItem(item, this.screen);
			this.items.splice(index, 0, item);
			this.dom.inner.insertBefore(itemDom, existingItem.dom);
			return true;
		} 
		return false;
	}.$bind(object);
	
	// Private function to handle provider updates
	object._providerUpdate = function(value) {
		this.refreshItems(value);
	}.$bind(object);
	
	// Handle resize of screen
	object._onresize = function() {
		this._recalculateLayout();
	}.$bind(object);
	
	// If there is no data provider then just create the items
	if (!object.provider) {
		var i,
			item,
			itemDom;
		for (i = 0; i < object.items.length; i++) {
			item = object.items[i];
			object._addItem(item);
		}
		// Re-calculate once the screen dimensions have been calculated
		setTimeout(object._onresize,0); 
	}	
	
	return object.dom;
}

/**
 * The {@link $ui.CircleMenu} <b>onclick</b> event will fire when the user clicks a menu item
 * @callback CircleMenuClickEvent
 * @param {$ui.CircleMenuItem} item - The menu item that the user clicked
 */
/**
 * A circle menu item is used within a [Circle Menu]{@link $ui.CircleMenu}.  <b>NOTE: It cannot be defined on its own outside of a circle menu</b> 
 * @namespace CircleMenuItem
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {string} caption - Text to appear on the menu item
 * @property {string} img - Path to the image to be displayed in the menu item
 */
function $ui_CircleMenuItem(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom,'menu-item');
	
	// Create inner circle
	object.dom.inner = document.createElement('div');
	object.dom.inner.model = object;
	$ui.addClass(object.dom.inner,'circle theme-border-color theme-screen-background-color');
	object.dom.appendChild(object.dom.inner);
	object.dom.inner.onclick = function(event) {
		if (this.model.parent._protected.inTransition == true) return; // Don't want to click while user is swiping
		this.model._raiseInteractionEvent('data-interaction-click');
		$ui.playTouchSound();
		if (this.model.parent.onclick) {
			this.model.parent.onclick(this.model);
		}
	}
	object.dom.inner.ontouchstart = function() {
		$ui.addClass(this,'theme-brand-background-color');
	}
	object.dom.inner.ontouchend = function() {
		$ui.removeClass(this,'theme-brand-background-color');
	}
	object.dom.inner.ontouchcancel = object.dom.inner.ontouchend;
	if (!$ui.isMobileDevice()) {
		object.dom.inner.onmousedown = object.dom.inner.ontouchstart;
		object.dom.inner.onmouseup = object.dom.inner.ontouchend;
		object.dom.inner.onmouseleave = object.dom.inner.ontouchend;
	}
	// Add our mark for automation
	if (object.id) {
		object.dom.inner.setAttribute('data-interaction-click', object.id);
	}
	
	// Create the icon area 
	object.dom.icon = document.createElement('div');
	$ui.addClass(object.dom.icon,'icon');
	object.dom.inner.appendChild(object.dom.icon);
	
	// Image Property
	if (object.img) {
		object.dom.icon.style.backgroundImage = 'url("'+ object.img + '")';
	}
	object._protected.img = object.img;
	Object.defineProperty(object, 'img', {
		get: function() {return this._protected.img;},
		set: function(value) {
			if (value == this._protected.img) return;
			this._protected.img = value;
			if (value == undefined) {
				this.dom.icon.style.backgroundImage = '';
			} else {
				this.dom.icon.style.backgroundImage = 'url("'+ value + '")';
			}
		},
		configurable: false}
	);
	
	// Caption Property
	object.dom.captionDiv = document.createElement('div');
	$ui.addClass(object.dom.captionDiv,'caption theme-text-color');
	object.dom.appendChild(object.dom.captionDiv);
	if (object.caption) {
		object.dom.captionDiv.textContent = object.caption;
	}
	object._protected.caption = object.caption;
	Object.defineProperty(object, 'caption', {
		get: function() {return this._protected.caption;},
		set: function(value) {
			if (value == this._protected.caption) return;
			this._protected.caption = value;
			if (value == undefined) {
				this.dom.captionDiv.textContent = '';
			} else {
				this.dom.captionDiv.textContent = value;
			}
		},
		configurable: false}
	);
	
	// Returns the size of the menu item
	object.getSize = function() {
		return this.dom.offsetWidth;
	}
	object.getSize = object.getSize.$bind(object);
	
	// Handle Visibility change
	object._setVisible = function(value) {
		if (this.parent) {
			this.parent._recalculateLayout();
		}
	}
	object._setVisible = object._setVisible.$bind(object);
	
	return object.dom;
}
/**
 * A Column represents a column of user interface items in a {@link $ui.ColumnLayout}
 * @namespace Column
 * @memberof $ui
 * @property {number} [span=1] - Specifies the span of the column.
 * @property {$ui.CoreComponent[]} [content] - Specifies the controls to be displayed in this column
*/
function $ui_Column(object, screen){
	$ui_CoreComponent.call(this, object, screen);
	if (object) {
		$ui.addClass(object.dom, 'ui-column');
		
		// Set our span
		if (object.span) {
			object.dom.style.width = (object._spanPercentage * object.span) + '%';
		} else {
			object.dom.style.width = object._spanPercentage + '%';
		}
		
		// content property
		if (object.content == undefined) {
			object.content = [];
		}
		object._protected.content = object.content;
		Object.defineProperty(object, 'content', {
			get: function() {return this._protected.content;},
			set: function() {
				console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','content'));
			},
			configurable: false}
		);
		
		// Now create the content
		var j,
			control;
		for (j = 0; j < object.content.length; j++) {
			control = object.content[j];
			controlDom = $ui.createControl(control, screen);
			if (controlDom) {
				object.dom.appendChild(controlDom);
			}
		}
		
		/** 
		 * Validate all the controls contained in this column (including nested controls) and return the boolean result
		 * @function validate
		 * @memberof $ui.Column
		 * @returns {boolean}
		 */
		object.validate = function() {
			var i,
				control,
				result = true;
			for (i = 0; i < this.content.length; i++) {
				control = this.content[i];
				if (control.validate)  {
					if (control.validate() == false) {
						result = false;
					}
				}
			}
			return result;
		}.$bind(object);
		
		// This function is called to cascade down a visibility change to child controls
		object._cascadeVisibility = function() {
			var i,
				control;			
			for (i = 0; i < this.content.length; i++) {
				control = this.content[i];
				if (control._cascadeVisibility) {
					control._cascadeVisibility();
				} else {
					if (control._onshow) {
						control._onshow();
					}
				}
			}
		}.$bind(object);
		
		// Cascade our visibility when it is set to "true"
		object._setVisible = function(value) {
			if (value == true) {
				this._cascadeVisibility();
			}
		}.$bind(object);
		
		return object.dom;
	}
}

/**
 * A Column layout specifies a set of columns which contain controls.  The number of columns, or their span, will determine the percentage width for each column
 * @namespace ColumnLayout
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {$ui.Column[]} columns - Contains all of the columns for this ColumnLayout
 * @property {boolean} [padding=false] - Specify <b>true</b> if you wish each of the columns to have padding inside them
 * @property {boolean} [fillToParent=false] - If set to <b>true</b> this column layout will grow to 100% of the height of its container.
*/
function $ui_ColumnLayout(object, screen){
	$ui_CoreComponent.call(this, object, screen);
	// Make sure this is only added to a HomeScreen
	if (object) {
		$ui.addClass(object.dom, 'ui-column-layout');
		
		// Check for padding
		if (object.padding == true) {
			$ui.addClass(object.dom, 'padding');
		}
		
		// Columns property
		if (object.columns == undefined) {
			object.columns = [];
		}
		object._protected.columns = object.columns;
		Object.defineProperty(object, 'columns', {
			get: function() {return this._protected.columns;},
			set: function() {
				console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','columns'));
			},
			configurable: false}
		);
		
		// fillToParent property
		if (object.fillToParent != true) {
			object.fillToParent = false;
		} else {
			$ui.addClass(object.dom,'fill');
		}
		object._protected.fillToParent = object.fillToParent;
		Object.defineProperty(object, 'fillToParent', {
			get: function() {return this._protected.fillToParent;},
			set: function(value) {
				if (value == this._protected.fillToParent) return;
				if (value == true) {
					$ui.addClass(this.dom, 'fill');
				} else {
					$ui.removeClass(this.dom,'fill');
				}
				this._protected.fillToParent = value;
			},
			configurable: false}
		);
		
		// Cycle through columns
		var i,
			j,
			column,
			spanPercentage,
			spanCount = 0,
			control,
			controlDom;
		// First move through to understand what a span of 1 is equal to
		for (i = 0; i < object.columns.length; i++) {
			column = object.columns[i];
			if (column.span) {
				spanCount = spanCount + column.span;
			} else {
				spanCount++;
			}
		}
		// Figure out our percentage
		if (spanCount == 0) {
			spanPercentage = 100;
		} else {
			spanPercentage = 100/spanCount;
		}
		// Now create the columns
		for (i = 0; i < object.columns.length; i++) {
			column = object.columns[i];
			column._spanPercentage = spanPercentage;
			if (column.component != $ui.Column) continue;
			new $ui_Column(column, screen);
			object.dom.appendChild(column.dom);
		}
		// Add a div to the end to ensure the container this column layout is embedded in grows to the height of the 
		// tallest column
		object.dom.clearElement = document.createElement('div');
		$ui.addClass(object.dom.clearElement, 'clear-element');
		object.dom.appendChild(object.dom.clearElement);
		
		/** 
		 * Validate all the controls contained in this column layout (including nested controls) and return the boolean result
		 * @function validate
		 * @memberof $ui.ColumnLayout
		 * @returns {boolean}
		 */
		object.validate = function() {
			var i,
				column,
				result = true;
			for (i = 0; i < this.columns.length; i++) {
				column = this.columns[i];
				if (column.validate() == false) {
						result = false;
				}
			}
			return result;
		}.$bind(object);
		
		// This function is called to cascade down a visibility change to child controls
		object._cascadeVisibility = function() {
			var i,
				column;
			for (i = 0; i < this.columns.length; i++) {
				column = this.columns[i];
				if (column._cascadeVisibility) {
					column._cascadeVisibility();
				}
			}
		}.$bind(object);
		
		// Cascade our visibility when it is set to "true"
		object._setVisible = function(value) {
			if (value == true) {
				this._cascadeVisibility();
			}
		}.$bind(object);
		
		return object.dom;	
	}
}

/**
 * The Control Group object represents a grouping of multiple different controls.  This component can be useful when you want to group different controls together for toggling visibility.<br><br>
 * <b>Sample Declaration</b><br>
 * <pre>
 * {
 *   component: $ui.ControlGroup,
 *    id: 'myGrouping',
 *    content: [
 *       {
 *           component: $ui.Header,
 *           caption: 'My Header',
 *       },
 *       {
 *           component: $ui.List,
 *           style: $ui.GenericListItem
 *       }
 *    ]
 *}
 * @namespace ControlGroup
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {$ui.CoreComponent[]} [content] - The content property is an array of control definitions to be displayed in the control
*/
function $ui_ControlGroup(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom,'ui-control-group');
	
	// Content property
	if (object.content == undefined) {
		object.content = [];
	}
	object._protected.content = object.content;
	Object.defineProperty(object, 'content', {
		get: function() {return this._protected.content;},
		set: function() {
			console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','content'));			
		},
		configurable: false}
	);
	if (object.content) {
		var i,
			item,
			itemDom;
		for (i = 0; i < object.content.length; i++) {
			item = object.content[i];
			itemDom = $ui.createControl(item, object.screen);
			if (itemDom) {
				object.dom.appendChild(itemDom);
			}
		}
	}	
	
	return object.dom;
}
/*! Hammer.JS - v2.0.4 - 2014-09-28
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2014 Jorik Tangelder;
 * Licensed under the MIT license */
!function(a,b,c,d){"use strict";function e(a,b,c){return setTimeout(k(a,c),b)}function f(a,b,c){return Array.isArray(a)?(g(a,c[b],c),!0):!1}function g(a,b,c){var e;if(a)if(a.forEach)a.forEach(b,c);else if(a.length!==d)for(e=0;e<a.length;)b.call(c,a[e],e,a),e++;else for(e in a)a.hasOwnProperty(e)&&b.call(c,a[e],e,a)}function h(a,b,c){for(var e=Object.keys(b),f=0;f<e.length;)(!c||c&&a[e[f]]===d)&&(a[e[f]]=b[e[f]]),f++;return a}function i(a,b){return h(a,b,!0)}function j(a,b,c){var d,e=b.prototype;d=a.prototype=Object.create(e),d.constructor=a,d._super=e,c&&h(d,c)}function k(a,b){return function(){return a.apply(b,arguments)}}function l(a,b){return typeof a==kb?a.apply(b?b[0]||d:d,b):a}function m(a,b){return a===d?b:a}function n(a,b,c){g(r(b),function(b){a.addEventListener(b,c,!1)})}function o(a,b,c){g(r(b),function(b){a.removeEventListener(b,c,!1)})}function p(a,b){for(;a;){if(a==b)return!0;a=a.parentNode}return!1}function q(a,b){return a.indexOf(b)>-1}function r(a){return a.trim().split(/\s+/g)}function s(a,b,c){if(a.indexOf&&!c)return a.indexOf(b);for(var d=0;d<a.length;){if(c&&a[d][c]==b||!c&&a[d]===b)return d;d++}return-1}function t(a){return Array.prototype.slice.call(a,0)}function u(a,b,c){for(var d=[],e=[],f=0;f<a.length;){var g=b?a[f][b]:a[f];s(e,g)<0&&d.push(a[f]),e[f]=g,f++}return c&&(d=b?d.sort(function(a,c){return a[b]>c[b]}):d.sort()),d}function v(a,b){for(var c,e,f=b[0].toUpperCase()+b.slice(1),g=0;g<ib.length;){if(c=ib[g],e=c?c+f:b,e in a)return e;g++}return d}function w(){return ob++}function x(a){var b=a.ownerDocument;return b.defaultView||b.parentWindow}function y(a,b){var c=this;this.manager=a,this.callback=b,this.element=a.element,this.target=a.options.inputTarget,this.domHandler=function(b){l(a.options.enable,[a])&&c.handler(b)},this.init()}function z(a){var b,c=a.options.inputClass;return new(b=c?c:rb?N:sb?Q:qb?S:M)(a,A)}function A(a,b,c){var d=c.pointers.length,e=c.changedPointers.length,f=b&yb&&d-e===0,g=b&(Ab|Bb)&&d-e===0;c.isFirst=!!f,c.isFinal=!!g,f&&(a.session={}),c.eventType=b,B(a,c),a.emit("hammer.input",c),a.recognize(c),a.session.prevInput=c}function B(a,b){var c=a.session,d=b.pointers,e=d.length;c.firstInput||(c.firstInput=E(b)),e>1&&!c.firstMultiple?c.firstMultiple=E(b):1===e&&(c.firstMultiple=!1);var f=c.firstInput,g=c.firstMultiple,h=g?g.center:f.center,i=b.center=F(d);b.timeStamp=nb(),b.deltaTime=b.timeStamp-f.timeStamp,b.angle=J(h,i),b.distance=I(h,i),C(c,b),b.offsetDirection=H(b.deltaX,b.deltaY),b.scale=g?L(g.pointers,d):1,b.rotation=g?K(g.pointers,d):0,D(c,b);var j=a.element;p(b.srcEvent.target,j)&&(j=b.srcEvent.target),b.target=j}function C(a,b){var c=b.center,d=a.offsetDelta||{},e=a.prevDelta||{},f=a.prevInput||{};(b.eventType===yb||f.eventType===Ab)&&(e=a.prevDelta={x:f.deltaX||0,y:f.deltaY||0},d=a.offsetDelta={x:c.x,y:c.y}),b.deltaX=e.x+(c.x-d.x),b.deltaY=e.y+(c.y-d.y)}function D(a,b){var c,e,f,g,h=a.lastInterval||b,i=b.timeStamp-h.timeStamp;if(b.eventType!=Bb&&(i>xb||h.velocity===d)){var j=h.deltaX-b.deltaX,k=h.deltaY-b.deltaY,l=G(i,j,k);e=l.x,f=l.y,c=mb(l.x)>mb(l.y)?l.x:l.y,g=H(j,k),a.lastInterval=b}else c=h.velocity,e=h.velocityX,f=h.velocityY,g=h.direction;b.velocity=c,b.velocityX=e,b.velocityY=f,b.direction=g}function E(a){for(var b=[],c=0;c<a.pointers.length;)b[c]={clientX:lb(a.pointers[c].clientX),clientY:lb(a.pointers[c].clientY)},c++;return{timeStamp:nb(),pointers:b,center:F(b),deltaX:a.deltaX,deltaY:a.deltaY}}function F(a){var b=a.length;if(1===b)return{x:lb(a[0].clientX),y:lb(a[0].clientY)};for(var c=0,d=0,e=0;b>e;)c+=a[e].clientX,d+=a[e].clientY,e++;return{x:lb(c/b),y:lb(d/b)}}function G(a,b,c){return{x:b/a||0,y:c/a||0}}function H(a,b){return a===b?Cb:mb(a)>=mb(b)?a>0?Db:Eb:b>0?Fb:Gb}function I(a,b,c){c||(c=Kb);var d=b[c[0]]-a[c[0]],e=b[c[1]]-a[c[1]];return Math.sqrt(d*d+e*e)}function J(a,b,c){c||(c=Kb);var d=b[c[0]]-a[c[0]],e=b[c[1]]-a[c[1]];return 180*Math.atan2(e,d)/Math.PI}function K(a,b){return J(b[1],b[0],Lb)-J(a[1],a[0],Lb)}function L(a,b){return I(b[0],b[1],Lb)/I(a[0],a[1],Lb)}function M(){this.evEl=Nb,this.evWin=Ob,this.allow=!0,this.pressed=!1,y.apply(this,arguments)}function N(){this.evEl=Rb,this.evWin=Sb,y.apply(this,arguments),this.store=this.manager.session.pointerEvents=[]}function O(){this.evTarget=Ub,this.evWin=Vb,this.started=!1,y.apply(this,arguments)}function P(a,b){var c=t(a.touches),d=t(a.changedTouches);return b&(Ab|Bb)&&(c=u(c.concat(d),"identifier",!0)),[c,d]}function Q(){this.evTarget=Xb,this.targetIds={},y.apply(this,arguments)}function R(a,b){var c=t(a.touches),d=this.targetIds;if(b&(yb|zb)&&1===c.length)return d[c[0].identifier]=!0,[c,c];var e,f,g=t(a.changedTouches),h=[],i=this.target;if(f=c.filter(function(a){return p(a.target,i)}),b===yb)for(e=0;e<f.length;)d[f[e].identifier]=!0,e++;for(e=0;e<g.length;)d[g[e].identifier]&&h.push(g[e]),b&(Ab|Bb)&&delete d[g[e].identifier],e++;return h.length?[u(f.concat(h),"identifier",!0),h]:void 0}function S(){y.apply(this,arguments);var a=k(this.handler,this);this.touch=new Q(this.manager,a),this.mouse=new M(this.manager,a)}function T(a,b){this.manager=a,this.set(b)}function U(a){if(q(a,bc))return bc;var b=q(a,cc),c=q(a,dc);return b&&c?cc+" "+dc:b||c?b?cc:dc:q(a,ac)?ac:_b}function V(a){this.id=w(),this.manager=null,this.options=i(a||{},this.defaults),this.options.enable=m(this.options.enable,!0),this.state=ec,this.simultaneous={},this.requireFail=[]}function W(a){return a&jc?"cancel":a&hc?"end":a&gc?"move":a&fc?"start":""}function X(a){return a==Gb?"down":a==Fb?"up":a==Db?"left":a==Eb?"right":""}function Y(a,b){var c=b.manager;return c?c.get(a):a}function Z(){V.apply(this,arguments)}function $(){Z.apply(this,arguments),this.pX=null,this.pY=null}function _(){Z.apply(this,arguments)}function ab(){V.apply(this,arguments),this._timer=null,this._input=null}function bb(){Z.apply(this,arguments)}function cb(){Z.apply(this,arguments)}function db(){V.apply(this,arguments),this.pTime=!1,this.pCenter=!1,this._timer=null,this._input=null,this.count=0}function eb(a,b){return b=b||{},b.recognizers=m(b.recognizers,eb.defaults.preset),new fb(a,b)}function fb(a,b){b=b||{},this.options=i(b,eb.defaults),this.options.inputTarget=this.options.inputTarget||a,this.handlers={},this.session={},this.recognizers=[],this.element=a,this.input=z(this),this.touchAction=new T(this,this.options.touchAction),gb(this,!0),g(b.recognizers,function(a){var b=this.add(new a[0](a[1]));a[2]&&b.recognizeWith(a[2]),a[3]&&b.requireFailure(a[3])},this)}function gb(a,b){var c=a.element;g(a.options.cssProps,function(a,d){c.style[v(c.style,d)]=b?a:""})}function hb(a,c){var d=b.createEvent("Event");d.initEvent(a,!0,!0),d.gesture=c,c.target.dispatchEvent(d)}var ib=["","webkit","moz","MS","ms","o"],jb=b.createElement("div"),kb="function",lb=Math.round,mb=Math.abs,nb=Date.now,ob=1,pb=/mobile|tablet|ip(ad|hone|od)|android/i,qb="ontouchstart"in a,rb=v(a,"PointerEvent")!==d,sb=qb&&pb.test(navigator.userAgent),tb="touch",ub="pen",vb="mouse",wb="kinect",xb=25,yb=1,zb=2,Ab=4,Bb=8,Cb=1,Db=2,Eb=4,Fb=8,Gb=16,Hb=Db|Eb,Ib=Fb|Gb,Jb=Hb|Ib,Kb=["x","y"],Lb=["clientX","clientY"];y.prototype={handler:function(){},init:function(){this.evEl&&n(this.element,this.evEl,this.domHandler),this.evTarget&&n(this.target,this.evTarget,this.domHandler),this.evWin&&n(x(this.element),this.evWin,this.domHandler)},destroy:function(){this.evEl&&o(this.element,this.evEl,this.domHandler),this.evTarget&&o(this.target,this.evTarget,this.domHandler),this.evWin&&o(x(this.element),this.evWin,this.domHandler)}};var Mb={mousedown:yb,mousemove:zb,mouseup:Ab},Nb="mousedown",Ob="mousemove mouseup";j(M,y,{handler:function(a){var b=Mb[a.type];b&yb&&0===a.button&&(this.pressed=!0),b&zb&&1!==a.which&&(b=Ab),this.pressed&&this.allow&&(b&Ab&&(this.pressed=!1),this.callback(this.manager,b,{pointers:[a],changedPointers:[a],pointerType:vb,srcEvent:a}))}});var Pb={pointerdown:yb,pointermove:zb,pointerup:Ab,pointercancel:Bb,pointerout:Bb},Qb={2:tb,3:ub,4:vb,5:wb},Rb="pointerdown",Sb="pointermove pointerup pointercancel";a.MSPointerEvent&&(Rb="MSPointerDown",Sb="MSPointerMove MSPointerUp MSPointerCancel"),j(N,y,{handler:function(a){var b=this.store,c=!1,d=a.type.toLowerCase().replace("ms",""),e=Pb[d],f=Qb[a.pointerType]||a.pointerType,g=f==tb,h=s(b,a.pointerId,"pointerId");e&yb&&(0===a.button||g)?0>h&&(b.push(a),h=b.length-1):e&(Ab|Bb)&&(c=!0),0>h||(b[h]=a,this.callback(this.manager,e,{pointers:b,changedPointers:[a],pointerType:f,srcEvent:a}),c&&b.splice(h,1))}});var Tb={touchstart:yb,touchmove:zb,touchend:Ab,touchcancel:Bb},Ub="touchstart",Vb="touchstart touchmove touchend touchcancel";j(O,y,{handler:function(a){var b=Tb[a.type];if(b===yb&&(this.started=!0),this.started){var c=P.call(this,a,b);b&(Ab|Bb)&&c[0].length-c[1].length===0&&(this.started=!1),this.callback(this.manager,b,{pointers:c[0],changedPointers:c[1],pointerType:tb,srcEvent:a})}}});var Wb={touchstart:yb,touchmove:zb,touchend:Ab,touchcancel:Bb},Xb="touchstart touchmove touchend touchcancel";j(Q,y,{handler:function(a){var b=Wb[a.type],c=R.call(this,a,b);c&&this.callback(this.manager,b,{pointers:c[0],changedPointers:c[1],pointerType:tb,srcEvent:a})}}),j(S,y,{handler:function(a,b,c){var d=c.pointerType==tb,e=c.pointerType==vb;if(d)this.mouse.allow=!1;else if(e&&!this.mouse.allow)return;b&(Ab|Bb)&&(this.mouse.allow=!0),this.callback(a,b,c)},destroy:function(){this.touch.destroy(),this.mouse.destroy()}});var Yb=v(jb.style,"touchAction"),Zb=Yb!==d,$b="compute",_b="auto",ac="manipulation",bc="none",cc="pan-x",dc="pan-y";T.prototype={set:function(a){a==$b&&(a=this.compute()),Zb&&(this.manager.element.style[Yb]=a),this.actions=a.toLowerCase().trim()},update:function(){this.set(this.manager.options.touchAction)},compute:function(){var a=[];return g(this.manager.recognizers,function(b){l(b.options.enable,[b])&&(a=a.concat(b.getTouchAction()))}),U(a.join(" "))},preventDefaults:function(a){if(!Zb){var b=a.srcEvent,c=a.offsetDirection;if(this.manager.session.prevented)return void b.preventDefault();var d=this.actions,e=q(d,bc),f=q(d,dc),g=q(d,cc);return e||f&&c&Hb||g&&c&Ib?this.preventSrc(b):void 0}},preventSrc:function(a){this.manager.session.prevented=!0,a.preventDefault()}};var ec=1,fc=2,gc=4,hc=8,ic=hc,jc=16,kc=32;V.prototype={defaults:{},set:function(a){return h(this.options,a),this.manager&&this.manager.touchAction.update(),this},recognizeWith:function(a){if(f(a,"recognizeWith",this))return this;var b=this.simultaneous;return a=Y(a,this),b[a.id]||(b[a.id]=a,a.recognizeWith(this)),this},dropRecognizeWith:function(a){return f(a,"dropRecognizeWith",this)?this:(a=Y(a,this),delete this.simultaneous[a.id],this)},requireFailure:function(a){if(f(a,"requireFailure",this))return this;var b=this.requireFail;return a=Y(a,this),-1===s(b,a)&&(b.push(a),a.requireFailure(this)),this},dropRequireFailure:function(a){if(f(a,"dropRequireFailure",this))return this;a=Y(a,this);var b=s(this.requireFail,a);return b>-1&&this.requireFail.splice(b,1),this},hasRequireFailures:function(){return this.requireFail.length>0},canRecognizeWith:function(a){return!!this.simultaneous[a.id]},emit:function(a){function b(b){c.manager.emit(c.options.event+(b?W(d):""),a)}var c=this,d=this.state;hc>d&&b(!0),b(),d>=hc&&b(!0)},tryEmit:function(a){return this.canEmit()?this.emit(a):void(this.state=kc)},canEmit:function(){for(var a=0;a<this.requireFail.length;){if(!(this.requireFail[a].state&(kc|ec)))return!1;a++}return!0},recognize:function(a){var b=h({},a);return l(this.options.enable,[this,b])?(this.state&(ic|jc|kc)&&(this.state=ec),this.state=this.process(b),void(this.state&(fc|gc|hc|jc)&&this.tryEmit(b))):(this.reset(),void(this.state=kc))},process:function(){},getTouchAction:function(){},reset:function(){}},j(Z,V,{defaults:{pointers:1},attrTest:function(a){var b=this.options.pointers;return 0===b||a.pointers.length===b},process:function(a){var b=this.state,c=a.eventType,d=b&(fc|gc),e=this.attrTest(a);return d&&(c&Bb||!e)?b|jc:d||e?c&Ab?b|hc:b&fc?b|gc:fc:kc}}),j($,Z,{defaults:{event:"pan",threshold:10,pointers:1,direction:Jb},getTouchAction:function(){var a=this.options.direction,b=[];return a&Hb&&b.push(dc),a&Ib&&b.push(cc),b},directionTest:function(a){var b=this.options,c=!0,d=a.distance,e=a.direction,f=a.deltaX,g=a.deltaY;return e&b.direction||(b.direction&Hb?(e=0===f?Cb:0>f?Db:Eb,c=f!=this.pX,d=Math.abs(a.deltaX)):(e=0===g?Cb:0>g?Fb:Gb,c=g!=this.pY,d=Math.abs(a.deltaY))),a.direction=e,c&&d>b.threshold&&e&b.direction},attrTest:function(a){return Z.prototype.attrTest.call(this,a)&&(this.state&fc||!(this.state&fc)&&this.directionTest(a))},emit:function(a){this.pX=a.deltaX,this.pY=a.deltaY;var b=X(a.direction);b&&this.manager.emit(this.options.event+b,a),this._super.emit.call(this,a)}}),j(_,Z,{defaults:{event:"pinch",threshold:0,pointers:2},getTouchAction:function(){return[bc]},attrTest:function(a){return this._super.attrTest.call(this,a)&&(Math.abs(a.scale-1)>this.options.threshold||this.state&fc)},emit:function(a){if(this._super.emit.call(this,a),1!==a.scale){var b=a.scale<1?"in":"out";this.manager.emit(this.options.event+b,a)}}}),j(ab,V,{defaults:{event:"press",pointers:1,time:500,threshold:5},getTouchAction:function(){return[_b]},process:function(a){var b=this.options,c=a.pointers.length===b.pointers,d=a.distance<b.threshold,f=a.deltaTime>b.time;if(this._input=a,!d||!c||a.eventType&(Ab|Bb)&&!f)this.reset();else if(a.eventType&yb)this.reset(),this._timer=e(function(){this.state=ic,this.tryEmit()},b.time,this);else if(a.eventType&Ab)return ic;return kc},reset:function(){clearTimeout(this._timer)},emit:function(a){this.state===ic&&(a&&a.eventType&Ab?this.manager.emit(this.options.event+"up",a):(this._input.timeStamp=nb(),this.manager.emit(this.options.event,this._input)))}}),j(bb,Z,{defaults:{event:"rotate",threshold:0,pointers:2},getTouchAction:function(){return[bc]},attrTest:function(a){return this._super.attrTest.call(this,a)&&(Math.abs(a.rotation)>this.options.threshold||this.state&fc)}}),j(cb,Z,{defaults:{event:"swipe",threshold:10,velocity:.65,direction:Hb|Ib,pointers:1},getTouchAction:function(){return $.prototype.getTouchAction.call(this)},attrTest:function(a){var b,c=this.options.direction;return c&(Hb|Ib)?b=a.velocity:c&Hb?b=a.velocityX:c&Ib&&(b=a.velocityY),this._super.attrTest.call(this,a)&&c&a.direction&&a.distance>this.options.threshold&&mb(b)>this.options.velocity&&a.eventType&Ab},emit:function(a){var b=X(a.direction);b&&this.manager.emit(this.options.event+b,a),this.manager.emit(this.options.event,a)}}),j(db,V,{defaults:{event:"tap",pointers:1,taps:1,interval:300,time:250,threshold:2,posThreshold:10},getTouchAction:function(){return[ac]},process:function(a){var b=this.options,c=a.pointers.length===b.pointers,d=a.distance<b.threshold,f=a.deltaTime<b.time;if(this.reset(),a.eventType&yb&&0===this.count)return this.failTimeout();if(d&&f&&c){if(a.eventType!=Ab)return this.failTimeout();var g=this.pTime?a.timeStamp-this.pTime<b.interval:!0,h=!this.pCenter||I(this.pCenter,a.center)<b.posThreshold;this.pTime=a.timeStamp,this.pCenter=a.center,h&&g?this.count+=1:this.count=1,this._input=a;var i=this.count%b.taps;if(0===i)return this.hasRequireFailures()?(this._timer=e(function(){this.state=ic,this.tryEmit()},b.interval,this),fc):ic}return kc},failTimeout:function(){return this._timer=e(function(){this.state=kc},this.options.interval,this),kc},reset:function(){clearTimeout(this._timer)},emit:function(){this.state==ic&&(this._input.tapCount=this.count,this.manager.emit(this.options.event,this._input))}}),eb.VERSION="2.0.4",eb.defaults={domEvents:!1,touchAction:$b,enable:!0,inputTarget:null,inputClass:null,preset:[[bb,{enable:!1}],[_,{enable:!1},["rotate"]],[cb,{direction:Hb}],[$,{direction:Hb},["swipe"]],[db],[db,{event:"doubletap",taps:2},["tap"]],[ab]],cssProps:{userSelect:"none",touchSelect:"none",touchCallout:"none",contentZooming:"none",userDrag:"none",tapHighlightColor:"rgba(0,0,0,0)"}};var lc=1,mc=2;fb.prototype={set:function(a){return h(this.options,a),a.touchAction&&this.touchAction.update(),a.inputTarget&&(this.input.destroy(),this.input.target=a.inputTarget,this.input.init()),this},stop:function(a){this.session.stopped=a?mc:lc},recognize:function(a){var b=this.session;if(!b.stopped){this.touchAction.preventDefaults(a);var c,d=this.recognizers,e=b.curRecognizer;(!e||e&&e.state&ic)&&(e=b.curRecognizer=null);for(var f=0;f<d.length;)c=d[f],b.stopped===mc||e&&c!=e&&!c.canRecognizeWith(e)?c.reset():c.recognize(a),!e&&c.state&(fc|gc|hc)&&(e=b.curRecognizer=c),f++}},get:function(a){if(a instanceof V)return a;for(var b=this.recognizers,c=0;c<b.length;c++)if(b[c].options.event==a)return b[c];return null},add:function(a){if(f(a,"add",this))return this;var b=this.get(a.options.event);return b&&this.remove(b),this.recognizers.push(a),a.manager=this,this.touchAction.update(),a},remove:function(a){if(f(a,"remove",this))return this;var b=this.recognizers;return a=this.get(a),b.splice(s(b,a),1),this.touchAction.update(),this},on:function(a,b){var c=this.handlers;return g(r(a),function(a){c[a]=c[a]||[],c[a].push(b)}),this},off:function(a,b){var c=this.handlers;return g(r(a),function(a){b?c[a].splice(s(c[a],b),1):delete c[a]}),this},emit:function(a,b){this.options.domEvents&&hb(a,b);var c=this.handlers[a]&&this.handlers[a].slice();if(c&&c.length){b.type=a,b.preventDefault=function(){b.srcEvent.preventDefault()};for(var d=0;d<c.length;)c[d](b),d++}},destroy:function(){this.element&&gb(this,!1),this.handlers={},this.session={},this.input.destroy(),this.element=null}},h(eb,{INPUT_START:yb,INPUT_MOVE:zb,INPUT_END:Ab,INPUT_CANCEL:Bb,STATE_POSSIBLE:ec,STATE_BEGAN:fc,STATE_CHANGED:gc,STATE_ENDED:hc,STATE_RECOGNIZED:ic,STATE_CANCELLED:jc,STATE_FAILED:kc,DIRECTION_NONE:Cb,DIRECTION_LEFT:Db,DIRECTION_RIGHT:Eb,DIRECTION_UP:Fb,DIRECTION_DOWN:Gb,DIRECTION_HORIZONTAL:Hb,DIRECTION_VERTICAL:Ib,DIRECTION_ALL:Jb,Manager:fb,Input:y,TouchAction:T,TouchInput:Q,MouseInput:M,PointerEventInput:N,TouchMouseInput:S,SingleTouchInput:O,Recognizer:V,AttrRecognizer:Z,Tap:db,Pan:$,Swipe:cb,Pinch:_,Rotate:bb,Press:ab,on:n,off:o,each:g,merge:i,extend:h,inherit:j,bindFn:k,prefixed:v}),typeof define==kb&&define.amd?define(function(){return eb}):"undefined"!=typeof module&&module.exports?module.exports=eb:a[c]=eb}(window,document,"Hammer");
//# sourceMappingURL=hammer.min.map
$ui.themeDark = {
	backgroundImageColor: '#D94646',
	inHeadUnit: true,
	chart: { // Not in CSS because charts are <canvas>
		color: '#747474', //#F0F0F0
		color_OK: '#D94646',//#FAD60A
		color_GOOD: '#D94646',//#FDBF2F
		color_GREAT: '#D94646', //#A3D525
		color_RANDOM1: '#D94646', //#97BBCD
	},
	variables: [
		{
			name: '@brand-color',
			value: '#D94646'
		},
		{
			name: '@highlight-text-color',
			value: '#FFFFFF'
		},
		{
			name: '@foreground-color',
			value: '#FFFFFF'
		},
		{
			name: '@border-color',
			value: '#FFFFFF'
		},
		{
			name: '@background-color',
			value: '#000000'
		},
		{
			name: '@dark-color',
			value: '#747474'
		},
		{
			name: '@profile-wedge-color',
			value: '#D94646'// #FDBF2F
		},
		{
			name: '@green-color',
			value: '#779933'
		}
	],
	classList: [
		{
			className: '.theme-border-color',
			properties: [
				{
					name: 'border-color',
					value: '@border-color !important'
				}
			]
		},
		{
			className: '.theme-brand-border-color',
			properties: [
				{
					name: 'border-color',
					value: '@brand-color !important'
				}
			]
		},
		{
			className: '.theme-tile-border-color',
			properties: [
				{
					name: 'border-color',
					value: '@brand-color !important'
				}
			]
		},
		{
			className: '.theme-dark-border-color',
			properties: [
				{
					name: 'border-color',
					value: '@dark-color !important'
				}
			]
		},
		{
			className: '.theme-text-color',
			properties: [
				{
					name: 'color',
					value: '@foreground-color'
				}
			]
		},
		{
			className: '.theme-dark-text-color',
			properties: [
				{
					name: 'color',
					value: '@dark-color'
				}
			]
		},
		{
			className: '.theme-highlight-text-color',
			properties: [
				{
					name: 'color',
					value: '@highlight-text-color'
				}
			]
		},
		{
			className: '.theme-brand-text-color',
			properties: [
				{
					name: 'color',
					value: '@brand-color'
				}
			]
		},
		{
			className: '.theme-hint-text-color',
			properties: [
				{
					name: 'color',
					value: '#999999'
				}
			]
		},
		{
			className: '.theme-warning-text-color',
			properties: [
				{
					name: 'color',
					value: 'red'
				}
			]
		},
		{
			className: '.theme-screen-background-color',
			properties: [
				{
					name: 'background-color',
					value: '@background-color'
				}
			]
		},
		{
			className: '.theme-brand-background-color',
			properties: [
				{
					name: 'background-color',
					value: '@brand-color'
				}
			]
		},
		{
			className: '.theme-light-background-color',
			properties: [
				{
					name: 'background-color',
					value: '@foreground-color'
				}
			]
		},
		{
			className: '.theme-dark-background-color',
			properties: [
				{
					name: 'background-color',
					value: '@dark-color'
				}
			]
		},
		/****************  Call Button ******************/
		{
			className: '.theme-call-button',
			properties: [
				{
					name: 'background-color',
					value: '@green-color'
				}
			]
		},
		/****************  Generic List Items ******************/
		{
			className: '.theme-generic-list-accent-color',
			properties: [
				{
					name: 'color',
					value: '@brand-color'
				}
			]
		},
		/****************  Segmented Control ******************/
		{
			className: '.theme-segmented-control',
			properties: [
				{
					name: 'border-color',
					value: '@foreground-color'
				},
				{
					name: 'background-color',
					value: '@background-color'
				},
				{
					name: 'color',
					value: '@foreground-color'
				}
			]
		},
		/****************  Posts ******************/
		{
			className: '.theme-post-control',
			properties: [
				{
					name: 'color',
					value: '#D3D3D3'
				},
				{
					name: 'background-color',
					value: '@background-color'
				}
			]
		},
		/****************  Profile ******************/
		{
			className: '.theme-profile-vehicle-background-color',
			properties: [
				{
					name: 'background-color',
					value: '@background-color' // Light theme should be same as border color
				}
			]
		},
		{
			className: '.theme-profile-wedge-background-color',
			properties: [
				{
					name: 'background-color',
					value: '@profile-wedge-color'
				}
			]
		},
		{
			className: '.theme-profile-rank',
			properties: [
				{
					name: 'background-color',
					value: '@profile-wedge-color'
				},
				{
					name: 'color',
					value: '@highlight-text-color'
				}
			]
		},
		{
			className: '.theme-profile-rank-text-color',
			properties: [
				{
					name: 'color',
					value: '@highlight-text-color' // Light theme should be @dark-color
				}
			]
		},
		{
			className: '.theme-profile-label-text-color',
			properties: [
				{
					name: 'color',
					value: '@border-color' 
				}
			]
		},
		{
			className: '.theme-profile-stats',
			properties: [
				{
					name: 'border-color',
					value: '@brand-color' // Light theme should be @border-color
				},
				{
					name: 'background-color',
					value: '@background-color'
				}
			]
		},
		{
			className: '.theme-profile-number-color',
			properties: [
				{
					name: 'color',
					value: '@profile-wedge-color'
				}
			]
		},
		{
			className: '.theme-profile-avatar',
			properties: [
				{
					name: 'background-color',
					value: '@dark-color' // Light theme should be @border-color
				},
				{
					name: 'border-color',
					value: '@brand-color' // Light theme should be white
				},
				{
					name: 'box-shadow',
					value: 'inherit' // Light theme should be 0px 0px 7px #B6B6B6; 
				}
			]
		},
		/****************  On Off Switch ******************/
		{
			className: '.theme-on-off-switch',
			properties: [
				{
					name: 'background-image',
					value: 'linear-gradient(to top, @dark-color, #B9B9B9 80%);' 
				}
			]
		},
		{
			className: '.theme-on-off-switch-inner-ring',
			properties: [
				{
					name: 'border-color',
					value: '@background-color' 
				},
				{
					name: 'background-image',
					value: 'linear-gradient(to top,#B9B9B9,#5c5c5c 25%);' 
				}
			]
		},
		{
			className: '.theme-on-off-switch-inner-ring-on',
			properties: [
				{
					name: 'border-color',
					value: '@background-color' 
				},
				{
					name: 'background-image',
					value: 'linear-gradient(to bottom, #B9B9B9, #5c5c5c 25%);' 
				}
			]
		},
		{
			className: '.theme-on-off-switch-indicator-on',
			properties: [
				{
					name: 'background-color',
					value: '@green-color'
				}
			]
		},
		{
			className: '.theme-on-off-switch',
			properties: [
				{
					name: 'background-image',
					value: 'linear-gradient(to top,#747474, #B9B9B9 50%);' 
				}
			]
		},
		/****************  Circle Menu ******************/
		{
			className: '.theme-circle-menu-indicator',
			properties: [
				{
					name: 'background-color',
					value: '@dark-color' 
				}
			]
		},
		{
			className: '.theme-circle-menu-indicator-selected',
			properties: [
				{
					name: 'background-color',
					value: '@foreground-color' 
				}
			]
		}
	]
};

$ui.themeLight = {
	backgroundImageColor: '#D94646',
	inHeadUnit: true,
	chart: { // Not in CSS because charts are <canvas>
		color: '#747474', //#F0F0F0
		color_OK: '#D94646',//#FAD60A
		color_GOOD: '#D94646',//#FDBF2F
		color_GREAT: '#D94646', //#A3D525
		color_RANDOM1: '#D94646', //#97BBCD
	},
	variables: [
		{
			name: '@brand-color',
			value: '#D94646'
		},
		{
			name: '@highlight-text-color',
			value: '#FFFFFF'
		},
		{
			name: '@foreground-color',
			value: '#FFFFFF'
		},
		{
			name: '@border-color',
			value: '#FFFFFF'
		},
		{
			name: '@background-color',
			value: '#000000'
		},
		{
			name: '@dark-color',
			value: '#747474'
		},
		{
			name: '@profile-wedge-color',
			value: '#D94646'// #FDBF2F
		}
	],
	classList: [
		{
			className: '.theme-border-color',
			properties: [
				{
					name: 'border-color',
					value: '@border-color !important'
				}
			]
		},
		{
			className: '.theme-brand-border-color',
			properties: [
				{
					name: 'border-color',
					value: '@brand-color !important'
				}
			]
		},
		{
			className: '.theme-tile-border-color',
			properties: [
				{
					name: 'border-color',
					value: '@brand-color !important'
				}
			]
		},
		{
			className: '.theme-dark-border-color',
			properties: [
				{
					name: 'border-color',
					value: '@dark-color !important'
				}
			]
		},
		{
			className: '.theme-text-color',
			properties: [
				{
					name: 'color',
					value: '@foreground-color'
				}
			]
		},
		{
			className: '.theme-dark-text-color',
			properties: [
				{
					name: 'color',
					value: '@dark-color'
				}
			]
		},
		{
			className: '.theme-highlight-text-color',
			properties: [
				{
					name: 'color',
					value: '@highlight-text-color'
				}
			]
		},
		{
			className: '.theme-brand-text-color',
			properties: [
				{
					name: 'color',
					value: '@brand-color'
				}
			]
		},
		{
			className: '.theme-screen-background-color',
			properties: [
				{
					name: 'background-color',
					value: '@background-color'
				}
			]
		},
		{
			className: '.theme-brand-background-color',
			properties: [
				{
					name: 'background-color',
					value: '@brand-color'
				}
			]
		},
		{
			className: '.theme-light-background-color',
			properties: [
				{
					name: 'background-color',
					value: '@foreground-color'
				}
			]
		},
		{
			className: '.theme-dark-background-color',
			properties: [
				{
					name: 'background-color',
					value: '@dark-color'
				}
			]
		},
		/****************  Generic List Items ******************/
		{
			className: '.theme-generic-list-accent-color',
			properties: [
				{
					name: 'color',
					value: '@brand-color'
				}
			]
		},
		/****************  Segmented Control ******************/
		{
			className: '.theme-segmented-control',
			properties: [
				{
					name: 'border-color',
					value: '@foreground-color'
				},
				{
					name: 'background-color',
					value: '@background-color'
				},
				{
					name: 'color',
					value: '@foreground-color'
				}
			]
		},
		/****************  Posts ******************/
		{
			className: '.theme-post-control',
			properties: [
				{
					name: 'color',
					value: '#D3D3D3'
				},
				{
					name: 'background-color',
					value: '@background-color'
				}
			]
		},
		/****************  Profile ******************/
		{
			className: '.theme-profile-vehicle-background-color',
			properties: [
				{
					name: 'background-color',
					value: '@background-color' // Light theme should be same as border color
				}
			]
		},
		{
			className: '.theme-profile-wedge-background-color',
			properties: [
				{
					name: 'background-color',
					value: '@profile-wedge-color'
				}
			]
		},
		{
			className: '.theme-profile-rank',
			properties: [
				{
					name: 'background-color',
					value: '@profile-wedge-color'
				},
				{
					name: 'color',
					value: '@highlight-text-color'
				}
			]
		},
		{
			className: '.theme-profile-rank-text-color',
			properties: [
				{
					name: 'color',
					value: '@highlight-text-color' // Light theme should be @dark-color
				}
			]
		},
		{
			className: '.theme-profile-label-text-color',
			properties: [
				{
					name: 'color',
					value: '@border-color' 
				}
			]
		},
		{
			className: '.theme-profile-stats',
			properties: [
				{
					name: 'border-color',
					value: '@brand-color' // Light theme should be @border-color
				},
				{
					name: 'background-color',
					value: '@background-color'
				}
			]
		},
		{
			className: '.theme-profile-number-color',
			properties: [
				{
					name: 'color',
					value: '@profile-wedge-color'
				}
			]
		},
		{
			className: '.theme-profile-avatar',
			properties: [
				{
					name: 'background-color',
					value: '@dark-color' // Light theme should be @border-color
				},
				{
					name: 'border-color',
					value: '@brand-color' // Light theme should be white
				},
				{
					name: 'box-shadow',
					value: 'inherit' // Light theme should be 0px 0px 7px #B6B6B6; 
				}
			]
		}
	]
};

/**
 * The CoreTile object represents the abstract base class for all tile controls. <br><br>
 * <b>NOTE: This base class should never be declared in a screen's declaration. It will not actually render and return a tile. It is simply an abstract base class.</b>
 * @namespace CoreTile
 * @memberof $ui
 * @extends $ui.CoreComponent
 */
function $ui_CoreTile(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	if (object) {
		$ui.addClass(object.dom,'ui-tile theme-text-color theme-tile-border-color theme-screen-background-color');
		object._contentShowing = false;
		/** 
		 * The size of a tile. This property should be set by the internal code of a derivative Tile class.
		 * @name _size
		 * @memberof $ui.CoreTile
		 * @protected
		 * @type {$ui.TileSize}
		 */
		if (object._size && (object._size != $ui.TileSize.STANDARD)) {
			$ui.addClass(object.dom, object._size);
		}
		object._protected._size = object._size;
		Object.defineProperty(object, '_size', {
			get: function() {return this._protected._size;},
			set: function() {
				console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','_size'));			
			},
			configurable: false}
		);
		
		// Create our loading area
		object.dom.loadingDiv = document.createElement('div');
		$ui.addClass(object.dom.loadingDiv, 'loading');
		object.dom.appendChild(object.dom.loadingDiv);
		object.dom.spinner = new $ui_Spinner({component: $ui.Spinner, size: $ui.Spinner.SMALL},screen);
		object.dom.loadingDiv.appendChild(object.dom.spinner);
		
		// Create our content area
		object.dom.contentDiv = document.createElement('div');
		$ui.addClass(object.dom.contentDiv, 'content');
		object.dom.appendChild(object.dom.contentDiv);	
		
		/** 
		 * This function is to be called when a tile needs to be toggled between the loading state and content state. 
		 * @function showContent
		 * @memberof $ui.CoreTile
		 * @param {boolean} value - The value parameter represents the boolean state of visibility of the tile content.
		 */
		object.showContent = function(value) {
			if (value == this._contentShowing) return;
			if (value) {
				this.dom.loadingDiv.style.display = 'none';
				this.dom.contentDiv.style.display = 'inherit';
			} else {
				this.dom.loadingDiv.style.display = 'inline';
				this.dom.contentDiv.style.display = 'none';
			}
			this._contentShowing = value;
		}.$bind(object);
	}
}
/**
 * The CoreTileDonutChart is the abstract base class of any donut chart tiles. This base class should never be declared in a screen's declaration.
 * <b>NOTE: It will not actually render and return a tile. It is simply an abstract base class.</b>
 * @namespace CoreTileDonutChart
 * @memberof $ui
 * @extends $ui.CoreTile
 */
function $ui_CoreTileDonutChart(object, screen) {
	// Set our default animation
	if (object.animated == undefined) {
		object.animated = true;
	}
	$ui_CoreTile.call(this, object, screen);
	if (object) {
		$ui.addClass(object.dom,'ui-tile-donut-chart');

		// Create our chart area
		object.dom.chartDiv = document.createElement('div');
		$ui.addClass(object.dom.chartDiv, 'chart'); // Base class styling
		object.dom.contentDiv.appendChild(object.dom.chartDiv);
		
		// Create our canvas area
		object.dom.canvas = document.createElement('canvas');
		object.dom.chartDiv.appendChild(object.dom.canvas);

		// Create our chart
		object.chart = new Chart(object.dom.canvas.getContext('2d'));
		
		/** 
		 * This function takes a value parameter which is an array of data point objects. These data point objects defined a section of the chart and consist of two properties representing value and color
		 * @function _setData
		 * @memberof $ui.CoreTileDonutChart
		 * @param {object[]} value - Array of data points. <br/><b>Example:</b>
		 * <pre>
		 * [
		 *   {
		 *      value: 10,
		 *      color: '#000000',
		 *   },
		 *   {
		 *      value: 90,
		 *      color: '#FEFEFE',
		 *   }
		 * ]
		 * </pre>
		 * @protected
		 */
		object._setData = function(data) {
			this._protected.data = data;
			this.chart.Doughnut(data,{showTooltips: false, animation: this.animated, segmentStrokeColor : "transparent",});
		}.$bind(object);
		
		// Create the caption area
		object.dom.caption = document.createElement('div');
		$ui.addClass(object.dom.caption,'caption');
		object.dom.contentDiv.appendChild(object.dom.caption);
		
		/** 
		 * This function will set the caption of the Donut chart.
		 * @function _setCaption
		 * @memberof $ui.CoreTileDonutChart
		 * @param {string} value - Text for the caption
		 * @protected
		 */
		object._setCaption = function(value) {
			this.dom.caption.innerHTML = value;
		}.$bind(object);
		
		// Create the accent area
		object.dom.accent = document.createElement('div');
		$ui.addClass(object.dom.accent,'accent');
		object.dom.contentDiv.appendChild(object.dom.accent);
		object.dom.accent.style.color = $ui.theme.chart.color;
		
		/** 
		 * This function will set the accent text of the Donut chart
		 * @function _setAccent
		 * @memberof $ui.CoreTileDonutChart
		 * @param {string} value - Text for the accent
		 * @protected
		 */
		object._setAccent = function(value) {
			if (value == undefined) {
				$ui.removeClass(this.dom.contentDiv, 'has-accent');
				this.dom.accent.textContent = '';
				this.accent = value;
				return;
			}
			this.accent = value;
			$ui.addClass(this.dom.contentDiv, 'has-accent');
			this.dom.accent.textContent = value;
		}.$bind(object);
	}
}
/**
 * The CoreTileGauge is the abstract base class of any gauge chart tiles.
 * <b>NOTE: It will not actually render and return a tile. It is simply an abstract base class.</b><br><br>
 * <b>Sample Declaration:</b>
 * <pre>
 * {
 *    min: 0,
 *    max: 1.5,
 *    value: 1
 *}
 * </pre>
 * @namespace CoreTileGauge
 * @memberof $ui
 * @extends $ui.CoreTile
 * @property {number} min - This is the minimum numeric value that you want to display at the left hand side of the gauge
 * @property {number} max - This is the maximum numeric value that you want to display at the right hand side of the gauge
 * @property {number} value - The numeric value you want to display. This should be between min and max.
 */
function $ui_CoreTileGauge(object, screen) {
	if (object) object._size = undefined; // Always square
	$ui_CoreTile.call(this, object, screen);
	if (object) {
		$ui.addClass(object.dom,'ui-tile-gauge');

		// Create our title area
		object.dom.titleDiv = document.createElement('div');
		$ui.addClass(object.dom.titleDiv,'title');
		object.dom.contentDiv.appendChild(object.dom.titleDiv);
		
		/** 
		 * This function will set the title of the gauge chart.
		 * @function _setTitle
		 * @memberof $ui.CoreTileGauge
		 * @param {string} value - Value to be used as the title
		 * @protected
		 */
		object._setTitle = function(value) {
			if (value == undefined || value == null) value = '';
			object.dom.titleDiv.textContent = value;
		}.$bind(object);
		
		// Create our chart area
		object.dom.chartDiv = document.createElement('div');
		$ui.addClass(object.dom.chartDiv, 'chart'); // Base class styling
		object.dom.contentDiv.appendChild(object.dom.chartDiv);
		
		// Create our canvas area
		object.dom.canvas = document.createElement('canvas');
		object.dom.canvas.width = 200;
		object.dom.canvas.height = 200;
		$ui.addClass(object.dom.canvas,'graph-canvas');
		object.dom.chartDiv.appendChild(object.dom.canvas);

		// Add our bottom labels
		object.dom.labels = document.createElement('div');
		$ui.addClass(object.dom.labels, 'labels-area');
		object.dom.chartDiv.appendChild(object.dom.labels);
		
		// Min Label
		object.dom.minLabel = document.createElement('div');
		$ui.addClass(object.dom.minLabel, 'label');
		$ui.addClass(object.dom.minLabel, 'left');
		object.dom.labels.appendChild(object.dom.minLabel);
		
		// Max Label
		object.dom.maxLabel = document.createElement('div');
		$ui.addClass(object.dom.maxLabel, 'label');
		$ui.addClass(object.dom.maxLabel, 'right');
		object.dom.labels.appendChild(object.dom.maxLabel);
		
		// Accent Label
		object.dom.accentLabel = document.createElement('div');
		$ui.addClass(object.dom.accentLabel, 'label');
		$ui.addClass(object.dom.accentLabel, 'center');
		object.dom.labels.appendChild(object.dom.accentLabel);
		/** 
		 * This function will set the title of the gauge chart.
		 * @function _setAccent
		 * @memberof $ui.CoreTileGauge
		 * @param {string} value - Value to use as the accent text
		 * @protected
		 */
		object._setAccent = function(value) {
			if (value == undefined || value == null) value = '';
			object.dom.accentLabel.textContent = value;
		}
		object._setAccent = object._setAccent.$bind(object);
		
		// Value Label
		object.dom.valueDiv = document.createElement('div');
		$ui.addClass(object.dom.valueDiv, 'value');
		object.dom.chartDiv.appendChild(object.dom.valueDiv);
		
		// Create our chart Context 
		var ctx = object.dom.canvas.getContext('2d');
		object.dom.ctx = ctx;
		object._width = object.dom.canvas.width;
		object._height = object.dom.canvas.height;
		
		// This will render our filled in area
		object._renderLoop = function() {
			if (this._degrees > this._newDegrees) {
				return;
			}
			requestAnimationFrame(this._renderLoop)
			
			//Angle in radians = angle in degrees * PI / 180
			var ctx = this.dom.ctx,
				radians = this._degrees * Math.PI / 180;
			
			//Clear the canvas every time a chart is drawn
			ctx.clearRect(0, 0, this._width, this._height);
		
			//Background 180 degree arc
			ctx.beginPath();
			ctx.strokeStyle = $ui.theme.chart.color;
			ctx.lineWidth = 40;
			ctx.arc(this._width/2, this._height/2, 80, 0 - 180*Math.PI/180, Math.PI/180, false); //you can see the arc now
			ctx.stroke();
			
			// Now render our value
			ctx.beginPath();
			ctx.strokeStyle = this._color;
			//The arc starts from the rightmost end. If we deduct 180 degrees from the angles
			//the arc will start from the leftmost end
			ctx.arc(this._width/2, this._height/2, 80, 0 - 180*Math.PI/180, radians - 180*Math.PI/180, false); 
			//you can see the arc now
			ctx.stroke();
			
			if (this._degrees <= this._newDegrees) {
				this._degrees = this._degrees + this._step;
			}
			
		}.$bind(object);
		
		// This function will populate the control with the current values and then render the control
		object._populateData = function() {
			// Correct any bad data
			if (this.min == undefined) this.min = 0;
			if (this.max == undefined) this.max = 100;
			if (this.value == undefined) this.value = this.min;
			if (this.value < this.min) this.value = this.min;
			
			// Set our labels
			this.dom.minLabel.textContent = this.min;
			this.dom.maxLabel.textContent = this.max;
			this.dom.valueDiv.textContent = this.value;
			
			var percent = ((this.value - this.min)/this.max);
			this._newDegrees = percent * 180;
			switch (true) {
				case (percent < 0.33):
					this._color = $ui.theme.chart.color_GREAT;
					this._step = 2;
					break;
				case (percent < 0.77):
					this._color = $ui.theme.chart.color_GOOD;
					this._step = 7;
					break;
				default:
					this._color = $ui.theme.chart.color_OK;
					this._step = 10;
					break;
			}
			//this._degrees = 0;
			this._degrees = this._newDegrees - this._step;// temporary to stop slow animation
			this._renderLoop();
		}.$bind(object);
	}
}
/**
 * The DockLayout object represents a layout that allows for a static content and also scrolling content. The DockLayout will size itself to all the available space provided by its parent control.
 * <br><br><b>Sample Declaration</b>
 * <pre>
 * {
 *    component: $ui.DockLayout,
 *    dock: [
 *        {
 *            component: $ui.SegmentedControl,
 *            options: ['one','two']
 *        }
 *    ],
 *    content: [
 *        {
 *            component: $ui.List
 *        }
 *    ]
 *}
 * </pre>
 * @namespace DockLayout
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {$ui.CoreComponent[]} dock - This array holds all of the component definitions for the docked content
 * @property {$ui.CoreComponent[]} content - This array holds all of the component definitions for the scrollable area of the dock layout
 * @property {$ui.DockLayout.DockLocation} [location=$ui.DockLayout.DockLocation.TOP] - This property allows you to set the location of the docked content.
 */
function $ui_DockLayout(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom,'ui-dock-layout');
	
	// Create our dock area
	object.dom.dock = document.createElement('div');
	$ui.addClass(object.dom.dock, 'dock');
	
	var i,
		control,
		controlDom;
	
	// Load our dock
	if (object.dock) {
		for (i = 0; i < object.dock.length; i++) {
			control = object.dock[i];
			controlDom = $ui.createControl(control, screen);
			if (controlDom) {
				object.dom.dock.appendChild(controlDom);
			}
		}
	}
	
	// Create our contents area
	object.dom.contentDiv = document.createElement('div');
	$ui.addClass(object.dom.contentDiv, 'contents');
	
	// Load our contents
	if (object.content) {
		for (i = 0; i < object.content.length; i++) {
			control = object.content[i];
			controlDom = $ui.createControl(control, screen);
			if (controlDom) {
				object.dom.contentDiv.appendChild(controlDom);
			}
		}
	}
	
	// Check our dock location
	if (object.location === $ui.DockLayout.DockLocation.BOTTOM) {
		object.dom.appendChild(object.dom.contentDiv);
		object.dom.appendChild(object.dom.dock)
	} else {
		object.dom.appendChild(object.dom.dock)
		object.dom.appendChild(object.dom.contentDiv);
	}
	
	return object.dom;
}
/**
 * The generic list item type is used with the {@link $ui.List} component. A List component will define the type of list item it wishes to display by setting the <b>style</b> property of the control. 
 * <br><br><b>Sample Declaration</b>
 * <pre>
 * {
 *   img: 'thumbnails/foo.png',
 *   title: 'This is my title',
 *   accent: '6 hours ago',
 *   caption: 'My summary description'
 *}
 * </pre>
 * @namespace GenericListItem
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {string} [img] - Represents the path to the image that will appear in the list item
 * @property {string} title - Represents the main title to display
 * @property {string} [accent] - Represents the accent text to go along with the title and caption
 * @property {string} [caption] - Represents the main text to show in the list item
 */
function $ui_GenericListItem(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom, 'ui-generic-list-item theme-text-color theme-screen-background-color theme-dark-border-color');
	
	if ($ui.theme.inHeadUnit == true) {
		$ui.addClass(object.dom, 'in-head-unit');
	}
	
	// Create the image
	object.dom.img = document.createElement('div');
	$ui.addClass(object.dom.img,'img');
	object.dom.appendChild(object.dom.img);
	
	// Details section
	object.dom.details = document.createElement('div');
	$ui.addClass(object.dom.details,'details');
	object.dom.appendChild(object.dom.details);
	
	// Title
	object.dom.titleArea = document.createElement('div');
	$ui.addClass(object.dom.titleArea,'title');
	object.dom.details.appendChild(object.dom.titleArea);

	// Caption
	object.dom.captionDiv = document.createElement('div');
	$ui.addClass(object.dom.captionDiv,'caption');
	object.dom.details.appendChild(object.dom.captionDiv);
	
	// Accent
	object.dom.accent = document.createElement('div');
	$ui.addClass(object.dom.accent,'accent theme-generic-list-accent-color');
	object.dom.details.appendChild(object.dom.accent);
	
	// Load the image
	object._loadImage = function() {
		if(this.img != undefined && this.img != null && this.img != '') {
			// Image Loader
			this._loader = new Image();
			this._loader.model = object;
			this._loader.onload = function() {
				this.model.dom.img.style.backgroundImage = 'url("'+ this.model.img + '")';
				this.model.dom.img.style.opacity = '1.0';
				this.model._loader = undefined;
			}
			this._loader.onerror = function() {
				this.model.dom.img.style.backgroundImage = '';
				this.model.dom.img.style.opacity = '1.0';
				this.model._loader = undefined;
			}
			this._loader.src = object.img;
		} else {
			this.dom.img.style.opacity = '1.0';
			this.dom.loader = undefined;
		}
	}.$bind(object);
	
	// img property
	object._loadImage();
	object._protected.img = object.img;
	Object.defineProperty(object, 'img', {
		get: function() {return this._protected.img;},
		set: function(value) {
			if (value == this._protected.img) return;
			this._protected.img = value;
			this._loadImage();
		},
		configurable: false}
	);
	
	// Caption property
	if (object.caption) {
		object.dom.captionDiv.textContent = object.caption;
	} else {
		$ui.addClass(object.dom, 'no-caption');
	}
	object._protected.caption = object.caption;
	Object.defineProperty(object, 'caption', {
		get: function() {return this._protected.caption;},
		set: function(value) {
			if (value == this._protected.caption) return;
			this._protected.caption = value;
			if (value == undefined) {
				$ui.addClass(this.dom, 'no-caption');
			} else {
				$ui.removeClass(this.dom, 'no-caption');
				this.dom.captionDiv.textContent = value;
			}
		},
		configurable: false}
	);
	
	// accent Property
	if(object.accent != undefined) {
		object.dom.accent.textContent = object.accent;
		$ui.addClass(object.dom, 'has-accent');
	} 
	object._protected.accent = object.accent;
	Object.defineProperty(object, 'accent', {
		get: function() {return this._protected.accent;},
		set: function(value) {
			if (value == this._protected.accent) return;
			this._protected.accent = value;
			if (value == undefined) {
				$ui.removeClass(this.dom, 'has-accent');
			} else {
				$ui.addClass(this.dom, 'has-accent');
			}
		},
		configurable: false}
	);
	
	// Title Property
	object.dom.titleArea.textContent = object.title;
	object._protected.title = object.title;
	Object.defineProperty(object, 'title', {
		get: function() {return this._protected.title;},
		set: function(value) {
			if (value == this._protected.title) return;
			this._protected.title = value;
			this.dom.titleArea.textContent = value;
		},
		configurable: false}
	);
	
	// Handle our touch events
	object.dom.ontouchstart = function() {
		$ui.removeClass(this, 'theme-screen-background-color');
		$ui.addClass(this, 'theme-brand-background-color');
		$ui.removeClass(this, 'theme-text-color');
		$ui.addClass(this, 'theme-highlight-text-color');
		// Update our accent text
		if (this.model.dom && this.model.dom.accent) {
			$ui.removeClass(this.model.dom.accent, 'theme-generic-list-accent-color');
		}
	}
	object.dom.ontouchend = function() {
		$ui.removeClass(this, 'theme-brand-background-color');
		$ui.addClass(this, 'theme-screen-background-color');
		$ui.removeClass(this, 'theme-highlight-text-color');
		$ui.addClass(this, 'theme-text-color');
		// Update our accent text
		if (this.model.dom && this.model.dom.accent) {
			$ui.addClass(this.model.dom.accent, 'theme-generic-list-accent-color');
		}
	}
	object.dom.ontouchcancel = object.dom.ontouchend;
	if (!$ui.isMobileDevice()) {
		object.dom.onmousedown = object.dom.ontouchstart;
		object.dom.onmouseup = object.dom.ontouchend;
		object.dom.onmouseleave = object.dom.ontouchend;
	}

	// Pass the onclick back to the list
	object.dom.addEventListener('click', function() {
		if (this.model.parent.onaction == undefined) return;
		var event = new ListEvent(this.model, $ui.GenericListItem.GenericListEvent.ONCLICK);
		this.model.parent._onaction(this.model, event);
		$ui.playTouchSound();
	},false);

	return object.dom;
}
/**
 * The Header object represents a screen separator with a caption.  This component can be useful when you wish to label different areas of the screen.  Headers can also be used as
 * an item in a {@link $ui.List} control<br><br>
 * <b>Sample Declaration</b><br>
 * <pre>
 * {
 *   component: $ui.Header,
 *   caption: 'My Lovely Header'
 * }
 * @namespace Header
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {string} [caption] - The caption to be displayed in the control
*/
function $ui_Header(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom,'ui-header theme-text-color theme-brand-border-color');
	if ($ui.theme.inHeadUnit == true) {
		$ui.addClass(object.dom, 'in-head-unit');
	}
	if (object.caption) {
		object.dom.textContent = object.caption;
	}
	
	return object.dom;
}
/**
 * The image list item type is used with the {@link $ui.List} component. A List component will define the type of list item it wishes to display by setting the <b>style</b> property of the control. 
 * <br><br><b>Sample Declaration</b>
 * <pre>
 * {
 *   img: 'thumbnails/foo.png',
 *   caption: 'My summary description'
 *}
 * </pre>
 * @namespace ImageListItem
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {string} img - Represents the path to the image that will appear in the list item
 * @property {string} [caption] - Represents the main text to show in the list item
 */
function $ui_ImageListItem(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom, 'ui-image-list-item');
	
	// Create the image
	object.dom.img = document.createElement('div');
	$ui.addClass(object.dom.img,'img');
	object.dom.appendChild(object.dom.img);
	
	if(object.img != undefined && object.img != null && object.img != '') {
		// Image Loader
		object._loader = new Image();
		object._loader.model = object;
		object._loader.onload = function() {
			this.model.dom.img.style.backgroundImage = 'url("'+ this.model.img + '")';
			this.model.dom.img.style.opacity = '1.0';
			this.model._loader = undefined;
		}
		object._loader.onerror = function() {
			this.model.dom.img.style.backgroundImage = '';
			this.model.dom.img.style.opacity = '1.0';
			this.model._loader = undefined;
		}
		object._loader.src = object.img;
	} else {
		object.dom.img.style.opacity = '1.0';
		object.dom.loader = undefined;
	}
	

	// Caption
	object.dom.captionDiv = document.createElement('div');
	$ui.addClass(object.dom.captionDiv,'caption theme-highlight-text-color');
	object.dom.appendChild(object.dom.captionDiv);
	if (object.caption) {
		object.dom.captionDiv.textContent = object.caption;
	} else {
		$ui.addClass(object.dom.captionDiv, 'no-caption');
	}

	// Pass the onclick back to the list
	object.dom.addEventListener('click', function() {
		if (this.model.parent.onaction == undefined) return;
		var event = new ListEvent(this.model, $ui.ImageListItem.ImageListEvent.ONCLICK);
		this.model.parent._onaction(this.model, event);
		$ui.playTouchSound();
	},false);

	return object.dom;
}
/**
 * An input can provide either single line or multi-line input with various different display options and interactions<br>
 * <b>Sample Declaration</b>
 * <pre>
 * {
 *     component: $ui.Input,
 *     hint: 'Password',
 *     password: true,
 *     onenterkey: function() {
 *        // Login
 *    }
 * }
 * @namespace Input
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {string} [text] - The text that is contained in the input
 * @property {string} [hint] - The to show up as background "hint" text to let the user know what to enter into the control
 * @property {number} [tabIndex] - Optionally set the tab index for this input
 * @property {$ui.Input.InputType} [inputType] - Optionally set the type of input for this field. By default it is text.
 * @property {boolean} [password=false] - Set this value to <b>true</b> if you wish to have a password mask on the control
 * @property {boolean} [warning=false] - This <b>read only</b> flag will be set to <b>true</b> if the control has a validation error.
 * @property {boolean} [multiLine=false] - Set this value to <b>true</b> if you wish the control to allow for multi-line input
 * @property {number} [minLinesToShow=1] - This optional property allows you to specify how many lines high a multiLine input should be by default. 
 * The minLinesToShow property is ignored if multiLine is not set to <b>true</b>. The property is also ignored if it is not greater than 1 which is the default.<br><br> 
 * The control will then show a minimum number of lines as specified, but will also grow as the user types in content that will extend that minimum number just like it regularly does with a multiLine input.
 * @property {number} [maxLinesToShow=1] - This optional property allows you to specify how many lines high a multiLine input should grow to. The maxLinesToShow property is ignored if multiLine is not set to <b>true</b>. The property is also ignored if it is not greater than 1 which is the default. The control will then grow to a maximum number of lines as specified.
 * @property {GenericEvent} [onenterkey] - This event will fire when the user presses the enter key on their keyboard
 * @property {GenericEvent} [onchange] - The onchange event will fire whenever the user types in the input box. <i>NOTE: It will not fire when the text property is changed programatically.</i>
 * @property {GenericEvent} [onfocus] - The onfocus event will fire whenever the input received the focus.
 * @property {GenericEvent} [onblur] - The onblur event will fire whenever the input box loses focus.
 * @property {GenericEvent} [onvalidate] - The onvalidate event will fire when the <b>validate()</b> function is called. If you wish to have the validation fail, return <b>false</b> from your function. When validate() is called it will perform internal validation based on the <b>inputType</b> and also call the onvalidate function.  If either returns false the input will go into its warning state 
 */
function $ui_Input(object, screen){
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom, 'ui-input');
	object.dom.style.borderColor = $ui.theme.borderColor;
	
	if ($ui.isApple == true) {
		$ui.addClass(object.dom, 'iOS');
	}
	
	if ($ui.theme.inHeadUnit == true) {
		$ui.addClass(object.dom, 'in-head-unit');
	}
	
	// inputType property
	object._protected.inputType = object.inputType;
	Object.defineProperty(object, 'inputType', {
		get: function() {return this._protected.inputType;},
		set: function() {
			console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','inputType'));
		},
		configurable: false}
	);
	
	// Warning property
	object.warning = false;
	object._protected.warning = object.warning;
	Object.defineProperty(object, 'warning', {
		get: function() {return this._protected.warning;},
		set: function() {
			console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','warning'));
		},
		configurable: false}
	);
	
	// Configure our placeholder
	object.dom.placeholder = document.createElement('div');
	$ui.addClass(object.dom.placeholder,'placeholder theme-hint-text-color');
	object.dom.appendChild(object.dom.placeholder);

	// Multi-Line property
	object._protected.multiLine = object.multiLine;
	Object.defineProperty(object, 'multiLine', {
		get: function() {return this._protected.multiLine;},
		set: function() {
			console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','multiLine'));
		},
		configurable: false}
	);
	
	// Private function called from the base class for setting the enabled state
	object._setEnabled = function(value) {
		if (value == true) {
			this.dom.input.removeAttribute('readonly');
			// TODO: Set Color
		} else {
			this.dom.input.setAttribute('readonly','true');
			// TODO: Set Color
		}
	}.$bind(object);
	
	// Style our enabled state
	if (object.enabled == false) {
		object._setEnabled(false);
	}
	
	// Figure out if we need to set the placeholder/hint
	object.computePlaceholder = function() {
		var small = (this.dom.input.value == '' || this.dom.input.value == undefined) ? false : true;
		if (small) {
			$ui.addClass(this.dom.placeholder,'draw-small');
			$ui.addClass(this.dom.input, 'small-placeholder');
			if (this.dom.textAreaSize != undefined) {
				$ui.addClass(this.dom.textAreaSize, 'small-placeholder');
			}
		} else {
			$ui.removeClass(this.dom.placeholder,'draw-small')
			$ui.removeClass(this.dom.input, 'small-placeholder');
			if (this.dom.textAreaSize != undefined) {
				$ui.removeClass(this.dom.textAreaSize, 'small-placeholder');
			}
		}
	}.$bind(object);
	
	// See if it is single or multi-line input
	if (object.multiLine == true) {
		object.dom.input = document.createElement('textarea');
		$ui.addClass(object.dom.input, 'textarea');
		object.dom.appendChild(object.dom.input);
		object.dom.textAreaSize = document.createElement('div');
		$ui.addClass(object.dom.textAreaSize, 'textarea-size');
		object.dom.appendChild(object.dom.textAreaSize);
		// Check for text
		if (object.text) {
			object.dom.input.value = object.text;
			object.dom.textAreaSize.innerHTML = object.text;
		}
		if ((object.minLinesToShow != undefined) && (parseInt(object.minLinesToShow) > 1)) {
			var minHeight = object.minLinesToShow * 35;
			object.dom.textAreaSize.style['min-height'] = minHeight + 'px';
		}
		if ((object.maxLinesToShow != undefined) && (parseInt(object.maxLinesToShow) > 1)) {
			var maxHeight = (object.maxLinesToShow -1) * 35;
			object.dom.textAreaSize.style['max-height'] = maxHeight + 'px';
			object.dom.input.style['overflow-y'] = 'scroll';
			object.dom.input.onscroll = function() {
				if (this.scrollTop > 0) {
					this.model.dom.placeholder.style.display = 'none';
				} else {
					this.model.dom.placeholder.style.display = 'inherit';
				}
			}
		}
	} else {
		// Create our actual input box
		object.dom.input = document.createElement('input');		
		if(object.password == true){
			object.dom.input.setAttribute('type', 'password');
		}
		else {
			object.dom.input.setAttribute('type', 'text');
		}
		$ui.addClass(object.dom.input, 'text');
		object.dom.input.style.color = $ui.theme.textColor;
		// Check for text
		if (object.text) {
			object.dom.input.setAttribute('value',object.text);
		}
		object.dom.appendChild(object.dom.input);
	} 
	// Set our automation markers
	if (object.id) {
		object.dom.input.setAttribute('data-interaction-input',object.id);
	}
		
	object.dom.input.onfocus = function() {
		this.model.dom.style.borderColor = $ui.theme.color;
		$ui.addClass(this.model.dom, 'theme-brand-border-color');
		if (this.model.onfocus) {
			this.model.onfocus();
		}
	}
	
	object.dom.input.onblur = function() {
		$ui.removeClass(this.model.dom, 'theme-brand-border-color');
		if (this.model.onblur) {
			this.model.onblur();
		}
	}
	
	// Assign our pointers
	object.dom.input.model = object;
	object.computePlaceholder();
	
	// tabIndex property
	if (object.tabIndex != undefined) {
		object.dom.input.tabIndex = object.tabIndex;
	}
	object._protected.tabIndex = object.tabIndex;
	Object.defineProperty(object, 'tabIndex', {
		get: function() {return this._protected.tabIndex;},
		set: function() {
			console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','tabIndex'));
		},
		configurable: false}
	);
	
	// Prevent FastClick for dom.input if-and-only-if it's multiline input field if it's Apple Device
	if($ui.isApple === true) {
		if(object.multiLine === true) {
			object.dom.input.addEventListener('touchstart',function(e) {
				e.stopPropagation();
			},false);
			object.dom.input.addEventListener('touchend',function(e) {
				e.stopPropagation();
			},false);
		}
	} else {
		object.dom.input.addEventListener('touchstart',function(e) {
			e.stopPropagation();
		},false);
		object.dom.input.addEventListener('touchend',function(e) {
			e.stopPropagation();
		},false);
	}
	
	// Trap the keyup to trigger the event
	object.dom.input.addEventListener('keyup',function(e) {
		// See if they pressed enter
		if ((e.keyCode == 13) && (this.model.onenterkey)) {
			this.model.onenterkey();
		} 
	},false);
	
	// Trap the keydown to check input types
	object.dom.input.addEventListener('keydown',function(e) {
		// Check our input type
		if (this.model.inputType == $ui.Input.InputType.INTEGER || this.model.inputType == $ui.Input.InputType.FLOAT) {
			if (e.keyCode == 127 || e.keyCode == 8 || e.keyCode == 9 || e.keyCode == 13 || e.keyCode == 46 || e.keyCode == 37 || e.keyCode == 39) return;
			if ((e.keyCode >= 48 && e.keyCode <= 57) || (e.keyCode >= 96 && e.keyCode <= 105)) return;
			if ((e.keyCode == 110 || e.keyCode == 190) && this.model.inputType == $ui.Input.InputType.FLOAT) {
				return;
			}
			e.preventDefault();
		}
	},false);
	
	object.dom.input.addEventListener('input',function(e) {
		this.model._raiseInteractionEvent('data-interaction-input');
		this.model._protected.text = this.value;
		// Adjust our multi-line size by adjusting the outer div height
		if (this.model.multiLine == true) {
			this.model.dom.textAreaSize.innerHTML = this.value.replace(new RegExp('\n', 'g'), '<br>&nbsp;');//this.value;
		} 
		// Calculate our placeholder position and update the data provider
		this.model.computePlaceholder();
		this.model._updateData(this.model.text);
		// Fire our onchange event
		if (this.model.onchange) {
			this.model.onchange();
		}
	},false);
	
	
	// Text Property
	object._protected.text = object.text;
	Object.defineProperty(object, 'text', {
		get: function() {return this._protected.text;},
		set: function(value) {
			if (value == this._protected.text) return;
			this._setText(value);
			this._updateData(this.text);
		},
		configurable: false}
	);
	
	/**
	* This function will set focus to the input control
	* @function setFocus
	* @memberof $ui.Input
	*/
	object.setFocus = function(value) {
		this.dom.input.focus();
	}.$bind(object);
	
	// Private function to set the text
	object._setText = function(value) {
		if (value == undefined) {
			value = '';
		}
		this._protected.warning = false;
		$ui.removeClass(this.dom.input, 'theme-warning-text-color');
		$ui.removeClass(this.dom.placeholder, 'theme-warning-text-color');
		this._protected.text = value;
		if (this.multiLine == true) {
			$ui.removeClass(this.dom.input, 'placeholder');
			this.dom.input.value = value;
			this.dom.textAreaSize.innerHTML = value;
			this.dom.input.onblur();
		} else {
			this.dom.input.value = this._protected.text;
		}
		this.computePlaceholder();
	}.$bind(object);
	
	// Hint Property
	if (object.hint == undefined) {
		object.hint = '';
	}
	object.dom.placeholder.textContent = object.hint;
	object._protected.hint = object.hint;
	Object.defineProperty(object, 'hint', {
		get: function() {return this._protected.hint;},
		set: function(value) {
			if (value == undefined) value = '';
			if (value == this._protected.hint) return;
			this._protected.hint = value;
			this.dom.placeholder.textContent = value;
			this.computePlaceholder();
		},
		configurable: false}
	);
	
	/**
	* This function will validate the contents of the input control and return <b>false</b> if the contents are not valid
	* @function validate
	* @returns {boolean}
	* @memberof $ui.Input
	*/
	object.validate = function() {
		// Check for custom validation
		if (this.onvalidate) {
			if (this.onvalidate() == false) {
				this._protected.warning = true;
			}
		}
		if (this._protected.warning == true) {
			$ui.addClass(this.dom.input,'theme-warning-text-color');
			$ui.addClass(this.dom.placeholder, 'theme-warning-text-color');
		} else {
			$ui.removeClass(this.dom.input,'theme-warning-text-color');
			$ui.removeClass(this.dom.placeholder, 'theme-warning-text-color');
			if (this._protected.hadNoHint == true) {
				this.hint = undefined;
			} else {
				this.dom.placeholder.textContent = this.hint;
			}
		}
		return !this._protected.warning;
	}.$bind(object);
	
	// Private function to handle provider updates
	object._providerUpdate = function(value) {
		this._setText(value);
	}.$bind(object);
	
	return object.dom;
}



/**
 * This object defines the type of background to be shown on the screen.<br><br>
 * <b>Sample Code:</b><br>
 * <pre>
 * {
 *   img: 'img/background.png', 
 *   repeat: true, 
 *}
 * </pre>
 * @class ScreenBackground
 * @param {string} img - Path to the background image
 * @param {boolean} [repeat=false] - Whether or not you want the background repeated/tiled
 */
function ScreenBackground(img, repeat) {
	/** 
	 * Path to the background image
	 * @member {string} img
	 * @memberOf ScreenBackground
	 */
	if (img == null) throw new Error('ScreenBackground: img cannot be null');
	if (img == undefined) throw new Error('ScreenBackground: img cannot be undefined');
	this.img = img;
	/** 
	 * Whether or not you want the background repeated/tiled
	 * @member {boolean} [repeat=false]
	 * @memberOf ScreenBackground
	 */
	if (repeat == undefined || repeat == null) {
		this.repeat = false;
	}
}
/**
 * The segmented control provides an actionable item for the user to choose between multiple options.
 * A segmented control's width will fill the width of the container in which it is a member.<br><br>
 * <b>Sample Declaration</b><br>
 * <pre>
 * {
 *   component: $ui.SegmentedControl,
 *   selectedIndex: 0,
 *   options: ['One', 'Two', 'Three'],
 *   onclick: function() {
 *      alert('You clicked: ' + this.options[this.selectedIndex]);
 *   }
 *}
 * @namespace SegmentedControl
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {number} [selectedIndex=0] - Represents the index of the option you want to be selected. This property will also be updated whenever a user selects an option from the control. 
 * @property {string[]} options - This property represents the options provided by the control. It is an array of string values that will be displayed
 * @property {GenericEvent} [onclick] - The onclick event will fire when the user selects/clicks an option in the control. You can retrieve which option was selected by inspecting the <b>selectedIndex</b> property.
 */
function $ui_SegmentedControl(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom,'ui-segmented-control theme-segmented-control');
	if ($ui.theme.inHeadUnit == true) {
		$ui.addClass(object.dom, 'in-head-unit');
	}
	object.domOptions = [];
	
	/** 
	 * You can set the selected index for the control by using this function. This function will also raise the <i>onclick</i> event as though a user just clicked the control.
	 * @function setSelectedIndex
	 * @memberof $ui.SegmentedControl
	 * @param {number} index - Item to be added to the menu
	 */
	object.setSelectedIndex = function(index) {
		if (this.selectedIndex != index) {
			this.selectedIndex = index;
			// Trigger the onclick
			if (this.onclick) {
				this.onclick(); 
			}
		} 
		this._setSelectedIndex(index);
	}.$bind(object);
	
	// Private function to set the selected index for the control
	object._setSelectedIndex = function(index) {
		if (this.options) {
			var i,
				option;
			for (i = 0; i < this.domOptions.length; i++) {
				option = this.domOptions[i];
				if (i == index) {
					option._setSelected(true);
				} else {
					option._setSelected(false);
				}
			}
		}
	}.$bind(object);
	
	// Go through our options
	if (object.options) {
		var i,
			option, 
			percentage = 100/object.options.length;
		
		for (i = 0; i < object.options.length; i++) {
			option = document.createElement('div');
			$ui.addClass(option,'button');
			if (i == 0) {
				$ui.addClass(option,'left');
			} else if (i == object.options.length -1) {
				$ui.addClass(option,'right');
			}
			option.model = object;
			option.index = i;
			option.selected = false;
			option.style.width = percentage + '%';
			option.style.left = (i * percentage) + '%';
			option.textContent = object.options[i];
			object.domOptions.push(option);
			object.dom.appendChild(option);
			
			// Pass the onclick back to the list
			option.addEventListener('click', function() {
				if (this.model.enabled == false) return;
				if (this.selected) return;
				this.model.setSelectedIndex(this.index);
			},false);
			
			// Change the selected state for the button
			option._setSelected = function(value) {
				this.selected = value;
				if (value == true) {
					$ui.addClass(this,'selected');
					$ui.addClass(this,'theme-brand-background-color');
					$ui.addClass(this,'theme-highlight-text-color');
				} else {
					$ui.removeClass(this,'selected');
					$ui.removeClass(this,'theme-brand-background-color');
					$ui.removeClass(this,'theme-highlight-text-color');
				}
			}.$bind(option);
		}
	}
	// Set our selected index
	if (object.selectedIndex) {
		object._setSelectedIndex(object.selectedIndex);
	} else {
		object.selectedIndex = 0;
		object._setSelectedIndex(0);
	}
	
	return object.dom;
}

/**
 * The SplitView object represents two vertical columns for layout components. The SplitView will size itself to all the available space provided by its parent control.
 * <br><br><b>Sample Declaration</b>
 * <pre>
 * {
 *    component: $ui.SplitView,
 *    left: [
 *        {
 *            component: $ui.SegmentedControl
 *        }
 *    ],
 *    right: [
 *        {
 *            component: $ui.Spinner
 *        }
 *    ]
 * }
 * </pre>
 * @namespace SplitView
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {$ui.CoreComponent[]} left - This array holds all of the component definitions for the left side of the split view
 * @property {$ui.CoreComponent[]} right - This array holds all of the component definitions for the right side of the split view
 */
function $ui_SplitView(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom,'ui-split-view');
	
	var i,
		control,
		controlDom;
	
	// Create our left column
	object.dom.leftCol = document.createElement('div');
	$ui.addClass(object.dom.leftCol, 'col');
	$ui.addClass(object.dom.leftCol, 'left theme-brand-border-color');
	object.dom.appendChild(object.dom.leftCol);
	
	// Load our left column
	if (object.left) {
		for (i = 0; i < object.left.length; i++) {
			control = object.left[i];
			controlDom = $ui.createControl(control, screen);
			if (controlDom) {
				object.dom.leftCol.appendChild(controlDom);
			}
		}
	}
	
	// Create our right column
	object.dom.rightCol = document.createElement('div');
	$ui.addClass(object.dom.rightCol, 'col');
	$ui.addClass(object.dom.rightCol, 'right');
	object.dom.appendChild(object.dom.rightCol);
	
	// Load our right column
	if (object.right) {
		for (i = 0; i < object.right.length; i++) {
			control = object.right[i];
			controlDom = $ui.createControl(control, screen);
			if (controlDom) {
				object.dom.rightCol.appendChild(controlDom);
			}
		}
	}
	
	return object.dom;
}
/**
 * The Tab object represents a tab within a {@link $ui.TabbedPane}.  A tab represents a container of multiple other controls
 * <br><br><b>Sample Declaration</b>
 * <pre>
 * {
 *    component: $ui.Tab,
 *    content: [
 *        {
 *            component: $ui.Spinner
 *        }
 *    ]
 * }
 * </pre>
 * @namespace Tab
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {$ui.CoreComponent[]} content - This array holds all of the component definitions to be displayed in the tab
 * @property {boolean} [selected=false] - This property, when set to <i>true</i> will specify that the tab should be the default selected tab in the [Tabbed Pane]{@link $ui.TabbedPane}.  The Tabbed Pane will select only the first tab it encounters with selected set to <i>true</i> as the selected tab.
 */
function $ui_Tab(object, screen) {
	// All tabs are invisible by default
	object.visible = false;
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom,'ui-tab');
	// Set our default
	if (object.selected != true) {
		object.selected = false;
	}
	
	var i,
		control,
		controlDom;
	// Load our contents
	if (object.content) {
		for (i = 0; i < object.content.length; i++) {
			control = object.content[i];
			controlDom = $ui.createControl(control, screen);
			if (controlDom) {
				object.dom.appendChild(controlDom);
			}
		}
	}
	
	return object.dom;
}
/**
 * The TabbedPane object represents a container that has one or more {@link $ui.Tab} objects.<br><br>
 * A Tabbed Pane will cover the entire area of the control it is contained by. The control will cycle through all of the defined Tabs and see which one has been specified as the first selected tab. If no tabs are found with the specified <b>selected:true</b> property, it will select the first tab in the list.
 * <br><br><b>Sample Declaration</b>
 * <pre>
 * {
 *    component: $ui.TabbedPane,
 *    tabs: [
 *        {
 *            component: $ui.Tab,
 *            selected: true
 *        }
 *    ]
 * }
 * </pre>
 * @namespace TabbedPane
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {$ui.Tab[]} content - This array holds all of the {@link $ui.Tab} objects that are to be controlled by the tabbed pane
*/
function $ui_TabbedPane(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom,'ui-tabbed-pane');
	// Set our default selected tab
	object._selectedTab = undefined;
	
	var i,
		control,
		controlDom,
		selectedTab;
	// Load our tabs
	if (object.tabs) {
		for (i = 0; i < object.tabs.length; i++) {
			control = object.tabs[i];
			if (control.component != $ui.Tab) continue;
			control.parent = object;
			controlDom = $ui.createControl(control, screen);
			if (controlDom) {
				object.dom.appendChild(controlDom);
			}
			// See if it is the selected tab
			if ((control.selected === true) && (object._selectedTab == undefined)) {
				object._selectedTab = control;
			}
		}
	}
	
	/** 
	 * This function will set the selected tab to the value passed in as a parameter
	 * @function selectTab
	 * @memberof $ui.TabbedPane
	 * @param {$ui.Tab} tab - Tab to select
	 */
	object.selectTab = function(tab) {
		if (tab == undefined) return;
		if (tab.component != $ui.Tab) return;
		if (tab === this._selectedTab) return;
		// Unselect all tabs
		var i,
			item;
		for (i = 0; i < this.tabs.length; i++) {
			item = this.tabs[i];
			item.selected = false;
			item.visible = false;
		}
		// Now select the desired tab
		this._selectTab(tab);
	}.$bind(object);
	
	// Private function to select a tab
	object._selectTab = function(tab) {
		if (tab == undefined) return;
		if (tab.component != $ui.Tab) return;
		object._selectedTab = tab;
		tab.selected = true;
		tab.visible = true;
	}.$bind(object);
	
	// Set our selected tab
	if ((object._selectedTab == undefined) && (object.tabs.length > 0)){
		object._selectedTab = object.tabs[0];
	}
	if (object._selectedTab != undefined) {
		object._selectTab(object._selectedTab);
	}
	
	return object.dom;
}
/**
 * The Tile Group object represents a container that holds one or more tiles that inherit from {@link $ui.CoreTile}.
 * <br><br><b>Sample Declaration</b>
 * <pre>
 * {
 *    component: $ui.TileGroup,
 *    tiles: [
 *        {
 *            component: $ui.TileCool,
 *            value: 70
 *        {
 *    ]
 * }
 * </pre>
 * @namespace TileGroup
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {$ui.CoreTile[]} tiles - This array holds all of the Tiles which are to be displayed
 */
function $ui_TileGroup(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom,'ui-tile-group');
	if ($ui.theme.inHeadUnit == true) {
		$ui.addClass(object.dom,'in-head-unit');
	}
	
	// Set our default tile size
	object._tileSize = 256;
	object._thresholdWidth = 1024;
	
	// Create the inner area for the tiles
	object.dom.inner = document.createElement('div');
	$ui.addClass(object.dom.inner, 'group-inner');
	object.dom.appendChild(object.dom.inner);
	
	// Create a matrix for keeping track of open slots
	object.matrix = [];

	// From the row and column number set the top left of the tile
	object._setTileTopLeft = function(tile, rowNum, colNum) {
		tile.dom.style.top = ((rowNum  * this._tileSize) + 'px');
		tile.dom.style.left = ((colNum * this._tileSize) + 'px');
	}.$bind(object);
	
	// Best position the tile in the group
	object._positionTile = function(tile) {
		var row,
			colNum,
			rowNum,
			found = false;
		
		if (tile._size == undefined) { 
			// Will fit in a 1x1 slot..find first slot and insert
			for (rowNum = 0; rowNum < this.matrix.length; rowNum++) {
				row = this.matrix[rowNum];
				for (colNum = 0; colNum < row.length; colNum++) {
					if (row[colNum] === 0) {
						// This space is empty. Now mark it as taken
						row[colNum] = 1;
						this._setTileTopLeft(tile,rowNum,colNum);
						found = true;
						break;
					}
				}
				if (found == true) break;
			}
		} else if (tile._size == $ui.TileSize.WIDE) { 
			// Will fit in a 1x2 slot..find first slot and insert
			for (rowNum = 0; rowNum < this.matrix.length; rowNum++) {
				row = this.matrix[rowNum];
				for (colNum = 0; colNum < row.length; colNum++) {
					if (row[colNum] === 0) {
						if ((colNum+1 <= row.length) && (row[colNum+1] === 0)){
							// This space is empty. Now mark it as taken
							row[colNum] = 1;
							row[colNum+1] = 1;
							this._setTileTopLeft(tile,rowNum,colNum);
							found = true;
							break;
						}
					}
				}
				if (found == true) break;
			}
		} else if (tile._size == $ui.TileSize.TALL) { 
			// Will fit in a 2x1 slot..find first slot and insert
			for (rowNum = 0; rowNum < this.matrix.length; rowNum++) {
				row = this.matrix[rowNum];
				for (colNum = 0; colNum < row.length; colNum++) {
					if (row[colNum] === 0) {
						if ((rowNum+1 < this.matrix.length) && (this.matrix[rowNum+1][colNum] === 0)){
							// This space is empty. Now mark it as taken
							row[colNum] = 1;
							this.matrix[rowNum+1][colNum] = 1;
							this._setTileTopLeft(tile,rowNum,colNum);
							found = true;
							break;
						}
					}
				}
				if (found == true) break;
			}
		} else if (tile._size == $ui.TileSize.SQUARE) { 
			// Will fit in a 2x2 slot..find first slot and insert
			for (rowNum = 0; rowNum < this.matrix.length; rowNum++) {
				row = this.matrix[rowNum];
				for (colNum = 0; colNum < row.length; colNum++) {
					if (row[colNum] === 0) {
						if ((rowNum+1 < this.matrix.length) && (this.matrix[rowNum+1][colNum] === 0) &&
							(colNum+1 < row.length) && (this.matrix[rowNum+1][colNum+1] === 0)){
							// This space is empty. Now mark it as taken
							row[colNum] = 1;
							row[colNum+1] = 1;
							this.matrix[rowNum+1][colNum] = 1;
							this.matrix[rowNum+1][colNum+1] = 1;
							this._setTileTopLeft(tile,rowNum,colNum);
							found = true;
							break;
						}
					}
				}
				if (found == true) break;
			}
		}
		
		// See if no open slot was found
		if (found == false) {
			if (tile._size == undefined) {
				// Add one row and take the first slot
				if (object._is3Columns == true) {
					this.matrix.push([1,0,0]);
				} else {
					this.matrix.push([1,0,0,0]);
				}
				this._setTileTopLeft(tile,this.matrix.length-1,0);
			} else if (tile._size == $ui.TileSize.WIDE) {
				// Add one row and take the first two slots
				if (object._is3Columns == true) {
					this.matrix.push([1,1,0]);
				} else {
					this.matrix.push([1,1,0,0]);
				}
				this._setTileTopLeft(tile,this.matrix.length-1,0);
			} else {
				// Add one row and try again
				if (object._is3Columns == true) {
					this.matrix.push([0,0,0]);
				} else {
					this.matrix.push([0,0,0,0]);
				}
				this._positionTile(tile);
			}
		}
	}.$bind(object);
	
	// Figure out our height based on the matrix
	object._recalculateHeight = function() {
		this.dom.inner.style.height = ((this.matrix.length * this._tileSize) + 'px');
	}.$bind(object);
	
	// Cycle through content
	if (object.tiles) {
		var i,
			control,
			controlDom;
		for (i = 0; i < object.tiles.length; i++) {
			control = object.tiles[i];
			controlDom = $ui.createControl(control, screen);
			if (controlDom) {
				object.dom.inner.appendChild(controlDom);
			}
		}
		object._recalculateHeight();
	}
	
	// Layout all the tiles
	object._layoutTiles = function() {
		var i;
		if (this._is3Columns == false) {
			this.matrix = [];
			this.matrix.push([0,0,0,0]);
		} else {
			this.matrix = [];
			this.matrix.push([0,0,0]);
		}
		// Cycle through our tiles and position them
		for (i = 0; i < this.tiles.length; i++) {
			this._positionTile(this.tiles[i]);
		}
		this._recalculateHeight();
	}.$bind(object);
	
	// Handle resize of screen
	object._onresize = function() {
		if ($ui.options.isClientDevice != true) {
			if ((this._is3Columns == true) && (this.dom.offsetWidth >= this._thresholdWidth)) {
				this._layoutTiles();
			} else if ((this._is3Columns == false) && (this.dom.offsetWidth < this._thresholdWidth)){
				this._layoutTiles();
			}
		}
	}.$bind(object);
	
	// Properly layout the control once animation ends
	object._onshow = function() {
		if ($ui.options.isClientDevice != true) {
			this._is3Columns = (this.dom.offsetWidth < this._thresholdWidth);
			this._layoutTiles();
		}
		this.dom.style.visibility = 'visible';
	}.$bind(object);
	
	return object.dom;
}
/**
 * The Toggle allows a user to move something from a checked/unchecked state typically denoting off/on.
 * <br><br><b>Sample Declaration</b>
 * <pre>
 * {
 *    component: $ui.Toggle,
 *    style: $ui.Toggle.Style.OnOff,
 *    position: 1
 * }
 * </pre>
 * @namespace Toggle
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {number} [position=0] - Represents the position of the switch. 0 represents <b>off</b>, 1 represents <b>on</b> and -1 represents <b>on</b> in reverse direction
 * @property {string} [align=left] - Optionally specify the alignment of the caption as "left", "right" or "center"
 * @property {string} [caption] - Caption to appear with the toggle
 * @property {string} [negativeLabel] - Optional label for the Negative position of an On-Off-On style toggle
 * @property {string} [positiveLabel] - Optional label for the Positive position of an On-Off-On style toggle
 * @property {number} [duration=0] - How long the switch should stay in the <b>on</b> position in milliseconds. A value of 0 means no duration.
 * @property {GenericEvent} [onclick] - Fires when a user clicks the control or changes its state
 */
function $ui_Toggle(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom,'ui-toggle');
		
	if ($ui.theme.inHeadUnit == true) {
		$ui.addClass(object.dom, 'in-head-unit');
	}
	
	// Create our bottom border
	object.dom.bottomBorder = document.createElement('div');
	$ui.addClass(object.dom.bottomBorder, 'bottom-border theme-dark-background-color');
	object.dom.appendChild(object.dom.bottomBorder);
	
	// Create our caption area
	object.dom.caption = document.createElement('span');
	$ui.addClass(object.dom.caption,'caption theme-text-color');
	object.dom.appendChild(object.dom.caption);
	
	// Create our duration area
	object.dom.duration = document.createElement('div');
	$ui.addClass(object.dom.duration, 'duration');
	object.dom.appendChild(object.dom.duration);
	// Bottom
	object.dom.duration.bottomDiv = document.createElement('div');
	$ui.addClass(object.dom.duration.bottomDiv, 'bottom');
	object.dom.duration.appendChild(object.dom.duration.bottomDiv);
	// Number
	object.dom.duration.number = document.createElement('div');
	$ui.addClass(object.dom.duration.number, 'number theme-highlight-text-color');
	object.dom.duration.bottomDiv.appendChild(object.dom.duration.number);
	// Bar
	object.dom.duration.bar = document.createElement('div');
	$ui.addClass(object.dom.duration.bar, 'bar theme-brand-background-color');
	object.dom.duration.bottomDiv.appendChild(object.dom.duration.bar);
	
	// style property
	if (object.style == undefined) {
		object.style = $ui.Toggle.Style.OnOff;
	}
	$ui.addClass(object.dom, object.style);
	object._protected.style = object.style;
	Object.defineProperty(object, 'style', {
		get: function() {return this._protected.style;},
		set: function(value) {
			if (value == undefined) value = $ui.Toggle.Style.OnOff;
			if (value == this._protected.style) return;
			$ui.removeClass(this.dom, this._protected.style);
			if (this._protected.style == $ui.Toggle.Style.OnOff) {
				this.dom.removeChild(this.dom.innerToggle);
			} else if (this._protected.style == $ui.Toggle.Style.Momentary) {
				this.dom.removeChild(this.dom.momentary);
			} else if (this._protected.style == $ui.Toggle.Style.OnOffOn) {
				this.dom.removeChild(this.dom.innerToggle);
			}
			this._protected.style = value;
			$ui.addClass(this.dom, this._protected.style);
			if (value == $ui.Toggle.Style.OnOff) {
				this._createOnOffStyle();
				this._setPosition(this.position);
			} else if (value == $ui.Toggle.Style.Momentary) {
				this._createMomentaryStyle();
			} else if (value == $ui.Toggle.Style.OnOffOn) {
				this._createOnOffOnStyle();
				this._setPosition(this.position);
			}
		},
		configurable: false}
	);
	
	// Handles creating our on-off style of toggle switch
	object._createOnOffStyle = function() {
		// Create our inner Toggle area
		this.dom.innerToggle = document.createElement('div');
		this.dom.innerToggle.model = this;
		$ui.addClass(this.dom.innerToggle, 'inner-toggle theme-border-color');
		this.dom.appendChild(this.dom.innerToggle);
		// Create our inner slide
		this.dom.slide = document.createElement('div');
		$ui.addClass(this.dom.slide,'slide');
		this.dom.innerToggle.appendChild(this.dom.slide);
		// Create our yes area
		this.dom.left = document.createElement('div');
		$ui.addClass(this.dom.left,'left');
		this.dom.slide.appendChild(this.dom.left);
		// Create our button area
		this.dom.button = document.createElement('div');
		$ui.addClass(this.dom.button,'button theme-border-color');
		this.dom.slide.appendChild(this.dom.button);
		this.dom.button.inner = document.createElement('div');
		$ui.addClass(this.dom.button.inner, 'button-inner theme-brand-border-color');
		this.dom.button.appendChild(this.dom.button.inner);
		// Create our right area
		this.dom.right = document.createElement('div');
		$ui.addClass(this.dom.right,'right');
		this.dom.slide.appendChild(this.dom.right);
		// Fire the onclick
		this.dom.innerToggle.addEventListener('click', function() {
			if (this.model.enabled == false) return;
			if (this.model._protected.isCountingDown == true) return;
			$ui.playTouchSound();
			if (this.model.position == 0) {
				this.model.position = 1;
			} else {
				this.model.position = 0;
			}
			if (this.model.onclick) {
				this.model.onclick(this.model);
			}
		},false);
	}.$bind(object);
	
	// Handles creating our on-off-on style of toggle switch
	object._createOnOffOnStyle = function() {
		// Create our inner Toggle area
		this.dom.innerToggle = document.createElement('div');
		this.dom.innerToggle.model = this;
		$ui.addClass(this.dom.innerToggle, 'inner-toggle theme-border-color');
		this.dom.appendChild(this.dom.innerToggle);
		// Create our inner slide
		this.dom.slide = document.createElement('div');
		$ui.addClass(this.dom.slide,'slide');
		this.dom.innerToggle.appendChild(this.dom.slide);
		// Create our left area
		this.dom.left = document.createElement('div');
		$ui.addClass(this.dom.left,'left');
		this.dom.slide.appendChild(this.dom.left);
		this.dom.left.label = document.createElement('div');
		$ui.addClass(this.dom.left.label, 'label theme-dark-text-color');
		this.dom.left.appendChild(this.dom.left.label);
		if (this.negativeLabel != undefined && this.style == $ui.Toggle.Style.OnOffOn) {
			this.dom.left.label.textContent = this.negativeLabel;
		}	
		// Create our button area
		this.dom.button = document.createElement('div');
		$ui.addClass(this.dom.button,'button theme-border-color');
		this.dom.slide.appendChild(this.dom.button);
		this.dom.button.inner = document.createElement('div');
		$ui.addClass(this.dom.button.inner, 'button-inner theme-brand-border-color');
		this.dom.button.appendChild(this.dom.button.inner);
		// Create our right area
		this.dom.right = document.createElement('div');
		$ui.addClass(this.dom.right,'right');
		this.dom.slide.appendChild(this.dom.right);
		this.dom.right.label = document.createElement('div');
		$ui.addClass(this.dom.right.label, 'label theme-dark-text-color');
		this.dom.right.appendChild(this.dom.right.label);
		if (this.positiveLabel != undefined && this.style == $ui.Toggle.Style.OnOffOn) {
			this.dom.right.label.textContent = this.positiveLabel;
		}	
		// Fire the onclick
		this.dom.innerToggle.onclick = function(event) {
			if (this.model.enabled == false) return;
			if (this.model._protected.isCountingDown == true) return;
			$ui.playTouchSound();
			var rect = this.getBoundingClientRect(),
				third = (rect.right - rect.left)/3;	
			if (event.clientX < (rect.left + third)) {
				this.model.position = -1; // Negative
			} else if (event.clientX > (rect.right - third)) {
				this.model.position = 1; // Positive
			} else {
				this.model.position = 0; // Off
			}
			if (this.model.onclick) {
				this.model.onclick(this.model);
			}
		};
	}.$bind(object);
	
	// Create our DOM for a momentary switch
	object._createMomentaryStyle = function() {
		this.dom.momentary = document.createElement('div');
		this.dom.momentary.model = this;
		$ui.addClass(this.dom.momentary, 'momentary theme-brand-background-color theme-highlight-text-color');
		this.dom.appendChild(this.dom.momentary);
		this.dom.momentary.onclick = function(event) {
			if (this.model._protected.isCountingDown == true) return;
			if (this.model.enabled == false) return;
			$ui.playTouchSound();
			this.model.position = 1;
			if (this.model.onclick) {
				this.model.onclick(this.model);
			}
			if (this.model.duration == undefined || this.model.duration <= 0) {
				var model = this.model;
				window.setTimeout(function() {
					model.position = 0;
				}, 500);
			}
		};
		this.dom.momentary.ontouchstart = function() {
			this.style.opacity = '0.7';
		};
		this.dom.momentary.ontouchend = function() {
			this.style.opacity = '';
		};
		this.dom.momentary.ontouchcancel = this.dom.momentary.ontouchend;
		if (!$ui.isMobileDevice()) {
			this.dom.momentary.onmousedown = this.dom.momentary.ontouchstart;
			this.dom.momentary.onmouseup = this.dom.momentary.ontouchend;
			this.dom.momentary.onmouseleave = this.dom.momentary.ontouchend;
		}
	}.$bind(object);
	
	// This is our standard toggle
	if (object.style == $ui.Toggle.Style.OnOff) {
		object._createOnOffStyle();
	} else if (object.style == $ui.Toggle.Style.Momentary) { // Our momentary switch styling
		object._createMomentaryStyle();
	} else if (object.style == $ui.Toggle.Style.OnOffOn) {
		object._createOnOffOnStyle();
	}
	
	// positiveLabel Property
	object._protected.positiveLabel = object.positiveLabel;
	Object.defineProperty(object, 'positiveLabel', {
		get: function() {return this._protected.positiveLabel;},
		set: function(value) {
			if (value == undefined) value = '';
			if (value == this._protected.positiveLabel) return;
			this._protected.positiveLabel = value;
			if (this.style == $ui.Toggle.Style.OnOffOn) {
				this.dom.right.label.textContent = value;
			}
		},
		configurable: false}
	);
	
	// negativeLabel Property
	object._protected.negativeLabel = object.negativeLabel;
	Object.defineProperty(object, 'negativeLabel', {
		get: function() {return this._protected.negativeLabel;},
		set: function(value) {
			if (value == undefined) value = '';
			if (value == this._protected.negativeLabel) return;
			this._protected.negativeLabel = value;
			if (this.style == $ui.Toggle.Style.OnOffOn) {
				this.dom.left.label.textContent = value;
			}
		},
		configurable: false}
	);
	
	// Caption Property
	if (object.caption != undefined) {
		object.dom.caption.textContent = object.caption;
	}	
	object._protected.caption = object.caption;
	Object.defineProperty(object, 'caption', {
		get: function() {return this._protected.caption;},
		set: function(value) {
			if (value == this._protected.caption) return;
			if (value == undefined) value = '';
			this._protected.caption = value;
			this.dom.caption.textContent = value;
		},
		configurable: false}
	);
	
	// align property
	if (object.align == 'center') {
		$ui.addClass(object.dom.caption,'align-center');
	} else if (object.align == 'right') {
		$ui.addClass(object.dom.caption,'align-right');
	} else {
		object.align = 'left';
		$ui.addClass(object.dom.caption,'align-left');
	}
	object._protected.align = object.align;
	Object.defineProperty(object, 'align', {
		get: function() {return this._protected.align;},
		set: function() {
			console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','align'));
		},
		configurable: false}
	);
	
	// Private function to set the position state
	object._setPosition = function(value) {
		if (value == undefined) {
			value = 0;
		}
		this._protected.position = value;
		if (this.style == $ui.Toggle.Style.OnOff) {
			if (value == 0) {
				$ui.removeClass(this.dom.innerToggle,'yes');
				$ui.removeClass(this.dom.innerToggle, 'theme-brand-background-color');
				$ui.removeClass(this.dom.button.inner,'theme-light-background-color');
				$ui.addClass(this.dom.innerToggle,'no');
			} else {
				$ui.removeClass(this.dom.innerToggle, 'no');
				$ui.addClass(this.dom.innerToggle,'yes theme-brand-background-color');
				$ui.addClass(this.dom.button.inner,'theme-light-background-color');
			}
		} else if (this.style == $ui.Toggle.Style.OnOffOn) {
			$ui.removeClass(this.dom.innerToggle, 'theme-brand-background-color');
			$ui.removeClass(this.dom.button.inner,'theme-light-background-color');
			if (value == 0) {
				$ui.removeClass(this.dom.innerToggle,'positive');
				$ui.removeClass(this.dom.innerToggle,'negative');
				this.dom.right.label.style.display = 'block';
				this.dom.left.label.style.display = 'block';
			} else if (value == 1) {
				$ui.removeClass(this.dom.innerToggle, 'negative');
				$ui.addClass(this.dom.innerToggle,'positive theme-brand-background-color');
				$ui.addClass(this.dom.button.inner,'theme-light-background-color');
				this.dom.right.label.style.display = 'none';
				this.dom.left.label.style.display = 'none';
			} else {
				$ui.removeClass(this.dom.innerToggle, 'positive');
				$ui.addClass(this.dom.innerToggle,'negative theme-brand-background-color');
				$ui.addClass(this.dom.button.inner,'theme-light-background-color');
				this.dom.right.label.style.display = 'none';
				this.dom.left.label.style.display = 'none';
			}
		}
	}.$bind(object);
	
	// duration Property
	if (object.duration == undefined) {
		object.duration = 0;
	}
	if (object.duration > 0) {
		object.dom.duration.style.display = 'block';
	}
	object._protected.duration = object.duration;
	Object.defineProperty(object, 'duration', {
		get: function() {return this._protected.duration;},
		set: function(value) {
			if (value == undefined) value = 0;
			if (value == this._protected.duration) return;
			this._protected.duration = value;
			if (value <= 0) {
				this.dom.duration.style.display = 'none';
			} else {
				this.dom.duration.style.display = 'block';
			}
		},
		configurable: false}
	);
	
	// position Property
	if (object.position == undefined) {
		object.position = 0;
	}
	object._setPosition(object.position);
	object._protected.position = object.position;
	Object.defineProperty(object, 'position', {
		get: function() {return this._protected.position;},
		set: function(value) {
			if (value == this._protected.position) return;
			this._protected.position = value;
			this._setPosition(value);
			this._updateData(value); // update our provider
			if (value == 0) {
				this._protected.isCountingDown = false;
				this.dom.duration.bottomDiv.style.opacity = 0;
				this.dom.duration.style['-webkit-transform'] = 'translate3d(0px, 0px, 0px)';
				if (this.style == $ui.Toggle.Style.OnOff || this.style == $ui.Toggle.Style.OnOffOn) {
					this.dom.innerToggle.style.opacity = 1;
				} else {
					this.dom.momentary.style.opacity = 1;
				}
			} else if ( this.duration && this.duration > 0) {
				this.dom.duration.bottomDiv.style.opacity = 1;
				if ($ui.options.isClientDevice == true) {
					this.dom.duration.style['-webkit-transform'] = 'translate3d(-20px, -10px, 0px)';
				} else {
					this.dom.duration.style['-webkit-transform'] = 'translate3d(-26px, -14px, 0px)';
				}
				this._protected.intervalCount = this.duration;
				this._protected.isCountingDown = true;
				this.dom.duration.bar.style.width = '100%';
				this.dom.duration.number.textContent = (this._protected.intervalCount/1000);
				this._protected.interval = window.setInterval(this._countDownInterval, 1000);
				if (this.style == $ui.Toggle.Style.OnOff || this.style == $ui.Toggle.Style.OnOffOn) {
					this.dom.innerToggle.style.opacity = 0.5;
				} else {
					this.dom.momentary.style.opacity = 0.5;
				}
			}
		},
		configurable: false}
	);
	
	// Handle our count down interval
	object._countDownInterval = function() {
		this._protected.intervalCount = this._protected.intervalCount - 1000;
		var rounded = this._protected.intervalCount / 1000;
		if (rounded < 0) {
			rounded = 0;
		}
		this.dom.duration.number.textContent = rounded;
		this.dom.duration.bar.style.width = (1 - (this._protected.duration - this._protected.intervalCount)/this._protected.duration) *100 + '%';
		if (this._protected.intervalCount <= 0) {
			window.clearInterval(this._protected.interval);
			this.position = 0;
		}
	}.$bind(object);
	
	// Private function to handle provider updates
	object._providerUpdate = function(value) {
		this._setPosition(value);
	}.$bind(object);
	
	object._ondestroy = function() {
		if (this._protected.interval) {
			window.clearInterval(this._protected.interval);
		}
	}.$bind(object);
	
	return object.dom;
}

/**
 * This is the object that represents a window instance in a head unit. It derives from {@link $ui.CoreScreen}. A WindowPane is declared as a JavaScript function and has various different properties. 
 * When a WindowPane is pushed onto the stack a new instance of the screen will be created and rendered.
 * <br><br><b>Sample Declaration</b>
 * <pre>
 * function MyWindowPane() {
 *   this.component = $ui.WindowPane;
 *   this.content = [
 *       {
 *          component: $ui.SegmentedControl,
 *       }
 *   ];
 *
 *   this.onshow = function() {
 *      console.log('I was just shown');
 *   }
 * }
 * </pre>
 * @namespace WindowPane
 * @memberof $ui
 * @extends $ui.CoreScreen
 * @property {ScreenBackground} [background] - This object defines the type of background to be shown on the screen
 * @property {$ui.CoreComponent[]} content - This object array specifies the list of controls that will be rendered in this screen
 * @property {string} [backCaption] - This property defines the text you would like to appear on the title bar with a back button. If this is left <i>undefined</i> then no back button will appear
 * @property {GenericEvent} [onbackclick] - This event fires when the user presses the "Back" button.  It allows you to run logic before the screen is popped off of the stack.  If you wish to block the "Back" action return <b>false</b> from your event handler
 */
function $ui_WindowPane(object, data) {
	$ui_CoreScreen.call(this, object, data);
	if (object) {
		$ui.addClass(object.dom,'ui-window-pane theme-screen-background-color');
		if ($ui.theme.inHeadUnit == true) {
			$ui.addClass(object.dom, 'in-head-unit');
		}
		
		// Set our width to that of our parent
		if (!object.width) {
			object.dom.style.width = window.innerWidth + 'px'; // default
		} else {
			object.dom.style.width = object.width + 'px';
		}
		
		// Create our background image div
		object.dom.backgroundDiv = document.createElement('div');
		$ui.addClass(object.dom.backgroundDiv,'background theme-screen-background-color');
		object.dom.appendChild(object.dom.backgroundDiv);
		
		if (object.backCaption) {
			object.dom.backBar = document.createElement('div');
			$ui.addClass(object.dom.backBar,'back-bar theme-screen-background-color theme-brand-border-color');
			$ui.addClass(object.dom,'has-back');
			object.dom.appendChild(object.dom.backBar);
			object.dom.backCaption = document.createElement('span');
			object.dom.backCaption.textContent = object.backCaption;
			object.dom.backCaption.model = object;
			$ui.addClass(object.dom.backCaption,'caption theme-text-color');
			object.dom.backBar.appendChild(object.dom.backCaption);
			object.dom.backCaption.onclick = function() {
				$ui.playTouchSound();
				if (this.model.onbackclick) {
					var allow = this.model.onbackclick();
					if (allow != false) {
						$ui.pop();
					}
				} else {
					$ui.pop();
				}
			};
			try {
				Object.defineProperty(object,"backCaption",{
					get:function() {
						return object.dom.backCaption.textContent;
					},set:function(newCaption) {
						console.log("RPW: setting caption to " + newCaption);
						object.dom.backCaption.textContent = newCaption;
					}
				});
			} catch (toIgnore) {
				console.log("RPW: ignoring " + toIgnore);
			}
		}

		/** 
		 * Set the background for the screen
		 * @function setBackground
		 * @memberof $ui.WindowPane
		 * @param {ScreenBackground} screenBackground - The background object to use for the screen.
		 */
		object.setBackground = function(screenBackground) {
			// Clear existing background
			if (this.background) {
				this.dom.backgroundDiv.style.opacity = '0';
			} 
			// Load new background
			if (screenBackground != undefined) {
				this.background = screenBackground;
				// Check for repeat
				if (this.background.repeat === true) {
					this.dom.backgroundDiv.style.backgroundRepeat = 'repeat';
				} else {
					this.dom.backgroundDiv.style.backgroundSize = 'cover';
				}
				// Load our image
				if (this.background.img) {
					this._loader = new Image();
					this._loader.model = this;
					this._loader.onload = function() {
						this.model.dom.backgroundDiv.style.backgroundImage = 'url("'+this.model.background.img+'")';
						this.model.dom.backgroundDiv.style.opacity = '1';
						this.model._loader = null;
					}
					this._loader.src = this.background.img;
				}
			}
		}.$bind(object);
				
		// Create our content div for the controls
		object.dom.contentDiv = document.createElement('div');
		$ui.addClass(object.dom.contentDiv, 'inner');
		object.dom.appendChild(object.dom.contentDiv);
		
		// content Property
		object._protected.content = object.content;
		Object.defineProperty(object, 'content', {
			get: function() {return this._protected.content;},
			set: function() {
				console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','content'));
			},
			configurable: false} 
		);
		
		// Implementing CoreContainerComponent Interface
		object._getControlListProperty = function() {
			return this.content;
		}.$bind(object);
		
		// Implementing CoreContainerComponent Interface
		object._getControlListDom = function() {
			return this.dom.contentDiv;
		}.$bind(object);
		
		// Create all the content
		if (object.content) {
			for (var i = 0; i < object.content.length; i++) {
				object._addComponent(object.content[i]);
			}
		}
		
		// Handle window pane resizes
		object._onwindowpaneresize = function() {
			// Set our width to that of our parent
			this.dom.style.width = '';
			this.dom.style.right = '0px';
		}.$bind(object);
		
		// Clean-up any listeners
		object._onbeforepop = function() {
			if (this.animated == true) {
				this.dom.style['-webkit-animation-delay'] = '';
				this.dom.style['-webkit-animation-name'] = 'ui-pane-slide-right';
			}
		}.$bind(object);
		
		// Initialize the screen
		object._initialize = function() {
			// Load the background if needed
			if (this.background) {
				this.setBackground(this.background);
			}
		}.$bind(object);
		
		return object.dom;
	}
}
// Initialize the toolkit extensions
function $ui_ExtendWS12() {
	// Add our control extensions
	$ui.addExtension(new UIExtension('Browser', $ui_Browser));	
	$ui.addExtension(new UIExtension('DialPad', $ui_DialPad));	
	$ui.addExtension(new UIExtension('Map', $ui_Map));	
	$ui.addExtension(new UIExtension('MediaPlayer', $ui_MediaPlayer));	
	$ui.addExtension(new UIExtension('ResponsiveLayout', $ui_ResponsiveLayout));
	$ui.addExtension(new UIExtension('MenuItem', $ui_MenuItem));
	$ui.addExtension(new UIExtension('RawContent', $ui_RawContent));
	$ui.addExtension(new UIExtension('Suspension', $ui_Suspension));

	// Screen Extensions
	$ui.addExtension(new UIExtension('OnlineScreen', $ui_OnlineScreen, $ui.UIExtensionType.SCREEN));	
	// Custom Tiles
	$ui.addExtension(new UIExtension('TileAcceleration', $ui_TileAcceleration));	
	$ui.addExtension(new UIExtension('TileBadge', $ui_TileBadge));	
	$ui.addExtension(new UIExtension('TileBraking', $ui_TileBraking));	
	$ui.addExtension(new UIExtension('TileDistance', $ui_TileDistance));
	$ui.addExtension(new UIExtension('TileFuel', $ui_TileFuel));
	$ui.addExtension(new UIExtension('TileIdle', $ui_TileIdle));
	$ui.addExtension(new UIExtension('TileIdleDetails', $ui_TileIdleDetails));
	$ui.addExtension(new UIExtension('TileMPG', $ui_TileMPG));
	$ui.addExtension(new UIExtension('TileProfile', $ui_TileProfile));
	$ui.addExtension(new UIExtension('TileRecord', $ui_TileRecord));
	$ui.addExtension(new UIExtension('TileTimer', $ui_TileTimer));
	$ui.addExtension(new UIExtension('TileTimeDonut', $ui_TileTimeDonut));
	$ui.addExtension(new UIExtension('TileTimeHistory', $ui_TileTimeHistory));
	$ui.addExtension(new UIExtension('TileDynoChart', $ui_TileDynoChart));
	$ui.addExtension(new UIExtension('TileDriftAngle', $ui_TileDriftAngle));
	$ui.addExtension(new UIExtension('TileLateralGs', $ui_TileLateralGs));
	
	// Add our list item extensions
	def = { 
		/**
		 * Event type of an event raised from a {@link $ui.GenericListItem} 
		 * @namespace PhoneLogListEvent
		 * @readonly
		 * @memberof $ui.PhoneLogListItem
		 */
		PhoneLogListEvent: {
			/** Click of a generic list item 
			* @memberof $ui.PhoneLogListItem.PhoneLogListEvent
			*/
			ONCLICK:'onclick' 
		},
		/**
		 * Event type of an event raised from a {@link $ui.GenericListItem} 
		 * @namespace PhoneLogStyle
		 * @readonly
		 * @memberof $ui.PhoneLogListItem
		 */
		PhoneLogStyle: {
			/** Incoming Call
			* @memberof $ui.PhoneLogListItem.PhoneLogStyle
			*/
			INCOMING: 'incoming',
			/** Outgoing Call
			* @memberof $ui.PhoneLogListItem.PhoneLogStyle
			*/
			OUTGOING: 'outgoing',
			/** Missed Call
			* @memberof $ui.PhoneLogListItem.PhoneLogStyle
			*/
			MISSED: 'missed'
		}
	};
	$ui.addExtension(new UIExtension('PhoneLogListItem', $ui_PhoneLogListItem, $ui.UIExtensionType.LISTITEM, def));
	// Add our list item extensions
	def = { 
		/**
		 * Event type of an event raised from a {@link $ui.ColorListItem} 
		 * @namespace ColorListEvent
		 * @readonly
		 * @memberof $ui.ColorListItem
		 */
		ColorListEvent: {
			/** Click of a generic list item 
			* @memberof $ui.ColorListItem.ColorListEvent
			*/
			ONCLICK:'onclick' 
		}
	};
	$ui.addExtension(new UIExtension('ColorListItem', $ui_ColorListItem, $ui.UIExtensionType.LISTITEM, def));
	def = { 
		/**
		 * Event type of an event raised from a {@link $ui.SuspensionListItem} 
		 * @namespace SuspensionListEvent
		 * @readonly
		 * @memberof $ui.SuspensionListItem
		 */
		SuspensionListEvent: {
			/** Click of a generic list item 
			* @memberof $ui.SuspensionListItem.SuspensionListEvent
			*/
			ONCLICK:'onclick' 
		}
	};
	$ui.addExtension(new UIExtension('SuspensionListItem', $ui_SuspensionListItem, $ui.UIExtensionType.LISTITEM, def));
	$ui.addExtension(new UIExtension('PostListItem', $ui_PostListItem, $ui.UIExtensionType.LISTITEM));
}
// Register right away and don't use the extend() function so that all of our 
// components are defined as soon as the toolkit javascript loads in the browser
$ui_ExtendWS12();
/**
 * DataEvent class allows you to create an event that can be passed over the global event handler.
 * @class DataEvent
 * @memberof $ui
 * @param {number} id - Identifier for the event being raised
 * @param {object} data - The data to be passed with the event
 */
$ui.DataEvent = function(id, data) {
	/**
	* Numeric identifier for the event 
	* @name id
	* @type {number}
	* @memberof $ui.DataEvent
	*/
	if (id == undefined || id == null) throw 'DataEvent - The identifier "id" must be supplied';
	this.id = id;
	/**
	* Data payload for the event 
	* @name data
	* @type {object}
	* @memberof $ui.DataEvent
	*/
	this.data = data;
}

/**
 * The callback signature for the <i>addEventListner</i> function from {@link $ui}
 * @callback TriggeredEvent
 * @param {$ui.DataEvent} event - The event which was just received
 */
/**
 * @preserve FastClick: polyfill to remove click delays on browsers with touch UIs.
 *
 * @version 1.0.0
 * @codingstandard ftlabs-jsv2
 * @copyright The Financial Times Limited [All Rights Reserved]
 * @license MIT License (see LICENSE.txt)
 */

/*jslint browser:true, node:true*/
/*global define, Event, Node*/


/**
 * Instantiate fast-clicking listeners on the specificed layer.
 *
 * @constructor
 * @param {Element} layer The layer to listen on
 * @param {Object} options The options to override the defaults
 */
function FastClick(layer, options) {
	'use strict';
	var oldOnClick;

	options = options || {};

	/**
	 * Whether a click is currently being tracked.
	 *
	 * @type boolean
	 */
	this.trackingClick = false;


	/**
	 * Timestamp for when click tracking started.
	 *
	 * @type number
	 */
	this.trackingClickStart = 0;


	/**
	 * The element being tracked for a click.
	 *
	 * @type EventTarget
	 */
	this.targetElement = null;


	/**
	 * X-coordinate of touch start event.
	 *
	 * @type number
	 */
	this.touchStartX = 0;


	/**
	 * Y-coordinate of touch start event.
	 *
	 * @type number
	 */
	this.touchStartY = 0;


	/**
	 * ID of the last touch, retrieved from Touch.identifier.
	 *
	 * @type number
	 */
	this.lastTouchIdentifier = 0;


	/**
	 * Touchmove boundary, beyond which a click will be cancelled.
	 *
	 * @type number
	 */
	this.touchBoundary = options.touchBoundary || 10;


	/**
	 * The FastClick layer.
	 *
	 * @type Element
	 */
	this.layer = layer;
	
	/**
	 * The minimum time between tap(touchstart and touchend) events
	 * 
	 * @type number
	 */
	this.tapDelay = options.tapDelay || 200;

	if (FastClick.notNeeded(layer)) {
		return;
	}

	// Some old versions of Android don't have Function.prototype.bind
	function bind(method, context) {
		return function() { return method.apply(context, arguments); };
	}

	// Set up event handlers as required
	if (deviceIsAndroid) {
		layer.addEventListener('mouseover', bind(this.onMouse, this), true);
		layer.addEventListener('mousedown', bind(this.onMouse, this), true);
		layer.addEventListener('mouseup', bind(this.onMouse, this), true);
	}

	layer.addEventListener('click', bind(this.onClick, this), true);
	layer.addEventListener('touchstart', bind(this.onTouchStart, this), false);
	layer.addEventListener('touchmove', bind(this.onTouchMove, this), false);
	layer.addEventListener('touchend', bind(this.onTouchEnd, this), false);
	layer.addEventListener('touchcancel', bind(this.onTouchCancel, this), false);

	// Hack is required for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
	// which is how FastClick normally stops click events bubbling to callbacks registered on the FastClick
	// layer when they are cancelled.
	if (!Event.prototype.stopImmediatePropagation) {
		layer.removeEventListener = function(type, callback, capture) {
			var rmv = Node.prototype.removeEventListener;
			if (type === 'click') {
				rmv.call(layer, type, callback.hijacked || callback, capture);
			} else {
				rmv.call(layer, type, callback, capture);
			}
		};

		layer.addEventListener = function(type, callback, capture) {
			var adv = Node.prototype.addEventListener;
			if (type === 'click') {
				adv.call(layer, type, callback.hijacked || (callback.hijacked = function(event) {
					if (!event.propagationStopped) {
						callback(event);
					}
				}), capture);
			} else {
				adv.call(layer, type, callback, capture);
			}
		};
	}

	// If a handler is already declared in the element's onclick attribute, it will be fired before
	// FastClick's onClick handler. Fix this by pulling out the user-defined handler function and
	// adding it as listener.
	if (typeof layer.onclick === 'function') {

		// Android browser on at least 3.2 requires a new reference to the function in layer.onclick
		// - the old one won't work if passed to addEventListener directly.
		oldOnClick = layer.onclick;
		layer.addEventListener('click', function(event) {
			oldOnClick(event);
		}, false);
		layer.onclick = null;
	}
}


/**
 * Android requires exceptions.
 *
 * @type boolean
 */
var deviceIsAndroid = navigator.userAgent.indexOf('Android') > 0;


/**
 * iOS requires exceptions.
 *
 * @type boolean
 */
var deviceIsIOS = /iP(ad|hone|od)/.test(navigator.userAgent);


/**
 * iOS 4 requires an exception for select elements.
 *
 * @type boolean
 */
var deviceIsIOS4 = deviceIsIOS && (/OS 4_\d(_\d)?/).test(navigator.userAgent);


/**
 * iOS 6.0(+?) requires the target element to be manually derived
 *
 * @type boolean
 */
var deviceIsIOSWithBadTarget = deviceIsIOS && (/OS ([6-9]|\d{2})_\d/).test(navigator.userAgent);


/**
 * Determine whether a given element requires a native click.
 *
 * @param {EventTarget|Element} target Target DOM element
 * @returns {boolean} Returns true if the element needs a native click
 */
FastClick.prototype.needsClick = function(target) {
	'use strict';
	switch (target.nodeName.toLowerCase()) {

	// Don't send a synthetic click to disabled inputs (issue #62)
	case 'button':
	case 'select':
	case 'textarea':
		if (target.disabled) {
			return true;
		}

		break;
	case 'input':

		// File inputs need real clicks on iOS 6 due to a browser bug (issue #68)
		if ((deviceIsIOS && target.type === 'file') || target.disabled) {
			return true;
		}

		break;
	case 'label':
	case 'video':
		return true;
	}

	return (/\bneedsclick\b/).test(target.className);
};


/**
 * Determine whether a given element requires a call to focus to simulate click into element.
 *
 * @param {EventTarget|Element} target Target DOM element
 * @returns {boolean} Returns true if the element requires a call to focus to simulate native click.
 */
FastClick.prototype.needsFocus = function(target) {
	'use strict';
	switch (target.nodeName.toLowerCase()) {
	case 'textarea':
		return true;
	case 'select':
		return !deviceIsAndroid;
	case 'input':
		switch (target.type) {
		case 'button':
		case 'checkbox':
		case 'file':
		case 'image':
		case 'radio':
		case 'submit':
			return false;
		}

		// No point in attempting to focus disabled inputs
		return !target.disabled && !target.readOnly;
	default:
		return (/\bneedsfocus\b/).test(target.className);
	}
};


/**
 * Send a click event to the specified element.
 *
 * @param {EventTarget|Element} targetElement
 * @param {Event} event
 */
FastClick.prototype.sendClick = function(targetElement, event) {
	'use strict';
	var clickEvent, touch;

	// On some Android devices activeElement needs to be blurred otherwise the synthetic click will have no effect (#24)
	if (document.activeElement && document.activeElement !== targetElement) {
		document.activeElement.blur();
	}

	touch = event.changedTouches[0];

	// Synthesise a click event, with an extra attribute so it can be tracked
	clickEvent = document.createEvent('MouseEvents');
	clickEvent.initMouseEvent(this.determineEventType(targetElement), true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null);
	clickEvent.forwardedTouchEvent = true;
	targetElement.dispatchEvent(clickEvent);
};

FastClick.prototype.determineEventType = function(targetElement) {
	'use strict';

	//Issue #159: Android Chrome Select Box does not open with a synthetic click event
	if (deviceIsAndroid && targetElement.tagName.toLowerCase() === 'select') {
		return 'mousedown';
	}

	return 'click';
};


/**
 * @param {EventTarget|Element} targetElement
 */
FastClick.prototype.focus = function(targetElement) {
	'use strict';
	var length;

	// Issue #160: on iOS 7, some input elements (e.g. date datetime) throw a vague TypeError on setSelectionRange. These elements don't have an integer value for the selectionStart and selectionEnd properties, but unfortunately that can't be used for detection because accessing the properties also throws a TypeError. Just check the type instead. Filed as Apple bug #15122724.
	if (deviceIsIOS && targetElement.setSelectionRange && targetElement.type.indexOf('date') !== 0 && targetElement.type !== 'time') {
		length = targetElement.value.length;
		targetElement.setSelectionRange(length, length);
	} else {
		targetElement.focus();
	}
};


/**
 * Check whether the given target element is a child of a scrollable layer and if so, set a flag on it.
 *
 * @param {EventTarget|Element} targetElement
 */
FastClick.prototype.updateScrollParent = function(targetElement) {
	'use strict';
	var scrollParent, parentElement;

	scrollParent = targetElement.fastClickScrollParent;

	// Attempt to discover whether the target element is contained within a scrollable layer. Re-check if the
	// target element was moved to another parent.
	if (!scrollParent || !scrollParent.contains(targetElement)) {
		parentElement = targetElement;
		do {
			if (parentElement.scrollHeight > parentElement.offsetHeight) {
				scrollParent = parentElement;
				targetElement.fastClickScrollParent = parentElement;
				break;
			}

			parentElement = parentElement.parentElement;
		} while (parentElement);
	}

	// Always update the scroll top tracker if possible.
	if (scrollParent) {
		scrollParent.fastClickLastScrollTop = scrollParent.scrollTop;
	}
};


/**
 * @param {EventTarget} targetElement
 * @returns {Element|EventTarget}
 */
FastClick.prototype.getTargetElementFromEventTarget = function(eventTarget) {
	'use strict';

	// On some older browsers (notably Safari on iOS 4.1 - see issue #56) the event target may be a text node.
	if (eventTarget.nodeType === Node.TEXT_NODE) {
		return eventTarget.parentNode;
	}

	return eventTarget;
};


/**
 * On touch start, record the position and scroll offset.
 *
 * @param {Event} event
 * @returns {boolean}
 */
FastClick.prototype.onTouchStart = function(event) {
	'use strict';
	var targetElement, touch, selection;
	
	// Ignore multiple touches, otherwise pinch-to-zoom is prevented if both fingers are on the FastClick element (issue #111).
	if (event.targetTouches.length > 1) {
		return true;
	}

	targetElement = this.getTargetElementFromEventTarget(event.target);
	touch = event.targetTouches[0];

	
	
	if (deviceIsIOS) {

		// Only trusted events will deselect text on iOS (issue #49)
		selection = window.getSelection();
		if (selection.rangeCount && !selection.isCollapsed) {
			return true;
		}

		if (!deviceIsIOS4 && soloUI.isPhoneGap === true) {

			// Weird things happen on iOS when an alert or confirm dialog is opened from a click event callback (issue #23):
			// when the user next taps anywhere else on the page, new touchstart and touchend events are dispatched
			// with the same identifier as the touch event that previously triggered the click that triggered the alert.
			// Sadly, there is an issue on iOS 4 that causes some normal touch events to have the same identifier as an
			// immediately preceeding touch event (issue #52), so this fix is unavailable on that platform.
			if (touch.identifier === this.lastTouchIdentifier) {
				event.preventDefault();
				return false;
			}

			this.lastTouchIdentifier = touch.identifier;

			// If the target element is a child of a scrollable layer (using -webkit-overflow-scrolling: touch) and:
			// 1) the user does a fling scroll on the scrollable layer
			// 2) the user stops the fling scroll with another tap
			// then the event.target of the last 'touchend' event will be the element that was under the user's finger
			// when the fling scroll was started, causing FastClick to send a click event to that layer - unless a check
			// is made to ensure that a parent layer was not scrolled before sending a synthetic click (issue #42).
			this.updateScrollParent(targetElement);
		}
	}

	this.trackingClick = true;
	this.trackingClickStart = event.timeStamp;
	this.targetElement = targetElement;

	this.touchStartX = touch.pageX;
	this.touchStartY = touch.pageY;

	// Prevent phantom clicks on fast double-tap (issue #36)
	if ((event.timeStamp - this.lastClickTime) < this.tapDelay) {
		event.preventDefault();
	}
	
	return true;
};


/**
 * Based on a touchmove event object, check whether the touch has moved past a boundary since it started.
 *
 * @param {Event} event
 * @returns {boolean}
 */
FastClick.prototype.touchHasMoved = function(event) {
	'use strict';
	var touch = event.changedTouches[0], boundary = this.touchBoundary;

	if (Math.abs(touch.pageX - this.touchStartX) > boundary || Math.abs(touch.pageY - this.touchStartY) > boundary) {
		return true;
	}

	return false;
};


/**
 * Update the last position.
 *
 * @param {Event} event
 * @returns {boolean}
 */
FastClick.prototype.onTouchMove = function(event) {
	'use strict';
	
	if (!this.trackingClick) {
		return true;
	}

	// If the touch has moved, cancel the click tracking
	if (this.targetElement !== this.getTargetElementFromEventTarget(event.target) || this.touchHasMoved(event)) {
		this.trackingClick = false;
		this.targetElement = null;
	}
	
	
	
	return true;
};


/**
 * Attempt to find the labelled control for the given label element.
 *
 * @param {EventTarget|HTMLLabelElement} labelElement
 * @returns {Element|null}
 */
FastClick.prototype.findControl = function(labelElement) {
	'use strict';

	// Fast path for newer browsers supporting the HTML5 control attribute
	if (labelElement.control !== undefined) {
		return labelElement.control;
	}

	// All browsers under test that support touch events also support the HTML5 htmlFor attribute
	if (labelElement.htmlFor) {
		return document.getElementById(labelElement.htmlFor);
	}

	// If no for attribute exists, attempt to retrieve the first labellable descendant element
	// the list of which is defined here: http://www.w3.org/TR/html5/forms.html#category-label
	return labelElement.querySelector('button, input:not([type=hidden]), keygen, meter, output, progress, select, textarea');
};


/**
 * On touch end, determine whether to send a click event at once.
 *
 * @param {Event} event
 * @returns {boolean}
 */
FastClick.prototype.onTouchEnd = function(event) {
	'use strict';
	var forElement, trackingClickStart, targetTagName, scrollParent, touch, targetElement = this.targetElement;

	if (!this.trackingClick) {
		return true;
	}

	// Prevent phantom clicks on fast double-tap (issue #36)
	if ((event.timeStamp - this.lastClickTime) < this.tapDelay) {
		this.cancelNextClick = true;
		return true;
	}

	// Reset to prevent wrong click cancel on input (issue #156).
	this.cancelNextClick = false;

	this.lastClickTime = event.timeStamp;

	trackingClickStart = this.trackingClickStart;
	this.trackingClick = false;
	this.trackingClickStart = 0;

	
	// On some iOS devices, the targetElement supplied with the event is invalid if the layer
	// is performing a transition or scroll, and has to be re-detected manually. Note that
	// for this to function correctly, it must be called *after* the event target is checked!
	// See issue #57; also filed as rdar://13048589 .
	if (deviceIsIOSWithBadTarget) {
		touch = event.changedTouches[0];
		// In certain cases arguments of elementFromPoint can be negative, so prevent setting targetElement to null
		targetElement = document.elementFromPoint(touch.pageX - window.pageXOffset, touch.pageY - window.pageYOffset) || targetElement;
		targetElement.fastClickScrollParent = this.targetElement.fastClickScrollParent;
	}

	targetTagName = targetElement.tagName.toLowerCase();
	if (targetTagName === 'label') {
		forElement = this.findControl(targetElement);
		if (forElement) {
			this.focus(targetElement);
			if (deviceIsAndroid) {
				return false;
			}

			targetElement = forElement;
		}
	} else if (this.needsFocus(targetElement)) {

		// Case 1: If the touch started a while ago (best guess is 100ms based on tests for issue #36) then focus will be triggered anyway. Return early and unset the target element reference so that the subsequent click will be allowed through.
		// Case 2: Without this exception for input elements tapped when the document is contained in an iframe, then any inputted text won't be visible even though the value attribute is updated as the user types (issue #37).
		if ((event.timeStamp - trackingClickStart) > 100 || (deviceIsIOS && window.top !== window && targetTagName === 'input')) {
			this.targetElement = null;
			return false;
		}

		this.focus(targetElement);
		this.sendClick(targetElement, event);

		// Select elements need the event to go through on iOS 4, otherwise the selector menu won't open.
		if (!deviceIsIOS4 || targetTagName !== 'select') {
			this.targetElement = null;
			event.preventDefault();
		}

		return false;
	}

	if (deviceIsIOS && !deviceIsIOS4) {

		// Don't send a synthetic click event if the target element is contained within a parent layer that was scrolled
		// and this tap is being used to stop the scrolling (usually initiated by a fling - issue #42).
		scrollParent = targetElement.fastClickScrollParent;
		if (scrollParent && scrollParent.fastClickLastScrollTop !== scrollParent.scrollTop) {
			return true;
		}
	}
	

	// Prevent the actual click from going though - unless the target node is marked as requiring
	// real clicks or if it is in the whitelist in which case only non-programmatic clicks are permitted.
	if (!this.needsClick(targetElement)) {
		event.preventDefault();
		this.sendClick(targetElement, event);
	}

	return false;
};


/**
 * On touch cancel, stop tracking the click.
 *
 * @returns {void}
 */
FastClick.prototype.onTouchCancel = function() {
	'use strict';
	
	this.trackingClick = false;
	this.targetElement = null;
};


/**
 * Determine mouse events which should be permitted.
 *
 * @param {Event} event
 * @returns {boolean}
 */
FastClick.prototype.onMouse = function(event) {
	'use strict';

	// If a target element was never set (because a touch event was never fired) allow the event
	if (!this.targetElement) {
		return true;
	}

	if (event.forwardedTouchEvent) {
		return true;
	}

	// Programmatically generated events targeting a specific element should be permitted
	if (!event.cancelable) {
		return true;
	}

	// Derive and check the target element to see whether the mouse event needs to be permitted;
	// unless explicitly enabled, prevent non-touch click events from triggering actions,
	// to prevent ghost/doubleclicks.
	if (!this.needsClick(this.targetElement) || this.cancelNextClick) {

		// Prevent any user-added listeners declared on FastClick element from being fired.
		if (event.stopImmediatePropagation) {
			event.stopImmediatePropagation();
		} else {

			// Part of the hack for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
			event.propagationStopped = true;
		}

		// Cancel the event
		event.stopPropagation();
		event.preventDefault();

		return false;
	}

	// If the mouse event is permitted, return true for the action to go through.
	return true;
};


/**
 * On actual clicks, determine whether this is a touch-generated click, a click action occurring
 * naturally after a delay after a touch (which needs to be cancelled to avoid duplication), or
 * an actual click which should be permitted.
 *
 * @param {Event} event
 * @returns {boolean}
 */
FastClick.prototype.onClick = function(event) {
	'use strict';
	var permitted;

	// It's possible for another FastClick-like library delivered with third-party code to fire a click event before FastClick does (issue #44). In that case, set the click-tracking flag back to false and return early. This will cause onTouchEnd to return early.
	if (this.trackingClick) {
		this.targetElement = null;
		this.trackingClick = false;
		return true;
	}

	// Very odd behaviour on iOS (issue #18): if a submit element is present inside a form and the user hits enter in the iOS simulator or clicks the Go button on the pop-up OS keyboard the a kind of 'fake' click event will be triggered with the submit-type input element as the target.
	if (event.target.type === 'submit' && event.detail === 0) {
		return true;
	}

	permitted = this.onMouse(event);

	// Only unset targetElement if the click is not permitted. This will ensure that the check for !targetElement in onMouse fails and the browser's click doesn't go through.
	if (!permitted) {
		this.targetElement = null;
	}

	// If clicks are permitted, return true for the action to go through.
	return permitted;
};


/**
 * Remove all FastClick's event listeners.
 *
 * @returns {void}
 */
FastClick.prototype.destroy = function() {
	'use strict';
	var layer = this.layer;

	if (deviceIsAndroid) {
		layer.removeEventListener('mouseover', this.onMouse, true);
		layer.removeEventListener('mousedown', this.onMouse, true);
		layer.removeEventListener('mouseup', this.onMouse, true);
	}

	layer.removeEventListener('click', this.onClick, true);
	layer.removeEventListener('touchstart', this.onTouchStart, false);
	layer.removeEventListener('touchmove', this.onTouchMove, false);
	layer.removeEventListener('touchend', this.onTouchEnd, false);
	layer.removeEventListener('touchcancel', this.onTouchCancel, false);
};


/**
 * Check whether FastClick is needed.
 *
 * @param {Element} layer The layer to listen on
 */
FastClick.notNeeded = function(layer) {
	'use strict';
	var metaViewport;
	var chromeVersion;

	// Devices that don't support touch don't need FastClick
	if (typeof window.ontouchstart === 'undefined') {
		return true;
	}

	// Chrome version - zero for other browsers
	chromeVersion = +(/Chrome\/([0-9]+)/.exec(navigator.userAgent) || [,0])[1];

	if (chromeVersion) {

		if (deviceIsAndroid) {
			metaViewport = document.querySelector('meta[name=viewport]');

			if (metaViewport) {
				// Chrome on Android with user-scalable="no" doesn't need FastClick (issue #89)
				if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
					return true;
				}
				// Chrome 32 and above with width=device-width or less don't need FastClick
				if (chromeVersion > 31 && window.innerWidth <= window.screen.width) {
					return true;
				}
			}

		// Chrome desktop doesn't need FastClick (issue #15)
		} else {
			return true;
		}
	}

	// IE10 with -ms-touch-action: none, which disables double-tap-to-zoom (issue #97)
	if (layer.style.msTouchAction === 'none') {
		return true;
	}

	return false;
};


/**
 * Factory method for creating a FastClick object
 *
 * @param {Element} layer The layer to listen on
 * @param {Object} options The options to override the defaults
 */
FastClick.attach = function(layer, options) {
	'use strict';
	return new FastClick(layer, options);
};


if (typeof define !== 'undefined' && define.amd) {

	// AMD. Register as an anonymous module.
	define(function() {
		'use strict';
		return FastClick;
	});
} else if (typeof module !== 'undefined' && module.exports) {
	module.exports = FastClick.attach;
	module.exports.FastClick = FastClick;
} else {
	window.FastClick = FastClick;
}
/**
 * Every component in the UI follows the same general patterns. This is to keep consistency and make coding easier.
 * <br><br><b>NOTE: The core component is an abstract base class and cannot be created as an instance on its own</b>
 * @namespace
 * @name CoreComponent
 * @memberof $ui
 * @property {namespace} component - The <b>mandatory</b> component property defines what type of component is being defined. This property always starts with a <b>$ui.</b> defining the component to be used for generating the UI.
 * @property {string} [id] - The id property is used to uniquely define the control in the screen for which it belongs. <br><br>Providing an id for your control is very convenient because you can easily access your control through your javascript coding. Each id is added as a direct handle on the screen object for access.
 * @property {boolean} [animated=false] - Set this value to <b>true</b> for the control to have animation.  NOTE: Each derivative control is responsible for their animation styling. Setting this property to true will add the ".animated" CSS class to the root element of the control.  Feel free to define your own CSS for the ".animated" property
 * @property {boolean} [visible=true] - The visible property specifies the visibility of the control. 
 * @property {boolean} [enabled=true] - The enabled property specifies the initial enabled state of the control.  <i>NOTE: Not all controls will render a disabled state. If you wish to render a disabled state simply override the ".disabled" CSS for the root of your control</i>
 * @property {$ui.CoreScreen} screen - This <b>readonly</b> property allows for you to reference the screen from the control. This will be the screen in which the control is embedded
 * @property {$ui.DataProviderLink} [provider] - This property allows you to bind the control to a [data provider]{@link $ui.DataProvider} in the application. 
 * @property {object[]} attachedObjects - This property specifies an array of objects that can be attached to the control. These could be objects such as data providers and usually entail a component that does not provide a user interface.
 * @property {boolean} [marginTop=false] - A boolean property which when set to true will place a standard margin on the top of the control. 
 * @property {boolean} [marginBottom=false] - A boolean property which when set to true will place a standard margin on the bottom of the control.
 * @property {boolean} [marginLeft=false] - A boolean property which when set to true will place a standard margin on the left of the control
 * @property {boolean} [marginRight=false] - A boolean property which when set to true will place a standard margin on the right of the control.
 */
function $ui_CoreComponent(object, screen) {
	try {
	if (object) {
		this.object = object;
		// The protected object is where we store our dynamic object variables
		object._protected = {
			model: object
		};
		
		// Create our base container for the control 
		object.dom = document.createElement('div');
		object.dom.model = object;
		$ui.addClass(object.dom, 'ui-core-component');
		
		// Assign our control name for automation & analytics
		if (object.id) {
			object.dom.setAttribute('data-id',object.id);
		}
		
		// Component Property
		object._protected.component = object.component;
		Object.defineProperty(object, 'component', {
			get: function() {return this._protected.component;},
			set: function() {
				console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','component'));
			},
			configurable: false} 
		);
		
		// Screen Property
		if (screen != undefined) {
			object.screen = screen;
			screen.children.push(object);
			if (object.id) {
        if (screen[object.id] != undefined) {
          var text = 'WARNING: You have used a non-unique id: "'+ object.id+'"';
          if (screen.id != undefined) {
            text = text + ' on screen "'+screen.id+'"';
          }
          console.log(text);
        }
				screen[object.id] = object;
			}
		}
		object._protected.screen = object.screen;
		Object.defineProperty(object, 'screen', {
			get: function() {return this._protected.screen;},
			set: function() {
				console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','screen'));
			},
			configurable: false}
		);
		
		// id property
		object._protected.id = object.id;
		Object.defineProperty(object, 'id', {
			get: function() {return this._protected.id;},
			set: function() {
				console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','id'));
			},
			configurable: false}
		);
		
		// Enabled Property
		if (object.enabled != false) {
			object.enabled = true;
		} else {
			$ui.addClass(object.dom, 'disabled');
		}
		object._protected.enabled = object.enabled;
		Object.defineProperty(object, 'enabled', {
			get: function() {return this._protected.enabled;},
			set: function(value) {
				if (value == this._protected.enabled) return;
				if (this._protected.enabled && (value == false)) {
					this._protected.enabled = false;
					$ui.addClass(this.dom, 'disabled');
				} else if ((this._protected.enabled == false) && (value == true)) {
					this._protected.enabled = true;
					$ui.removeClass(this.dom, 'disabled');
				}
				// Call a child class' protected function if they need
				// to do special handling for enabling
				if (this._setEnabled) {
					this._setEnabled(value);
				}
			},
			configurable: false}
		);		

		
		// Animated property
		if (object.animated == true) {
			$ui.addClass(object.dom, 'animated');
		} else {
			object.animated = false;
		}
		object._protected.animated = object.animated;
		Object.defineProperty(object, 'animated', {
			get: function() {return this._protected.animated;},
			set: function() {
				console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','animated'));
			},
			configurable: false}
		);
		
		// Set our initial visibility
		if ((object.visible != undefined) && (object.visible == false)) {
			object.dom.style.display = 'none';
		} else {
			object.visible = true;
		}
		object._protected.visible = object.visible;
		// Set our modification rules for 'visible'
		Object.defineProperty(object, 'visible', {
			get: function() {return this._protected.visible;},
			set: function(value) {
				if (value != this._protected.visible) {
					if (value == true) {
						this._protected.visible = true;
						if (this.dom != undefined) {
							this.dom.style.display = '';
						}
					} else {
						this._protected.visible = false;
						if (this.dom != undefined) {
							this.dom.style.display = 'none';
						}
					}
					// Allow of the top level control to also react to the visibility change
					if (this._setVisible) {
						this._setVisible(value);
					}
				} 
			},
			configurable: false}
		);
		
		// Attached Objects Property
		if (object.attachedObjects) {
			var i,
        j,
				control,
        extension,
				controlDom,
				targetScreen = (object.screen != undefined) ? object.screen : object; // The only control without a screen is a screen
			for (i = 0; i < object.attachedObjects.length; i++) {
				control = object.attachedObjects[i];
        if (control == undefined) {
    			throw 'CoreComponent.attachedObject: "control" is not defined';
    		} 
    		if (targetScreen == undefined) {
    			throw 'CoreComponent.attachedObject: "screen" is not defined';
    		}
    		// Find and create the attached object extension
    		for (j = 0; j < $ui._protected.definitions.length; j++) {
    			extension = $ui._protected.definitions[j];
    			if (extension.type != $ui.UIExtensionType.ATTACHED_OBJECT) continue;
    			if (extension.component == control.component) {
    				controlDom = new extension.constructor(control, object, targetScreen);
    				break;
    			}
    		}
				// If this control needs to be in the DOM add it
				if (controlDom instanceof HTMLElement) {
					object.dom.appendChild(controlDom);
				}
			}
		} else {
			object.attachedObjects = [];
		}
		object._protected.attachedObjects = object.attachedObjects;
		Object.defineProperty(object, 'attachedObjects', {
			get: function() {return this._protected.attachedObjects;},
			set: function(value) {
				console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','attachedObjects'));
			},
			configurable: false}
		);
		
		/** 
		 * This protected function will raise an interaction event for the <b>oninteraction</b> callback assigned to the {@link $ui} object.
		 * @memberof $ui.CoreComponent
		 * @protected 
		 * @function _raiseInteractionEvent
		 * @param {string} interaction - Desired interaction to raise
		 */
		object._raiseInteractionEvent = function(interaction) {
			var event = new InteractionEvent(this.screen.id, this.id, interaction, this.component);
			$ui._raiseInteractionEvent(event);
		}.$bind(object);
		
		
		// Private function to animate scrolling the control into view 
		object._scrollIntoView = function() {
			var step = 20,
				rect = this.dom.getBoundingClientRect(),
				scrollArea = this.dom.parentNode;
				
			this._scrollIterationCounter = this._scrollIterationCounter + 1;
			// See if it has reached the top of the screen
			if (rect.top == scrollArea.offsetTop) { 
				return;
			}
			
			// If the bottom and top of the control is visible
			if ((rect.bottom < (scrollArea.offsetTop + scrollArea.offsetHeight)) && (rect.top > scrollArea.offsetTop)) {
				return;
			}
				
			if (rect.top > scrollArea.offsetTop) { // Need to scroll down
				if (rect.top - scrollArea.offsetTop < step) {
					step = 1;
				}
				scrollArea.scrollTop = scrollArea.scrollTop + step;
			} else { // Need to scroll up
				if (scrollArea.offsetTop - rect.top < step) {
					step = 1;
				}
				scrollArea.scrollTop = scrollArea.scrollTop - step;
			}
			
			if (this._scrollIterationCounter > 100) { // Equivalent to moving something 2000 pixels
				console.log('fail safe scroll counter exceeded');
				return;
			}
			requestAnimationFrame(this._scrollIntoView);
		}.$bind(object);
		
		/** 
		 * This function will scroll the control into view for the user.
		 * @memberof $ui.CoreComponent
		 * @function scrollIntoView
		 */
		object.scrollIntoView = function() {
			if (this.dom) {
				this._scrollIterationCounter = 0;
				requestAnimationFrame(this._scrollIntoView);
			}
		}.$bind(object);
		
		// Public base destructor for the component
		object.destroy = function() {	
			// Call private destructor of control if it is there
			if (object._destroy) {
				object._destroy();
			}
			// Remove the provider listener
			if (this.provider != undefined) {
				if (this.provider.id != undefined) {
					window.removeEventListener(this.screen.guid+'-'+this.provider.id+'-updated', this._providerRefresh, false);
				}
			}	
      // Remove screen reference
      if (this.id != undefined && this.id.length > 0) {
				this.screen[this.id] = undefined;
			}
			// Clean-up any attached objects
			var i,
				attachedObject;
			if (this.attachedObjects && this.attachedObjects.length > 0) {
				for (i = 0; i < this.attachedObjects.length; i++) {
					attachedObject = this.attachedObjects[i];
					if (attachedObject._destroy) {
						attachedObject._destroy();
					}
				}
			}
			this.dom = undefined;
		}.$bind(object);
		
		// Handle a provider update
		object._providerRefresh = function() {
			// Find the data provider
			var dataProvider = this.screen[this.provider.id];
			if (dataProvider != undefined) {
				// Make sure it has some data assigned to it
				if (dataProvider.data != undefined) {
					var properties = this.provider.property.split('.'),
						i,
						data = dataProvider.data,
						found = true;
					// traverse it's hierarchy for our data value	
					for (i = 0; i < properties.length; i++) {
						data = data[properties[i]];
						if (data == undefined) {
							found = false;
							break;
						}
					}
					if (found) {
						if (this._providerUpdate) {
							this._providerUpdate(data);
						}
						return;
					} else {
						if (this._providerUpdate) {
							this._providerUpdate(undefined);
						}
					}
				} else {
					// If there was data we would not reach this point other wise it is undefined
					// so we have to check to see if it is an initial load so that we don't trigger 
					// the control's update unnecessarily 
					if (this._providerUpdate) {
						this._providerUpdate(undefined);
					}
				}
			} 
		}.$bind(object);
		
		
    // This function will remove the control from the screen
    object._remove = function() {
      if (this._onremove) {
        this._onremove();
      }
      // Remove node
      if (this.dom && this.dom.parentNode) {
        this.dom.parentNode.removeChild(this.dom);
      }
      if (this.screen) {
        var index = this.screen.children.indexOf(this);
        if (index >= 0) {
          this.screen.children.splice(index, 1);
        }
      }
      this.destroy();
    }.$bind(object);
    
		// This function will update the provider data source with new data from the control
		object._updateData = function(value) {
			// Find the data provider
			var dataProvider = (this.provider == undefined) ? undefined : this.screen[this.provider.id];
			if (dataProvider != undefined) {
				// Mark the property as updated
				dataProvider._propertyUpdated(this.provider.property, value);
				// Make sure it has some data assigned to it
				if (dataProvider.data != undefined) {
					var properties = this.provider.property.split('.'),
						i,
						data = dataProvider.data,
						currentValue;
					// traverse it's hierarchy for our data value	
					for (i = 0; i < properties.length; i++) {
						currentValue = data[properties[i]];
						if ((currentValue == undefined) && (i < (properties.length -1))) {
							break;
						} else if (i == (properties.length -1)) {
							data[properties[i]] = value;
							break;
						}
						data = currentValue;
					}
				}
			}
		}.$bind(object);
		
		// Data Provider Property
		if (object.provider != undefined) {
			if (object.provider.id != undefined) {
				// unique event listener for this provider on this screen
				window.addEventListener(object.screen.guid+'-'+object.provider.id+'-updated', object._providerRefresh, false);
				// Evaluate our bindings 
				object._providerRefresh();
			}
		}
		object._protected.provider = object.provider;
		Object.defineProperty(object, 'provider', {
			get: function() {return this._protected.provider;},
			set: function(value) {
				console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','provider'));
			},
			configurable: false}
		);
	}
	} catch (error) {
		console.log("RPW error in core component: " + error);
	}
}

/** 
 * The function assigned to this member will fire when the component has been asked to be removed from its parent. This is an <b>internal protected</b> member to be used by derivative controls and should not be bound to by application code
 * @name _onremove
 * @memberof $ui.CoreComponent
 * @protected
 * @type {function} 
 */

/** 
 * The function assigned to this member will fire when the screen the component belongs to receives an onshow event. This is an <b>internal protected</b> member to be used by derivative controls and should not be bound to by application code
 * @name _onshow
 * @memberof $ui.CoreComponent
 * @protected
 * @type {function} 
 */
 
 /** 
 * The function assigned to this member will fire when the toolkit has updated its theme. This is an <b>internal protected</b> member to be used by derivative controls and should not be bound to by application code
 * @name _onthemechange
 * @memberof $ui.CoreComponent
 * @protected
 * @type {function} 
 */

 
/** 
 * The function assigned to this member will fire when the screen that the component belongs to has it's viewport size changed. This is an <b>internal protected</b> member to be used by derivative controls and should not be bound to by application code
 * @name _onresize
 * @memberof $ui.CoreComponent
 * @protected
 * @type {function} 
 */

/** 
 * The function assigned to this member will fire when the screen that the component belongs to is just about to be popped. This will only fire if the screen is the top most screen in the stack. It allows for any clean-up that might need to be done before animating. This is an <b>internal protected</b> member to be used by derivative controls and should not be bound to by application code
 * @name _onbeforepop
 * @memberof $ui.CoreComponent
 * @protected
 * @type {function} 
 */

/**
 * This is the abstract base class that represents a component instance which contains other components. It derives from {@link $ui.CoreComponent}. 
 * <br><br><b>NOTE: This is an abstract class </b>
 * @namespace
 * @name CoreContainerComponent
 * @memberof $ui
 * @extends $ui.CoreComponent 
 * @property {boolean} [modified] - This property will cascade the <b>modified</b> value to all child controls contained in the control group <b>IF</b> the value is false.  Otherwise it will simply mark itself as modified.
 */
function $ui_CoreContainerComponent(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	if (object) {
		
		/**
		* Protected internal function for derivative controls to implement to return the control list array
		* @function _getControlListProperty
		* @memberof $ui.CoreContainerComponent
		* @returns {$ui.CoreComponent[]}
		* @protected
		*/
		
		/**
		* Protected internal function for derivative controls to implement to return the DOM element that contains the controls
		* @function _getControlListDom
		* @memberof $ui.CoreContainerComponent
		* @returns {HTMLElement}
		* @protected
		*/
		
		/**
		* Protected internal function for derivative controls to implement to react if there is a cascading of visibility
		* @function _oncascadevisibility
		* @memberof $ui.CoreContainerComponent
		* @protected
		*/
    
    /**
		* Protected internal function for derivative controls to implement to react to the results of the validation of the control
		* @function _onvalidate
    * @param {boolean} result
		* @memberof $ui.CoreContainerComponent
		* @protected
		*/
    
    /**
		* Protected internal function for derivative controls to implement to react to the change of the modified flag
		* @function _onmodified
		* @memberof $ui.CoreContainerComponent
		* @protected
		*/
		
		// modified property
		if (object.modified == undefined) {
			object.modified = false;
		} 
		object._protected.modified = object.modified;
		Object.defineProperty(object, 'modified', {
			get: function() {return this._protected.modified;},
			set: function(value) {
				if (value == undefined) value = false;
				this._protected.modified = value;
				if (this._getControlListProperty == undefined) {
					console.log('ERROR: _getControlListProperty not defined for CoreContainerComponent');
					return;
				}
        if (value == false) {
          var i,
  					control,
  					controlList = this._getControlListProperty();
  				for (i = 0; i < controlList.length; i++) {
  					control = controlList[i];
  					control.modified = value;
  				}
        }
        if (this._onmodified) {
          this._onmodified();
        }
			},
			configurable: false}
		);
		
		/** 
		 * Validate all the controls contained in this column (including nested controls) and return the boolean result
		 * @function validate
		 * @memberof $ui.CoreContainerComponent
		 * @returns {boolean}
		 */
		object.validate = function() {
			if (this._getControlListProperty == undefined) {
				console.log('ERROR: _getControlListProperty not defined for CoreContainerComponent');
				return false;
			}
			var i,
				control,
				controlList = this._getControlListProperty(),
				result = true;
			for (i = 0; i < controlList.length; i++) {
				control = controlList[i];
				if (control.validate)  {
					if (control.validate() == false) {
						result = false;
					}
				}
			}
      if (this._onvalidate) {
        this._onvalidate(result);
      }
			return result;
		}.$bind(object);
		
		// This function is called to cascade down a visibility change to child controls
		object._cascadeVisibility = function() {
			if (this._getControlListProperty == undefined) {
				console.log('ERROR: _getControlListProperty not defined for CoreContainerComponent');
				return;
			}
			var i,
				controlList = this._getControlListProperty(),
				control;			
			for (i = 0; i < controlList.length; i++) {
				control = controlList[i];
				if (control._cascadeVisibility) {
					control._cascadeVisibility();
				} else {
					if (control._onshow) {
						control._onshow();
					}
				}
			}
			if (this._oncascadevisibility) {
				this._oncascadevisibility();
			}
		}.$bind(object);
		
		
		// Internal function to create the component
		object._addComponent = function(control) {
			if (control == undefined) return;
			if (this._getControlListDom == undefined) {
				console.log('ERROR: _getControlListDom not defined for CoreContainerComponent');
				return;
			}
			var dom = this._getControlListDom();
			if (dom == undefined) {
				console.log('ERROR: _getControlListDom did not return a valid DOM element');
				return;
			}
			if (this.modified != undefined) {
				control.modified = this.modified;
			}
			$ui.createControl(control, this.screen);
			if (control.dom) {
				dom.appendChild(control.dom);
			}
		}.$bind(object);
		
		/** 
		 * Add a new control to the end of this container control
		 * @function addComponent
		 * @memberof $ui.CoreContainerComponent
		 * @param {$ui.CoreComponent} control - The control that you wish to add to the container control
		 */
		object.addComponent = function(control) {
			if (control == undefined) return;
			this._addComponent(control);
			if (this._getControlListProperty == undefined) {
				console.log('ERROR: _getControlListProperty not defined for CoreContainerComponent');
				return;
			}
			var list = this._getControlListProperty();
			if (list == undefined) {
				console.log('ERROR: _getControlListProperty did not return a valid object');
				return;
			}
			list.push(control);
			if (control._onshow) {
				control._onshow();
			}
			if (control.provider != undefined) {
				control._providerRefresh();
			}
		}.$bind(object);
		
		/** 
		 * Insert a new control into this container control before the targetControl
		 * @function insertComponentBefore
		 * @memberof $ui.CoreContainerComponent
		 * @param {$ui.CoreComponent} control - The control that you wish to insert to the container control
		 * @param {$ui.CoreComponent} targetControl - The target control that you wish to insert before 
		 */
		object.insertComponentBefore = function(control, targetControl) {
			if (control == undefined) return;
			if (targetControl == undefined) return;
			if (this._getControlListProperty == undefined) {
				console.log('ERROR: _getControlListProperty not defined for CoreContainerComponent');
				return;
			}
			var list = this._getControlListProperty();
			if (list == undefined) {
				console.log('ERROR: _getControlListProperty did not return a valid object');
				return;
			}
			if (this._getControlListDom == undefined) {
				console.log('ERROR: _getControlListDom not defined for CoreContainerComponent');
				return;
			}
			var dom = this._getControlListDom();
			if (dom == undefined) {
				console.log('ERROR: _getControlListDom did not return a valid DOM element');
				return;
			}
			// See if we can find the target control
			var i,
				item;
			for (i = 0; i < list.length; i++) {
				item = list[i];
				if (item == targetControl && item.dom && item.dom.parentNode) {
					if (this.modified != undefined) {
						control.modified = this.modified;
					}
					$ui.createControl(control, this.screen);
					if (control.dom) {
						item.dom.parentNode.insertBefore(control.dom, item.dom);
						list.splice(i, 0, control);
						if (control._onshow) {
							control._onshow();
						}
						if (control.provider != undefined) {
							control._providerRefresh();
						}
					}
					break;
				}
			}
			
			
		}.$bind(object);
		
		/** 
		 * Remove an existing control from this container control
		 * @function removeComponent
		 * @memberof $ui.CoreContainerComponent
		 * @param {$ui.CoreComponent} control - The control that you wish to remove from the screen
		 */
		object.removeComponent = function(control) {
			if (control == undefined) return;
			if (this._getControlListDom == undefined) {
				console.log('ERROR: _getControlListDom not defined for CoreContainerComponent');
				return;
			}
			if (this._getControlListProperty == undefined) {
				console.log('ERROR: _getControlListProperty not defined for CoreContainerComponent');
				return;
			}
			var dom = this._getControlListDom();
			if (dom == undefined) {
				console.log('ERROR: _getControlListDom did not return a valid DOM element');
				return;
			}
			var list = this._getControlListProperty();
			if (list == undefined) {
				console.log('ERROR: _getControlListProperty did not return a valid object');
				return;
			}
			var i,
				item;
			for (i = 0; i < list.length; i ++) {
				item = list[i];
				if (item == control) {
					list.splice(i,1);
          if (item.clearComponents) {
            item.clearComponents();
          }
          item._remove();
					break;
				}
			}
		}.$bind(object);
		
		/** 
		 * Remove all the child controls from this container control
		 * @function clearComponents
		 * @memberof $ui.CoreContainerComponent
		 */
		object.clearComponents = function() {
			if (this._getControlListProperty == undefined) {
				console.log('ERROR: _getControlListProperty not defined for CoreContainerComponent');
				return;
			}
			var list = this._getControlListProperty();
			if (list == undefined) {
				console.log('ERROR: _getControlListProperty did not return a valid object');
				return;
			}
			for (var i = list.length - 1; i >= 0; i--) {
				this.removeComponent(list[i]);
			}
				
		}.$bind(object);
		
		return object.dom;
	}
}
/**
 * This is the abstract base class that represents a screen instance. It derives from {@link $ui.CoreComponent}. 
 * A screen is declared as a JavaScript function and has various different properties. When a screen is pushed onto the stack a new instance of the screen will be created and rendered.<br><br>
 * If a derivative screen is using the <b>animated</b> property to animate a screen transition to show the screen, it must also provide a reverse animation effect within its <b>_onbeforepop</b> event.
 * <br><br><b>NOTE: This is an abstract class </b>
 * @namespace
 * @name CoreScreen
 * @memberof $ui
 * @extends $ui.CoreContainerComponent 
 * @property {GenericEvent} [onresize] - This event will fire when the viewport of the screen changes size
 * @property {boolean} [floatOnTop=false] - When set to <b>true</b> the screens below this screen will remain visible and have this screen float on top.
 * @property {DataEvent} [onshow] - This event will fire when the screen has been displayed
 * @property {DataEvent} [oncreate] - This event will when the screen has been initialized but has not yet been processed.  This allows you to make any changes to the screens properties before any of the controls are created.
 * @property {GenericEvent} [ondestroy] - This event will fire when the screen is about to be destroyed. Allowing for any memory clean-up routines
 * @property {GenericEvent} [onthemechange] - This event will fire when the theme for the toolkit has been updated
 * @property {CheckReadyStateEvent} [oncheckreadystate] - This event will fire when the screen is asked about its dirty state.  It allows the screen to manage its own state and can call the <b>readyCallback<b> function passed as a parameter when the screen is ready.  Being ready means that whomever asked about your state can be assured that everything is ok with the screen's state.
 */
function $ui_CoreScreen(object, data) {
	$ui_CoreContainerComponent.call(this, object);
	if (object) {
		object.data = data;
		object._protected.screen = object;
		// Guid Property
		object.guid = $ui.guid();
		object._protected.guid = object.guid;
		Object.defineProperty(object, 'guid', {
			get: function() {return this._protected.guid;},
			set: function() {
				console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','guid'));
			},
			configurable: false}
		);
		
		// floatOnTop Property
		if (object.floatOnTop != true) {
			object.floatOnTop = false;
		}
		object._protected.floatOnTop = object.floatOnTop;
		Object.defineProperty(object, 'floatOnTop', {
			get: function() {return this._protected.floatOnTop;},
			set: function() {
				console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','floatOnTop'));
			},
			configurable: false}
		);
		
		object.children = []; // Contains all child controls in the screen
		$ui.addClass(object.dom,'ui-core-screen');
		
		/**
		* Protected internal function for derivative screens to implement if they have specific functionality they wish to
		* do when the screen initializes.  This function will fire just before the <b>onshow</b> event is triggered for the screen.
		* @function _intitialize
		* @memberof $ui.CoreScreen
		* @protected
		*/
     
    /**
		* This function allows for querying the ready state of the screen which in turn will fire the <b>oncheckreadystate</b> event.  This can be useful when someone wishes to navigate away from the screen but a 
    * user has not yet saved their changes. It allows the screen to determine if it is safe to leave the screen or if some action needs to be handled.
		* @function checkReadyState
		* @memberof $ui.CoreScreen
		* @param {GenericEvent} readyCallback - Callback function to be fired when the screen is ready
    * @param {GenericEvent} [cancelCallback] - Callback function to be fired when the screen says that it is not ready
		*/
    object.checkReadyState = function(readyCallback, cancelCallback) {
      if (readyCallback == undefined) {
        console.log('ERROR: Cannot pass an undefined readyCallback to CoreScreen.checkReadyState()');
        return;
      }
      if (this.oncheckreadystate) {
        this.oncheckreadystate(readyCallback, cancelCallback);
      } else {
        readyCallback();
      }
    }.$bind(object);
		
		// Initialize the screen
		object.initialize = function() {
      this.dom.style['z-index'] = $ui.screens.length+1;
			$ui._protected.inScreenTransition = false;
			$ui._blockAllTapEvent(false);
			// See if there is an internal implementation of _initialize
			if (this._initialize) {
				this._initialize();
			}
			// Raise our onshow event
			if (this.onshow) {
				this.onshow(this.data);
			}
			// Fire the _onshow for all the controls
			var i,
				control;
			for (i = 0; i < this.children.length;i++) {
				control = this.children[i];
				if (control._onshow) {
					control._onshow();
				}
			}
      this._raiseInteractionEvent('data-interaction-screen-initialized');
		}.$bind(object);
		
		// Handle our internal update for theme changes
		object._onthemechange = function() {
			// Raise our onthemechange event
			if (this.onthemechange) {
				this.onthemechange();
			}
			// Fire the _onthemechange for all the controls
			var i,
				control;
			for (i = 0; i < this.children.length;i++) {
				control = this.children[i];
				if (control._onthemechange) {
					control._onthemechange();
				}
			}
		}.$bind(object);
		
		// Internal Resize event
		object._onresize = function() {
			// Fire the _onresize for all the controls
			var i,
				control;
			for (i = 0; i < this.children.length;i++) {
				control = this.children[i];
				if (control._onresize) {
					control._onresize();
				}
			}
		}.$bind(object);
		
		// Internal before pop event
		object.onbeforepop = function() {
			if (this._onbeforepop) {
				this._onbeforepop();
			}
			// Fire the _onbeforepop for all the controls
			var i,
				control;
			for (i = 0; i < this.children.length;i++) {
				control = this.children[i];
				if (control._onbeforepop) {
					control._onbeforepop();
				}
			}
		}.$bind(object);
		
		// Destroy screen
		object._destroy = function() {
			if (this.ondestroy) {
				this.ondestroy();
			}
			// Loop through all the children and call their destroy
			var i;
			for (i = 0; i < this.children.length; i++) {
				this.children[i].destroy();
			}
		}.$bind(object);
		
		return object.dom;
	}
}
/**
 * The DataEvent is used in a few places where an event needs to be fired an an optional data object passed to that event
 * @callback DataEvent
 * @param {object} [data] - The data that is being passed to this event
 */
 
 /**
 * The {@link $ui.CoreScreen} <b>oncheckreadystate</b> fires when the screen is asked about its ready state.  The screen has an opportunity to process its own state and then
 * fire the <b>readyCallback</b> function passed in as a paramenter when the screen is actually ready.  It may never fire the <b>readyCallback</b> if it is not ready.
 * @callback CheckReadyStateEvent
 * @param {GenericEvent} readyCallback - Callback function to be fired when the screen's state is ready
 * @param {GenericEvent} [cancelCallback] - Callback function to be fired when the screen says that it is <b>not</b> ready
 */
/**
 * The DataProvider component provides a data source that can be bound to controls on a screen. This provides the ability to both populate controls with data, as well as automatically save the data based on user interaction with the controls.<br><br>
 * <b>NOTE: The DataProvider should be attached to a screen or control using its [attachedObjects]{@link $ui.CoreComponent} property.</b><br><br>
 * <b>Sample Declaration</b>
 * <pre>
 * {
 *   component: $ui.DataProvider,
 *   id: 'myProvider',
 *   data_key: 'RATE_TYPE_CLASS_LIST',
 *   // highlight the first item in the list on load
 *   onload: function () {
 *     if (this.data && this.data.classes && this.data.classes.length > 0) {
 *       this.screen.rateTypeClassLayout.selectClass( this.data.classes[0]);
 *     }
 *   }
 *}
 * </pre>
 * @namespace
 * @name DataProvider
 * @memberof $ui
 * @property {object} component - The <b>required</b> component property defines what type of component is being defined. This property must be $ui.DataProvider
 * @property {string} id - The <b>required</b> id property is used to uniquely define the data provider in the scope of the screen in which it belongs. Providing an id for your data provider is required because you can easily access your provider through your javascript coding and also reference it as the provider for a control.
 * 
 * @property {string} [data_key] - A string reference to a unique, registered data service key; This is required by the <b>fetch</b> method
 * @property {string} [data_resource]  A string overriding the name of the resource to retrieve; For JSON file requests, the name is prefixed and .json is added as the extension
 * @property {string} [data_type]  A string overriding the type of resource to retrieve (see $data.data_service_types for valid options)
 * 
 * @property {object} [data] - The data property by default is undefined. You can populate the data property as any kind of object. The data property holds the object that represents the data for the provider
 * @property {GenericEvent} [onload] - This event will fire when the data has been successfully loaded into the provider and controls have been updated
 * @property {GenericEvent} [onbeforeupdate] - This event will fire when the data property has been successfully set, but has not yet been used to update any controls connected to the provider. This gives you an opportunity to manipulate the data property of the data provider <b>before</b> controls are updated
 */
function $ui_DataProvider(object, component, screen){
	// Create our protected area
	object._protected = {
		model: object,
		updates: []
	};
	
	// Attach the ID to the main screen object
	if (object.id && screen) {
		screen[object.id] = object;
	}
	
	// Component Property
	object._protected.component = object.component;
	Object.defineProperty(object, 'component', {
		get: function() {return this._protected.component;},
		set: function() {
			console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','component'));
		},
		configurable: false}
	);
	
	// Screen property
	object.screen = screen;
	object._protected.screen = object.screen;
	Object.defineProperty(object, 'screen', {
		get: function() {return this._protected.screen;},
		set: function() {
			console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','screen'));
		},
		configurable: false}
	);
	
	// Data property
	object._protected.data = object.data;
	Object.defineProperty(object, 'data', {
		get: function() {return this._protected.data;},
		set: function(value) {
			this._protected.data = value;
			this._protected.updates = [];
			if (this.onbeforeupdate) {
				this.onbeforeupdate();
			}
			this._raiseEvent();
			if (value == undefined) return;
			if (this.onload) {
				this.onload();
			}
		},
		configurable: false}
	);

  object.clear = function() {
    // iterate through data object and reset each property to undefined
    var data = object.data,
      clear_data = {};
    for (var property in data) {
      if (data.hasOwnProperty(property)) {
        clear_data[property] = undefined;
      }
    }
    object.data = clear_data;
  };

  /**
   * The fetch function retrieves and populates the DataProvider's data property.
   * The fetch function will only work if the global <b>$ui.init()</b> function has been passed an option parameter that has configured the <b>globalDataProvider</b> value
   * @function fetch
   * @memberof $ui.DataProvider
   * @param onfail - this callback function is invoked if unable to retrieve the requested data
   * @param transform - an optional data transformation function that takes the data as a parameter
   *  and returns the transformed data
   */
  object.fetch = function(onfail, transform) {
    if ($ui.options.globalDataProvider != undefined) {
      $ui.options.globalDataProvider._getData.call(this.screen, this, function(data) {
        if (transform) {
          data = transform(data);
        }
        object.data = data;}, onfail);
    }
  }.$bind(object);

	/** 
	 * The refresh function will send a signal out to all connected components to refresh their data from the current content in memory from the provider. <b>NOTE: No <i>onbeforeupdate</i> or <i>onload</i> event will fire on the provider</b>
	 * @function refresh
	 * @memberof $ui.DataProvider
	 */
	object.refresh = function() {
		this._raiseEvent();
	}.$bind(object);
	
	/** 
	 * The getUpdates function will return an array of field updates on the provider since its data property has been set.
	 * @function getUpdatedFields
	 * @memberof $ui.DataProvider
	 * @returns {ProviderUpdate[]}
	 */
	object.getUpdatedFields = function() {
		var i,
			result = [];
		for (i = 0; i < this._protected.updates.length; i++) {
			result.push(this._protected.updates[i]); 
		}
		return result;		
	}.$bind(object);
	
	// Maintain a list of updated data
	object._propertyUpdated = function(property, value) {
		var i,
			entry,
			found = false,
			newEntry = {
				property: property,
				value: value
			};
		// See if we just need to update an existing entry
		for (i = 0; i < this._protected.updates.length; i++) {
			entry = this._protected.updates[i];
			if (entry.property == property) {
				this._protected.updates[i] = newEntry;
				found = true;
				break;
			}
		}
		if (found == false) {
			this._protected.updates.push(newEntry);
		}
	}.$bind(object);
	
	// Raise our event to let the rest of the app know to refresh
	object._raiseEvent = function() {
		var evt = document.createEvent('Events');
		evt.initEvent(this.screen.guid+'-'+this.id+'-updated', true, true);
		window.dispatchEvent(evt);
	}.$bind(object);
	
	// Private function to handle clean-up
	object._destroy = function() {
		this._protected.data = undefined;
	}.$bind(object);
	
	// See if the data was pre-defined
	if (object.data != undefined) {
		if (object.onbeforeupdate) {
			object.onbeforeupdate();
		}
		if (object.onload) {
			object.onload();
		}
	}
	
	return undefined;
}

/**
 * A data provider link provides a binding between a [control]{@link $ui.CoreComponent} and a data provider. The path for the <b>property</b> attribute starts at the root of the object that is provided as the data source for the data provider.<br><br>
 * The type of object that the property path should point to is dependent on the control and the data it uses to display and/or edit. If the control also allows the user to edit data or change settings, these changes will be applied to the property value in the data provider.<br><br>
 * <b>Sample Code:</b><br>
 * <pre>provider: {
 *    id: 'myProvider',
 *    property: 'posts'
 * }
 * </pre>
 * <br>
 * To access sub objects in the object chain from the data provider you can use normal <b>dot</b> notation:<br><br>
 * <b>Sample Code:</b><br>
 * <pre>provider: {
 *    id: 'myProvider',
 *    property: 'posts.item.thingy'
 * }
 * </pre>
 * <br>
 * @namespace
 * @name DataProviderLink
 * @memberof $ui
 * @property {string} id - This is the <b>mandatory</b> id of the data provider belonging to the screen which will be linked to this control.  
 * @property {string} property - This is the property path/name of the object to be used as the bound data for this control. A nested property can be defined simply by providing a path using <b>.</b> dot separators just like you were referring to the object via JavaScript
 */
 
 
/**
 * The ProviderUpdate is a value that specifies a property name from a {@link $ui.DataProvider} and the new value of the property
 * @namespace ProviderUpdate
 * @memberof $ui.DataProvider
 * @property [string] property - The name of the property updated
 * @property [object] value - The new value of the property
 */
 
 /**
 * The GlobalDataProviderEvent is used when initializing the toolkit and 
 * @callback GlobalDataProviderEvent
 * @param {$ui.DataProvider} dataProvider - The DataProvider instance
 * @param {DataEvent} callback - The callback data event to be fired when data is ready
 * @param {GenericEvent} onfail - Callback to be triggered if there was an error during retrieval
 */
/**
 * Represents an interaction event from the user interface.  This event is raised when a user interacts with a part of the interface. All interation events are sent to the $ui.oninteraction 
 * assigned function.  If valid values are not passed in for all of the parameters no event will be raised.
 * @class InteractionEvent
 * @param {string} screenId - The <b>id</b> property of the screen which contains the control providing the interaction
 * @param {string} controlID - The <b>id</b> property of the control in which the user interacted
 * @param {string} interaction - The interaction which took place
 * @param {object} component - The component type definition for which this interaction took place.   An example could be the value $ui.List.  This is <b>not</b> a pointer to the control.
 */
function InteractionEvent(screenId, controlId, interaction, component) {
	/**
	 * The <b>id</b> property of the screen which contains the control providing the interaction
	 * @member {string} screenId
	 * @memberOf InteractionEvent
	 */
	this.screenId = screenId;
	
	 /**
	 * The <b>id</b> property of the control in which the user interacted
	 * @member {string} controlId
	 * @memberOf InteractionEvent
	 */
	this.controlId = controlId;
	
	 
	 /**
	 * The interaction which took place
	 * @member {string} interaction
	 * @memberOf InteractionEvent
	 */
	this.interaction = interaction;
	
	/**
	 * The component type definition for which this interaction took place.  An example could be the value $ui.List.  This is <b>not</b> a pointer to the control
	 * @member {object} component
	 * @memberOf InteractionEvent
	 */
	this.component = component;
}


 


/**
 * A List object will display multiple list items based on the data provided to the control.  The type of item objects that are used should match the declaration of the <b>style</b> of the list control.<br><br>
 * The type of data provider value for a list control should point to a property in the data provider that would follow the same rules as hard coding an array of items.<br><br>
 * <b>Sample Declaration</b><br>
 * <pre>
 * {
 *   component: $ui.List,
 *   style: $ui.GenericListItem,
 *   items: [
 *      {
 *         img: 'thumbnails/foo.png',
 *         title: 'This is my title',
 *         accent: '6 hours ago',
 *         caption: 'My summary description'
 *      }
 *   ]
 *}
 * @namespace
 * @name List
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {object[]} [items] - The items property is an array of objects who's definition matches that of the requirements of the <b>style</b> property of the list
 * @property {object} style - This is a list item decalaration so that the list knows how to render. For example this could be set to {@link $ui.GenericListItem}
 * @property {ListActionEvent} [onaction] - The onaction event will fire when an action from a list item is triggered. Some list items may have multiple actions that can be taken. When one of these actions is selected by the user the onaction event will fire.
 * @property {GenericEvent} [onitemschanged] - The onitemschanged event will fire when any items have been added or removed from the list.  This will also fire on data provider updates.
 */
function $ui_List(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom,'ui-list');
	
	// Set our items property
	if (object.items == undefined) {
		object.items = [];
	}
	object._protected.items = object.items;
	Object.defineProperty(object, 'items', {
		get: function() {return this._protected.items;},
		set: function() {
			console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','items'));
		},
		configurable: false}
	);

	// Broker the onaction from a list item
	object._onaction = function(item, event) {
		if (this.onaction) {
			this.onaction(event);
		}
	}.$bind(object);
	
	// Create the DOM for a list item depending on the list type
	object._createItemDom = function(item) {
		var dom;
		// See if the item is a header
		if (item.component && (item.component == $ui.Header)) {
			dom = $ui.createControl(item,this.screen);
		} else if (this._itemConstructor != undefined) {
			dom = new this._itemConstructor(item,this.screen);
		}
		return dom;
	}.$bind(object);
	
	// Private function to add a new item to the list
	object._addItem = function(item) {
		item.parent = this;
		itemDom = this._createItemDom(item);
		if (itemDom) {
			this.dom.appendChild(itemDom);
			if (item._onafterinsert) {
				item._onafterinsert();
			}
			return true;
		} else {
			return false;
		}
	}.$bind(object);
	
	/** 
	 * You can add an item to the end of the list by calling the addItem function and passing in an object that matches the a list item
	 * @function addItem
	 * @memberof $ui.List
	 * @param {object} item - Item to be added to the list
	 */
	object.addItem = function(item) {
		if (this._addItem(item)) {
			this.items.push(item);
			// Trigger our changed event
			if (this.onitemschanged) {
				this.onitemschanged();
			}
			if (item._onshow) {
				item._onshow();
			}
			return true;
		} else {
			return false;
		}
	}.$bind(object);
	
	/** 
	 * The remove item function will remove an existing item from a list. If an invalid item is specified the removal will fail
	 * @function removeItem
	 * @memberof $ui.List
	 * @param {object} item - Item to be removed from the list
	 */
	object.removeItem = function(item) {
		if (item == undefined) return false;
		var index = this.items.indexOf(item);
		if (index < 0) return false;
		try {
			this.dom.removeChild(item.dom);
		} catch (ex) {
			console.log('$ui.List: ' + ex);
		}
		this.items.splice(index, 1);
		item.destroy(); 
		// Trigger our changed event
		if (this.onitemschanged) {
			this.onitemschanged();
		}
	}.$bind(object);
	
	/** 
	 * Insert item works similar to addItem but instead will insert the item into the list at the index specified. If an invalid index is specified it will result in failure to insert the item. To insert an item at the top of a list call insert with the index of 0.
	 * @function insertItem
	 * @memberOf $ui.List
	 * @param {object} item - Item to be inserted into the list
	 * @param {number} index - Index to insert the item
	 */
	object.insertItem = function(item, index) {
		item.parent = this;
		if (index < 0) {
			return false;
		} else if (this.items.length == 0) {
			this.addItem(item);
			return true;
		} else if (index > this.items.length - 1) {
			this.addItem(item);
			return true;
		} else { // Insert it at the index
			var existingItem = this.items[index],
				itemDom = this._createItemDom(item);
			this.items.splice(index, 0, item);
			this.dom.insertBefore(itemDom, existingItem.dom);
			// Trigger our changed event
			if (this.onitemschanged) {
				this.onitemschanged();
			}
			if (item._onshow) {
				item._onshow();
			}
			return true;
		} 
		return false;
	}.$bind(object);
	
	/** 
	 * You can refresh all the items in a list by calling the refreshItems function with an array of new items
	 * @function refreshItems
	 * @memberof $ui.List
	 * @param {object[]} items - Array of items to refresh the list
	 */
	object.refreshItems = function(itemArray) {
		var i,
			item;
		if (this.items) {
			// Remove all existing items first
			for (i = this.items.length - 1; i >= 0; i--) {
				item = this.items[i];
				try {
					this.dom.removeChild(item.dom);
				} catch (ex) {
					console.log('$ui.List: ' + ex);
				}
				this.items.pop();
				item.destroy();
			}
		}
		if (itemArray == undefined) return; // No data provided
		this.addItemBatch(itemArray);
		// Trigger our changed event
		if (this.onitemschanged) {
			this.onitemschanged();
		}
	}.$bind(object);
	
	/** 
	 * This function is much like the refreshItems function but instead it loads a list of items to the end of the current list and does not replace the existing list items.
	 * @function addItemBatch
	 * @memberof $ui.List
	 * @param {object[]} items - Array of items to be added to the list
	 */
	object.addItemBatch = function(itemArray) {
		var i,
			item;
		// Add all new items into the list
		for (i = 0; i < itemArray.length; i++) {
			item = itemArray[i];
			this.addItem(item);
		}
	}.$bind(object);
	
	/** 
	 * This function will filter the list items based on the name value pairs of search criteria.  All search criteria will be AND'ed
	 * @function filter
	 * @memberof $ui.List
	 * @param {ListFilter[]} filters - Array of filters to be used for this list
	 */
	object.filter = function(filters) {
		if (filters == undefined || filters == null) return;
		var i,
			j,
			filter,
			item,
			pattern,
			match = true;;
		for (i = 0; i < this.items.length; i++) {
			item = this.items[i];
			match = true;
			for (j = 0; j < filters.length; j++) {
				filter = filters[j];
				if (item[filter.name] != undefined) {
					pattern = new RegExp(filter.expression, 'gi');
					if (pattern.test(item[filter.name]) == false) {
						match = false;
						break;
					}
				}
			}
			item.visible = match;
		}
	}.$bind(object);
	
	/** 
	 * This function will reset any filter applied to the List
	 * @function filterReset
	 * @memberof $ui.List
	 */
	object.filterReset = function(filter) {
		var i;
		for (i = 0; i < this.items.length; i++) {
			this.items[i].visible = true;
		}
		
	}.$bind(object);
	
	
	// Private function to handle provider updates
	object._providerUpdate = function(value) {
		this.refreshItems(value);
	}.$bind(object);
	
	
	var i,
		extension;
	// Determine our item constructor
	for (i = 0; i < $ui._protected.definitions.length; i++) {
		extension = $ui._protected.definitions[i];
		if (extension.type != $ui.UIExtensionType.LISTITEM) continue;
		if (extension.component == object.style) {
			object._itemConstructor = extension.constructor;
			break;
		}
	}

	// Cycle through list items
	var	item,
		index;
	if (object.items) {
		for (i = 0; i < object.items.length; i++) {
			item = object.items[i];
			object._addItem(item);
		}
		// Trigger our changed event
		if (object.onitemschanged) {
			object.onitemschanged();
		}
	}
	
	// Relay the _onshow to list items
	object._onshow = function() {
		var i,
			item;
		for (i = 0; i < this.items.length; i++) {
			item = this.items[i];
			if (item._onshow) {
				item._onshow();
			}
		}
	}.$bind(object);
	
	return object.dom;
}

/**
 * The {@link $ui.List} <b>onaction</b> event will fire when the user interacts with a list item
 * @callback ListActionEvent
 * @param {ListEvent} event - The list event which was raised
 */
 
 /**
 * The {@link $ui.List} <b>onaction</b> event will fire when the user interacts with a list item
 * @class ListFilter
 * @memberof $ui
 * @param {string} name - The name of the property to be filtered
 * @param {string} expression - The regular expression to use to evaluate against the value of the named list item property
 */
 $ui.ListFilter = function(name, expression) {
	 this.name = name;
	 this.expression = expression;
 }
/**
 * The list event is what is triggered when a user interacts with the List control. It contains the target list item that the user was interacting with, the type of event which was triggered 
 * and an optional data property that contains extra data about the event.
 * @class ListEvent
 * @param {object} target - Target list item where the event originated
 * @param {string} eventType - The type of event that was triggered. Each list item has its own set of possible events that can be raised
 * @param {object} [data] - Optional data that can be passed with a list event
 */
function ListEvent(target, eventType, data) {
	/** 
	 * Target list item where the event originated
	 * @member {object} target
	 * @memberOf ListEvent
	 */
	this.target = target;
	
	/** 
	 * The type of event that was triggered. Each list item has its own set of possible events that can be raised
	 * @member {string} eventType
	 * @memberOf ListEvent
	 */
	this.eventType = eventType;
	
	/** 
	 * Optional data that can be passed with a list event
	 * @member {object} [data]
	 * @memberOf ListEvent
	 */
	this.data = data;
}


/**
 * The spinner control provides you the ability to give a visual indicator when your content is loading. The spinner has one main property <b>size</b>. <br><br>
 * <b>Sample Declaration</b><br>
 * <pre>
 * {
 *   component: $ui.Spinner,
 *   size: $ui.Spinner.SpinnerSize.LARGE
 *}
 * @namespace Spinner
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {$ui.Size} [size=$ui.Size.NORMAL] - Represents the size of the spinner component.
 * @property {$ui.Spinner.SpinnerColor} [forceColor] - This property specifies if the color should be forced to be dark or light. By default the system figures this out and does not need to be set. However, if you want to force a color in a certain scenario you can use this property.
 */
function $ui_Spinner(object, screen){
	$ui_CoreComponent.call(this, object, screen);
	// Size property
	object.size = (object.size) ? object.size : $ui.Size.NORMAL;
	object._protected.size = object.size;
	Object.defineProperty(object, 'size', {
		get: function() {return this._protected.size;},
		set: function(value) {
			if (this._protected.size == value) return;
			$ui.removeClass(this.dom, this._protected.size);
			this._protected.size = value;
			$ui.addClass(this.dom,value);			
		},
		configurable: false}
	);
	
	$ui.addClass(object.dom, 'ui-spinner')
	$ui.addClass(object.dom, object.size);
	$ui.addClass(object.dom, 'center');
	
	// Create the inner div
	object.dom.innerDiv = document.createElement('div');
	$ui.addClass(object.dom.innerDiv, 'inner');
	object.dom.appendChild(object.dom.innerDiv);
	
	// forceColor property
	object._protected.forceColor = object.forceColor;
	if (object.forceColor) {
		$ui.addClass(object.dom.innerDiv, object.forceColor);
	} else {
		if ($ui.theme.rootClass && $ui.theme.rootClass.indexOf('ui-theme-dark') > -1)  {
			$ui.addClass(object.dom.innerDiv, 'light');
		} else {
			$ui.addClass(object.dom.innerDiv, 'dark');
		}
	}
	Object.defineProperty(object, 'forceColor', {
		get: function() {return this._protected.forceColor;},
		set: function() {
			console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','forceColor'));			
		},
		configurable: false}
	);
	
	return object.dom
}

$ui_Spinner.prototype = new $ui_CoreComponent();
/**
 * The definition of an extension to be used in extending the <b>$ui</b> framework.
 * @class
 * @param {string} name - This would be the value you set as the <b>component</b> property for your control
 * @param {function} constructor - The function to be used as your control constructor
 * @param {$ui.UIExtensionType} [type=$ui.UIExtensionType.CONTROL] - The type of extension you are registering
 * @param {object} [definition] - Class definition for your extension, you can include properties such as constants here
 */
function UIExtension(name, constructor, type, definition) {
	/** 
	 * This would be the value you set as the <b>component</b> property for your control
	 * @member {string} name
	 * @memberOf UIExtension
	 */
	if (name == null) throw new Error('UIExtension: name cannot be null');
	if (name == undefined) throw new Error('UIExtension: name cannot be undefined');
	this.name = name;
	/** 
	 * The function to be used as your control constructor
	 * @member {function} constructor
	 * @memberOf UIExtension
	 */
	if (constructor == null) throw new Error('UIExtension: constructor cannot be null');
	if (constructor == undefined) throw new Error('UIExtension: constructor cannot be undefined');
	this.constructor = constructor;
	/** 
	 * The type of extension you are registering
	 * @member {$ui.UIExtensionType} [type=$ui.UIExtensionType.CONTROL]
	 * @memberOf UIExtension
	 */
	if (type == null || type == undefined) {
		this.type = $ui.UIExtensionType.CONTROL;
	} else if ((type != $ui.UIExtensionType.CONTROL) && (type != $ui.UIExtensionType.SCREEN) && (type != $ui.UIExtensionType.LISTITEM) && (type != $ui.UIExtensionType.ATTACHED_OBJECT)) {
		throw new Error('UIExtension: type is an invalid value');
	} else {
		this.type = type;
	}
	/** 
	 * Class definition for your extension, you can include properties such as constants here
	 * @member {object} [definition]
	 * @memberOf UIExtension
	 */
	if (definition == null || definition == undefined) {
		this.definition = {};
	} else {
		this.definition = definition;
	}
}
/**
 * The Button represents a standard button in the UI. 
 * <br><br><b>Sample Declaration</b>
 * <pre>
 * {
 *   component: $ui.Button,
 *   caption: 'Click Me'
 * }
 * </pre>
 * @namespace Button
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {string} caption - Represents the main text to show in the list item
 */
function $ui_Button(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom, 'ui-button theme-brand-background-color theme-highlight-text-color theme-border-color');
	if ($ui.theme.inHeadUnit == true) {
		$ui.addClass(object.dom, 'in-head-unit');
	}

	// Caption
	//object.dom.captionDiv = document.createElement('div');
	//$ui.addClass(object.dom.captionDiv,'caption theme-text-color');
	//object.dom.appendChild(object.dom.captionDiv);
	
	// caption property
	if (object.caption == undefined) {
		object.caption = '';
	}
	object.dom.textContent = object.caption;
	object._protected.caption = object.caption;
	Object.defineProperty(object, 'caption', {
		get: function() {return this._protected.caption;},
		set: function(value) {
			if (value == undefined) value = '';
			if (value == this._protected.caption) return;
			this._protected.caption = value;
			this.dom.textContent = value;
		},
		configurable: false}
	);
	
	
	// Handle our touch events
	object.dom.ontouchstart = function() {
		this.style.opacity = 0.7;
	}
	object.dom.ontouchend = function() {
		this.style.opacity = 1;
	}
	object.dom.ontouchcancel = object.dom.ontouchend;
	if (!$ui.isMobileDevice()) {
		object.dom.onmousedown = object.dom.ontouchstart;
		object.dom.onmouseup = object.dom.ontouchend;
		object.dom.onmouseleave = object.dom.ontouchend;
	}

	// Pass the onclick back to the list
	object.dom.onclick = function() {
		$ui.playTouchSound();
		if (this.model.onclick) {
			this.model.onclick();
		}
	};

	return object.dom;
}
/*!
 * Chart.js
 * http://chartjs.org/
 * Version: 1.0.1
 *
 * Copyright 2015 Nick Downie
 * Released under the MIT license
 * https://github.com/nnnick/Chart.js/blob/master/LICENSE.md
 */
(function(){"use strict";var t=this,i=t.Chart,e=function(t){this.canvas=t.canvas,this.ctx=t;this.width=t.canvas.width,this.height=t.canvas.height;return this.aspectRatio=this.width/this.height,s.retinaScale(this),this};e.defaults={global:{animation:!0,animationSteps:60,animationEasing:"easeOutQuart",showScale:!0,scaleOverride:!1,scaleSteps:null,scaleStepWidth:null,scaleStartValue:null,scaleLineColor:"rgba(0,0,0,.1)",scaleLineWidth:1,scaleShowLabels:!0,scaleLabel:"<%=value%>",scaleIntegersOnly:!0,scaleBeginAtZero:!1,scaleFontFamily:"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",scaleFontSize:12,scaleFontStyle:"normal",scaleFontColor:"#666",responsive:!1,maintainAspectRatio:!0,showTooltips:!0,customTooltips:!1,tooltipEvents:["mousemove","touchstart","touchmove","mouseout"],tooltipFillColor:"rgba(0,0,0,0.8)",tooltipFontFamily:"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",tooltipFontSize:14,tooltipFontStyle:"normal",tooltipFontColor:"#fff",tooltipTitleFontFamily:"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",tooltipTitleFontSize:14,tooltipTitleFontStyle:"bold",tooltipTitleFontColor:"#fff",tooltipYPadding:6,tooltipXPadding:6,tooltipCaretSize:8,tooltipCornerRadius:6,tooltipXOffset:10,tooltipTemplate:"<%if (label){%><%=label%>: <%}%><%= value %>",multiTooltipTemplate:"<%= value %>",multiTooltipKeyBackground:"#fff",onAnimationProgress:function(){},onAnimationComplete:function(){}}},e.types={};var s=e.helpers={},n=s.each=function(t,i,e){var s=Array.prototype.slice.call(arguments,3);if(t)if(t.length===+t.length){var n;for(n=0;n<t.length;n++)i.apply(e,[t[n],n].concat(s))}else for(var o in t)i.apply(e,[t[o],o].concat(s))},o=s.clone=function(t){var i={};return n(t,function(e,s){t.hasOwnProperty(s)&&(i[s]=e)}),i},a=s.extend=function(t){return n(Array.prototype.slice.call(arguments,1),function(i){n(i,function(e,s){i.hasOwnProperty(s)&&(t[s]=e)})}),t},h=s.merge=function(){var t=Array.prototype.slice.call(arguments,0);return t.unshift({}),a.apply(null,t)},l=s.indexOf=function(t,i){if(Array.prototype.indexOf)return t.indexOf(i);for(var e=0;e<t.length;e++)if(t[e]===i)return e;return-1},r=(s.where=function(t,i){var e=[];return s.each(t,function(t){i(t)&&e.push(t)}),e},s.findNextWhere=function(t,i,e){e||(e=-1);for(var s=e+1;s<t.length;s++){var n=t[s];if(i(n))return n}},s.findPreviousWhere=function(t,i,e){e||(e=t.length);for(var s=e-1;s>=0;s--){var n=t[s];if(i(n))return n}},s.inherits=function(t){var i=this,e=t&&t.hasOwnProperty("constructor")?t.constructor:function(){return i.apply(this,arguments)},s=function(){this.constructor=e};return s.prototype=i.prototype,e.prototype=new s,e.extend=r,t&&a(e.prototype,t),e.__super__=i.prototype,e}),c=s.noop=function(){},u=s.uid=function(){var t=0;return function(){return"chart-"+t++}}(),d=s.warn=function(t){window.console&&"function"==typeof window.console.warn&&console.warn(t)},p=s.amd="function"==typeof define&&define.amd,f=s.isNumber=function(t){return!isNaN(parseFloat(t))&&isFinite(t)},g=s.max=function(t){return Math.max.apply(Math,t)},m=s.min=function(t){return Math.min.apply(Math,t)},v=(s.cap=function(t,i,e){if(f(i)){if(t>i)return i}else if(f(e)&&e>t)return e;return t},s.getDecimalPlaces=function(t){return t%1!==0&&f(t)?t.toString().split(".")[1].length:0}),S=s.radians=function(t){return t*(Math.PI/180)},x=(s.getAngleFromPoint=function(t,i){var e=i.x-t.x,s=i.y-t.y,n=Math.sqrt(e*e+s*s),o=2*Math.PI+Math.atan2(s,e);return 0>e&&0>s&&(o+=2*Math.PI),{angle:o,distance:n}},s.aliasPixel=function(t){return t%2===0?0:.5}),y=(s.splineCurve=function(t,i,e,s){var n=Math.sqrt(Math.pow(i.x-t.x,2)+Math.pow(i.y-t.y,2)),o=Math.sqrt(Math.pow(e.x-i.x,2)+Math.pow(e.y-i.y,2)),a=s*n/(n+o),h=s*o/(n+o);return{inner:{x:i.x-a*(e.x-t.x),y:i.y-a*(e.y-t.y)},outer:{x:i.x+h*(e.x-t.x),y:i.y+h*(e.y-t.y)}}},s.calculateOrderOfMagnitude=function(t){return Math.floor(Math.log(t)/Math.LN10)}),C=(s.calculateScaleRange=function(t,i,e,s,n){var o=2,a=Math.floor(i/(1.5*e)),h=o>=a,l=g(t),r=m(t);l===r&&(l+=.5,r>=.5&&!s?r-=.5:l+=.5);for(var c=Math.abs(l-r),u=y(c),d=Math.ceil(l/(1*Math.pow(10,u)))*Math.pow(10,u),p=s?0:Math.floor(r/(1*Math.pow(10,u)))*Math.pow(10,u),f=d-p,v=Math.pow(10,u),S=Math.round(f/v);(S>a||a>2*S)&&!h;)if(S>a)v*=2,S=Math.round(f/v),S%1!==0&&(h=!0);else if(n&&u>=0){if(v/2%1!==0)break;v/=2,S=Math.round(f/v)}else v/=2,S=Math.round(f/v);return h&&(S=o,v=f/S),{steps:S,stepValue:v,min:p,max:p+S*v}},s.template=function(t,i){function e(t,i){return i.value;var e=/\W/.test(t)?new Function("obj","var p=[],print=function(){p.push.apply(p,arguments);};with(obj){p.push('"+t.replace(/[\r\t\n]/g," ").split("<%").join("	").replace(/((^|%>)[^\t]*)'/g,"$1\r").replace(/\t=(.*?)%>/g,"',$1,'").split("	").join("');").split("%>").join("p.push('").split("\r").join("\\'")+"');}return p.join('');"):s[t]=s[t];return i?e(i):e}if(t instanceof Function)return t(i);var s={};return e(t,i)}),w=(s.generateLabels=function(t,i,e,s){var o=new Array(i);return labelTemplateString&&n(o,function(i,n){o[n]=C(t,{value:e+s*(n+1)})}),o},s.easingEffects={linear:function(t){return t},easeInQuad:function(t){return t*t},easeOutQuad:function(t){return-1*t*(t-2)},easeInOutQuad:function(t){return(t/=.5)<1?.5*t*t:-0.5*(--t*(t-2)-1)},easeInCubic:function(t){return t*t*t},easeOutCubic:function(t){return 1*((t=t/1-1)*t*t+1)},easeInOutCubic:function(t){return(t/=.5)<1?.5*t*t*t:.5*((t-=2)*t*t+2)},easeInQuart:function(t){return t*t*t*t},easeOutQuart:function(t){return-1*((t=t/1-1)*t*t*t-1)},easeInOutQuart:function(t){return(t/=.5)<1?.5*t*t*t*t:-0.5*((t-=2)*t*t*t-2)},easeInQuint:function(t){return 1*(t/=1)*t*t*t*t},easeOutQuint:function(t){return 1*((t=t/1-1)*t*t*t*t+1)},easeInOutQuint:function(t){return(t/=.5)<1?.5*t*t*t*t*t:.5*((t-=2)*t*t*t*t+2)},easeInSine:function(t){return-1*Math.cos(t/1*(Math.PI/2))+1},easeOutSine:function(t){return 1*Math.sin(t/1*(Math.PI/2))},easeInOutSine:function(t){return-0.5*(Math.cos(Math.PI*t/1)-1)},easeInExpo:function(t){return 0===t?1:1*Math.pow(2,10*(t/1-1))},easeOutExpo:function(t){return 1===t?1:1*(-Math.pow(2,-10*t/1)+1)},easeInOutExpo:function(t){return 0===t?0:1===t?1:(t/=.5)<1?.5*Math.pow(2,10*(t-1)):.5*(-Math.pow(2,-10*--t)+2)},easeInCirc:function(t){return t>=1?t:-1*(Math.sqrt(1-(t/=1)*t)-1)},easeOutCirc:function(t){return 1*Math.sqrt(1-(t=t/1-1)*t)},easeInOutCirc:function(t){return(t/=.5)<1?-0.5*(Math.sqrt(1-t*t)-1):.5*(Math.sqrt(1-(t-=2)*t)+1)},easeInElastic:function(t){var i=1.70158,e=0,s=1;return 0===t?0:1==(t/=1)?1:(e||(e=.3),s<Math.abs(1)?(s=1,i=e/4):i=e/(2*Math.PI)*Math.asin(1/s),-(s*Math.pow(2,10*(t-=1))*Math.sin(2*(1*t-i)*Math.PI/e)))},easeOutElastic:function(t){var i=1.70158,e=0,s=1;return 0===t?0:1==(t/=1)?1:(e||(e=.3),s<Math.abs(1)?(s=1,i=e/4):i=e/(2*Math.PI)*Math.asin(1/s),s*Math.pow(2,-10*t)*Math.sin(2*(1*t-i)*Math.PI/e)+1)},easeInOutElastic:function(t){var i=1.70158,e=0,s=1;return 0===t?0:2==(t/=.5)?1:(e||(e=.3*1.5),s<Math.abs(1)?(s=1,i=e/4):i=e/(2*Math.PI)*Math.asin(1/s),1>t?-.5*s*Math.pow(2,10*(t-=1))*Math.sin(2*(1*t-i)*Math.PI/e):s*Math.pow(2,-10*(t-=1))*Math.sin(2*(1*t-i)*Math.PI/e)*.5+1)},easeInBack:function(t){var i=1.70158;return 1*(t/=1)*t*((i+1)*t-i)},easeOutBack:function(t){var i=1.70158;return 1*((t=t/1-1)*t*((i+1)*t+i)+1)},easeInOutBack:function(t){var i=1.70158;return(t/=.5)<1?.5*t*t*(((i*=1.525)+1)*t-i):.5*((t-=2)*t*(((i*=1.525)+1)*t+i)+2)},easeInBounce:function(t){return 1-w.easeOutBounce(1-t)},easeOutBounce:function(t){return(t/=1)<1/2.75?7.5625*t*t:2/2.75>t?1*(7.5625*(t-=1.5/2.75)*t+.75):2.5/2.75>t?1*(7.5625*(t-=2.25/2.75)*t+.9375):1*(7.5625*(t-=2.625/2.75)*t+.984375)},easeInOutBounce:function(t){return.5>t?.5*w.easeInBounce(2*t):.5*w.easeOutBounce(2*t-1)+.5}}),b=s.requestAnimFrame=function(){return window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame||function(t){return window.setTimeout(t,1e3/60)}}(),P=(s.cancelAnimFrame=function(){return window.cancelAnimationFrame||window.webkitCancelAnimationFrame||window.mozCancelAnimationFrame||window.oCancelAnimationFrame||window.msCancelAnimationFrame||function(t){return window.clearTimeout(t,1e3/60)}}(),s.animationLoop=function(t,i,e,s,n,o){var a=0,h=w[e]||w.linear,l=function(){a++;var e=a/i,r=h(e);t.call(o,r,e,a),s.call(o,r,e),i>a?o.animationFrame=b(l):n.apply(o)};b(l)},s.getRelativePosition=function(t){var i,e,s=t.originalEvent||t,n=t.currentTarget||t.srcElement,o=n.getBoundingClientRect();return s.touches?(i=s.touches[0].clientX-o.left,e=s.touches[0].clientY-o.top):(i=s.clientX-o.left,e=s.clientY-o.top),{x:i,y:e}},s.addEvent=function(t,i,e){t.addEventListener?t.addEventListener(i,e):t.attachEvent?t.attachEvent("on"+i,e):t["on"+i]=e}),L=s.removeEvent=function(t,i,e){t.removeEventListener?t.removeEventListener(i,e,!1):t.detachEvent?t.detachEvent("on"+i,e):t["on"+i]=c},k=(s.bindEvents=function(t,i,e){t.events||(t.events={}),n(i,function(i){t.events[i]=function(){e.apply(t,arguments)},P(t.chart.canvas,i,t.events[i])})},s.unbindEvents=function(t,i){n(i,function(i,e){L(t.chart.canvas,e,i)})}),F=s.getMaximumWidth=function(t){var i=t.parentNode;return i.clientWidth},R=s.getMaximumHeight=function(t){var i=t.parentNode;return i.clientHeight},T=(s.getMaximumSize=s.getMaximumWidth,s.retinaScale=function(t){var i=t.ctx,e=t.canvas.width,s=t.canvas.height;window.devicePixelRatio&&(i.canvas.style.width=e+"px",i.canvas.style.height=s+"px",i.canvas.height=s*window.devicePixelRatio,i.canvas.width=e*window.devicePixelRatio,i.scale(window.devicePixelRatio,window.devicePixelRatio))}),A=s.clear=function(t){t.ctx.clearRect(0,0,t.width,t.height)},M=s.fontString=function(t,i,e){return i+" "+t+"px "+e},W=s.longestText=function(t,i,e){t.font=i;var s=0;return n(e,function(i){var e=t.measureText(i).width;s=e>s?e:s}),s},z=s.drawRoundedRectangle=function(t,i,e,s,n,o){t.beginPath(),t.moveTo(i+o,e),t.lineTo(i+s-o,e),t.quadraticCurveTo(i+s,e,i+s,e+o),t.lineTo(i+s,e+n-o),t.quadraticCurveTo(i+s,e+n,i+s-o,e+n),t.lineTo(i+o,e+n),t.quadraticCurveTo(i,e+n,i,e+n-o),t.lineTo(i,e+o),t.quadraticCurveTo(i,e,i+o,e),t.closePath()};e.instances={},e.Type=function(t,i,s){this.options=i,this.chart=s,this.id=u(),e.instances[this.id]=this,i.responsive&&this.resize(),this.initialize.call(this,t)},a(e.Type.prototype,{initialize:function(){return this},clear:function(){return A(this.chart),this},stop:function(){return s.cancelAnimFrame.call(t,this.animationFrame),this},resize:function(t){this.stop();var i=this.chart.canvas,e=F(this.chart.canvas),s=this.options.maintainAspectRatio?e/this.chart.aspectRatio:R(this.chart.canvas);return i.width=this.chart.width=e,i.height=this.chart.height=s,T(this.chart),"function"==typeof t&&t.apply(this,Array.prototype.slice.call(arguments,1)),this},reflow:c,render:function(t){return t&&this.reflow(),this.options.animation&&!t?s.animationLoop(this.draw,this.options.animationSteps,this.options.animationEasing,this.options.onAnimationProgress,this.options.onAnimationComplete,this):(this.draw(),this.options.onAnimationComplete.call(this)),this},generateLegend:function(){return C(this.options.legendTemplate,this)},destroy:function(){this.clear(),k(this,this.events);var t=this.chart.canvas;t.width=this.chart.width,t.height=this.chart.height,t.style.removeProperty?(t.style.removeProperty("width"),t.style.removeProperty("height")):(t.style.removeAttribute("width"),t.style.removeAttribute("height")),delete e.instances[this.id]},showTooltip:function(t,i){"undefined"==typeof this.activeElements&&(this.activeElements=[]);var o=function(t){var i=!1;return t.length!==this.activeElements.length?i=!0:(n(t,function(t,e){t!==this.activeElements[e]&&(i=!0)},this),i)}.call(this,t);if(o||i){if(this.activeElements=t,this.draw(),this.options.customTooltips&&this.options.customTooltips(!1),t.length>0)if(this.datasets&&this.datasets.length>1){for(var a,h,r=this.datasets.length-1;r>=0&&(a=this.datasets[r].points||this.datasets[r].bars||this.datasets[r].segments,h=l(a,t[0]),-1===h);r--);var c=[],u=[],d=function(){var t,i,e,n,o,a=[],l=[],r=[];return s.each(this.datasets,function(i){t=i.points||i.bars||i.segments,t[h]&&t[h].hasValue()&&a.push(t[h])}),s.each(a,function(t){l.push(t.x),r.push(t.y),c.push(s.template(this.options.multiTooltipTemplate,t)),u.push({fill:t._saved.fillColor||t.fillColor,stroke:t._saved.strokeColor||t.strokeColor})},this),o=m(r),e=g(r),n=m(l),i=g(l),{x:n>this.chart.width/2?n:i,y:(o+e)/2}}.call(this,h);new e.MultiTooltip({x:d.x,y:d.y,xPadding:this.options.tooltipXPadding,yPadding:this.options.tooltipYPadding,xOffset:this.options.tooltipXOffset,fillColor:this.options.tooltipFillColor,textColor:this.options.tooltipFontColor,fontFamily:this.options.tooltipFontFamily,fontStyle:this.options.tooltipFontStyle,fontSize:this.options.tooltipFontSize,titleTextColor:this.options.tooltipTitleFontColor,titleFontFamily:this.options.tooltipTitleFontFamily,titleFontStyle:this.options.tooltipTitleFontStyle,titleFontSize:this.options.tooltipTitleFontSize,cornerRadius:this.options.tooltipCornerRadius,labels:c,legendColors:u,legendColorBackground:this.options.multiTooltipKeyBackground,title:t[0].label,chart:this.chart,ctx:this.chart.ctx,custom:this.options.customTooltips}).draw()}else n(t,function(t){var i=t.tooltipPosition();new e.Tooltip({x:Math.round(i.x),y:Math.round(i.y),xPadding:this.options.tooltipXPadding,yPadding:this.options.tooltipYPadding,fillColor:this.options.tooltipFillColor,textColor:this.options.tooltipFontColor,fontFamily:this.options.tooltipFontFamily,fontStyle:this.options.tooltipFontStyle,fontSize:this.options.tooltipFontSize,caretHeight:this.options.tooltipCaretSize,cornerRadius:this.options.tooltipCornerRadius,text:C(this.options.tooltipTemplate,t),chart:this.chart,custom:this.options.customTooltips}).draw()},this);return this}},toBase64Image:function(){return this.chart.canvas.toDataURL.apply(this.chart.canvas,arguments)}}),e.Type.extend=function(t){var i=this,s=function(){return i.apply(this,arguments)};if(s.prototype=o(i.prototype),a(s.prototype,t),s.extend=e.Type.extend,t.name||i.prototype.name){var n=t.name||i.prototype.name,l=e.defaults[i.prototype.name]?o(e.defaults[i.prototype.name]):{};e.defaults[n]=a(l,t.defaults),e.types[n]=s,e.prototype[n]=function(t,i){var o=h(e.defaults.global,e.defaults[n],i||{});return new s(t,o,this)}}else d("Name not provided for this chart, so it hasn't been registered");return i},e.Element=function(t){a(this,t),this.initialize.apply(this,arguments),this.save()},a(e.Element.prototype,{initialize:function(){},restore:function(t){return t?n(t,function(t){this[t]=this._saved[t]},this):a(this,this._saved),this},save:function(){return this._saved=o(this),delete this._saved._saved,this},update:function(t){return n(t,function(t,i){this._saved[i]=this[i],this[i]=t},this),this},transition:function(t,i){return n(t,function(t,e){this[e]=(t-this._saved[e])*i+this._saved[e]},this),this},tooltipPosition:function(){return{x:this.x,y:this.y}},hasValue:function(){return f(this.value)}}),e.Element.extend=r,e.Point=e.Element.extend({display:!0,inRange:function(t,i){var e=this.hitDetectionRadius+this.radius;return Math.pow(t-this.x,2)+Math.pow(i-this.y,2)<Math.pow(e,2)},draw:function(){if(this.display){var t=this.ctx;t.beginPath(),t.arc(this.x,this.y,this.radius,0,2*Math.PI),t.closePath(),t.strokeStyle=this.strokeColor,t.lineWidth=this.strokeWidth,t.fillStyle=this.fillColor,t.fill(),t.stroke()}}}),e.Arc=e.Element.extend({inRange:function(t,i){var e=s.getAngleFromPoint(this,{x:t,y:i}),n=e.angle>=this.startAngle&&e.angle<=this.endAngle,o=e.distance>=this.innerRadius&&e.distance<=this.outerRadius;return n&&o},tooltipPosition:function(){var t=this.startAngle+(this.endAngle-this.startAngle)/2,i=(this.outerRadius-this.innerRadius)/2+this.innerRadius;return{x:this.x+Math.cos(t)*i,y:this.y+Math.sin(t)*i}},draw:function(t){var i=this.ctx;i.beginPath(),i.arc(this.x,this.y,this.outerRadius,this.startAngle,this.endAngle),i.arc(this.x,this.y,this.innerRadius,this.endAngle,this.startAngle,!0),i.closePath(),i.strokeStyle=this.strokeColor,i.lineWidth=this.strokeWidth,i.fillStyle=this.fillColor,i.fill(),i.lineJoin="bevel",this.showStroke&&i.stroke()}}),e.Rectangle=e.Element.extend({draw:function(){var t=this.ctx,i=this.width/2,e=this.x-i,s=this.x+i,n=this.base-(this.base-this.y),o=this.strokeWidth/2;this.showStroke&&(e+=o,s-=o,n+=o),t.beginPath(),t.fillStyle=this.fillColor,t.strokeStyle=this.strokeColor,t.lineWidth=this.strokeWidth,t.moveTo(e,this.base),t.lineTo(e,n),t.lineTo(s,n),t.lineTo(s,this.base),t.fill(),this.showStroke&&t.stroke()},height:function(){return this.base-this.y},inRange:function(t,i){return t>=this.x-this.width/2&&t<=this.x+this.width/2&&i>=this.y&&i<=this.base}}),e.Tooltip=e.Element.extend({draw:function(){var t=this.chart.ctx;t.font=M(this.fontSize,this.fontStyle,this.fontFamily),this.xAlign="center",this.yAlign="above";var i=this.caretPadding=2,e=t.measureText(this.text).width+2*this.xPadding,s=this.fontSize+2*this.yPadding,n=s+this.caretHeight+i;this.x+e/2>this.chart.width?this.xAlign="left":this.x-e/2<0&&(this.xAlign="right"),this.y-n<0&&(this.yAlign="below");var o=this.x-e/2,a=this.y-n;if(t.fillStyle=this.fillColor,this.custom)this.custom(this);else{switch(this.yAlign){case"above":t.beginPath(),t.moveTo(this.x,this.y-i),t.lineTo(this.x+this.caretHeight,this.y-(i+this.caretHeight)),t.lineTo(this.x-this.caretHeight,this.y-(i+this.caretHeight)),t.closePath(),t.fill();break;case"below":a=this.y+i+this.caretHeight,t.beginPath(),t.moveTo(this.x,this.y+i),t.lineTo(this.x+this.caretHeight,this.y+i+this.caretHeight),t.lineTo(this.x-this.caretHeight,this.y+i+this.caretHeight),t.closePath(),t.fill()}switch(this.xAlign){case"left":o=this.x-e+(this.cornerRadius+this.caretHeight);break;case"right":o=this.x-(this.cornerRadius+this.caretHeight)}z(t,o,a,e,s,this.cornerRadius),t.fill(),t.fillStyle=this.textColor,t.textAlign="center",t.textBaseline="middle",t.fillText(this.text,o+e/2,a+s/2)}}}),e.MultiTooltip=e.Element.extend({initialize:function(){this.font=M(this.fontSize,this.fontStyle,this.fontFamily),this.titleFont=M(this.titleFontSize,this.titleFontStyle,this.titleFontFamily),this.height=this.labels.length*this.fontSize+(this.labels.length-1)*(this.fontSize/2)+2*this.yPadding+1.5*this.titleFontSize,this.ctx.font=this.titleFont;var t=this.ctx.measureText(this.title).width,i=W(this.ctx,this.font,this.labels)+this.fontSize+3,e=g([i,t]);this.width=e+2*this.xPadding;var s=this.height/2;this.y-s<0?this.y=s:this.y+s>this.chart.height&&(this.y=this.chart.height-s),this.x>this.chart.width/2?this.x-=this.xOffset+this.width:this.x+=this.xOffset},getLineHeight:function(t){var i=this.y-this.height/2+this.yPadding,e=t-1;return 0===t?i+this.titleFontSize/2:i+(1.5*this.fontSize*e+this.fontSize/2)+1.5*this.titleFontSize},draw:function(){if(this.custom)this.custom(this);else{z(this.ctx,this.x,this.y-this.height/2,this.width,this.height,this.cornerRadius);var t=this.ctx;t.fillStyle=this.fillColor,t.fill(),t.closePath(),t.textAlign="left",t.textBaseline="middle",t.fillStyle=this.titleTextColor,t.font=this.titleFont,t.fillText(this.title,this.x+this.xPadding,this.getLineHeight(0)),t.font=this.font,s.each(this.labels,function(i,e){t.fillStyle=this.textColor,t.fillText(i,this.x+this.xPadding+this.fontSize+3,this.getLineHeight(e+1)),t.fillStyle=this.legendColorBackground,t.fillRect(this.x+this.xPadding,this.getLineHeight(e+1)-this.fontSize/2,this.fontSize,this.fontSize),t.fillStyle=this.legendColors[e].fill,t.fillRect(this.x+this.xPadding,this.getLineHeight(e+1)-this.fontSize/2,this.fontSize,this.fontSize)},this)}}}),e.Scale=e.Element.extend({initialize:function(){this.fit()},buildYLabels:function(){this.yLabels=[];for(var t=v(this.stepValue),i=0;i<=this.steps;i++)this.yLabels.push(C(this.templateString,{value:(this.min+i*this.stepValue).toFixed(t)}));this.yLabelWidth=this.display&&this.showLabels?W(this.ctx,this.font,this.yLabels):0},addXLabel:function(t){this.xLabels.push(t),this.valuesCount++,this.fit()},removeXLabel:function(){this.xLabels.shift(),this.valuesCount--,this.fit()},fit:function(){this.startPoint=this.display?this.fontSize:0,this.endPoint=this.display?this.height-1.5*this.fontSize-5:this.height,this.startPoint+=this.padding,this.endPoint-=this.padding;var t,i=this.endPoint-this.startPoint;for(this.calculateYRange(i),this.buildYLabels(),this.calculateXLabelRotation();i>this.endPoint-this.startPoint;)i=this.endPoint-this.startPoint,t=this.yLabelWidth,this.calculateYRange(i),this.buildYLabels(),t<this.yLabelWidth&&this.calculateXLabelRotation()},calculateXLabelRotation:function(){this.ctx.font=this.font;var t,i,e=this.ctx.measureText(this.xLabels[0]).width,s=this.ctx.measureText(this.xLabels[this.xLabels.length-1]).width;if(this.xScalePaddingRight=s/2+3,this.xScalePaddingLeft=e/2>this.yLabelWidth+10?e/2:this.yLabelWidth+10,this.xLabelRotation=0,this.display){var n,o=W(this.ctx,this.font,this.xLabels);this.xLabelWidth=o;for(var a=Math.floor(this.calculateX(1)-this.calculateX(0))-6;this.xLabelWidth>a&&0===this.xLabelRotation||this.xLabelWidth>a&&this.xLabelRotation<=90&&this.xLabelRotation>0;)n=Math.cos(S(this.xLabelRotation)),t=n*e,i=n*s,t+this.fontSize/2>this.yLabelWidth+8&&(this.xScalePaddingLeft=t+this.fontSize/2),this.xScalePaddingRight=this.fontSize/2,this.xLabelRotation++,this.xLabelWidth=n*o;this.xLabelRotation>0&&(this.endPoint-=Math.sin(S(this.xLabelRotation))*o+3)}else this.xLabelWidth=0,this.xScalePaddingRight=this.padding,this.xScalePaddingLeft=this.padding},calculateYRange:c,drawingArea:function(){return this.startPoint-this.endPoint},calculateY:function(t){var i=this.drawingArea()/(this.min-this.max);return this.endPoint-i*(t-this.min)},calculateX:function(t){var i=(this.xLabelRotation>0,this.width-(this.xScalePaddingLeft+this.xScalePaddingRight)),e=i/(this.valuesCount-(this.offsetGridLines?0:1)),s=e*t+this.xScalePaddingLeft;return this.offsetGridLines&&(s+=e/2),Math.round(s)},update:function(t){s.extend(this,t),this.fit()},draw:function(){var t=this.ctx,i=(this.endPoint-this.startPoint)/this.steps,e=Math.round(this.xScalePaddingLeft);this.display&&(t.fillStyle=this.textColor,t.font=this.font,n(this.yLabels,function(n,o){var a=this.endPoint-i*o,h=Math.round(a),l=this.showHorizontalLines;t.textAlign="right",t.textBaseline="middle",this.showLabels&&t.fillText(n,e-10,a),0!==o||l||(l=!0),l&&t.beginPath(),o>0?(t.lineWidth=this.gridLineWidth,t.strokeStyle=this.gridLineColor):(t.lineWidth=this.lineWidth,t.strokeStyle=this.lineColor),h+=s.aliasPixel(t.lineWidth),l&&(t.moveTo(e,h),t.lineTo(this.width,h),t.stroke(),t.closePath()),t.lineWidth=this.lineWidth,t.strokeStyle=this.lineColor,t.beginPath(),t.moveTo(e-5,h),t.lineTo(e,h),t.stroke(),t.closePath()},this),n(this.xLabels,function(i,e){var s=this.calculateX(e)+x(this.lineWidth),n=this.calculateX(e-(this.offsetGridLines?.5:0))+x(this.lineWidth),o=this.xLabelRotation>0,a=this.showVerticalLines;0!==e||a||(a=!0),a&&t.beginPath(),e>0?(t.lineWidth=this.gridLineWidth,t.strokeStyle=this.gridLineColor):(t.lineWidth=this.lineWidth,t.strokeStyle=this.lineColor),a&&(t.moveTo(n,this.endPoint),t.lineTo(n,this.startPoint-3),t.stroke(),t.closePath()),t.lineWidth=this.lineWidth,t.strokeStyle=this.lineColor,t.beginPath(),t.moveTo(n,this.endPoint),t.lineTo(n,this.endPoint+5),t.stroke(),t.closePath(),t.save(),t.translate(s,o?this.endPoint+12:this.endPoint+8),t.rotate(-1*S(this.xLabelRotation)),t.font=this.font,t.textAlign=o?"right":"center",t.textBaseline=o?"middle":"top",t.fillText(i,0,0),t.restore()},this))}}),e.RadialScale=e.Element.extend({initialize:function(){this.size=m([this.height,this.width]),this.drawingArea=this.display?this.size/2-(this.fontSize/2+this.backdropPaddingY):this.size/2},calculateCenterOffset:function(t){var i=this.drawingArea/(this.max-this.min);return(t-this.min)*i},update:function(){this.lineArc?this.drawingArea=this.display?this.size/2-(this.fontSize/2+this.backdropPaddingY):this.size/2:this.setScaleSize(),this.buildYLabels()},buildYLabels:function(){this.yLabels=[];for(var t=v(this.stepValue),i=0;i<=this.steps;i++)this.yLabels.push(C(this.templateString,{value:(this.min+i*this.stepValue).toFixed(t)}))},getCircumference:function(){return 2*Math.PI/this.valuesCount},setScaleSize:function(){var t,i,e,s,n,o,a,h,l,r,c,u,d=m([this.height/2-this.pointLabelFontSize-5,this.width/2]),p=this.width,g=0;for(this.ctx.font=M(this.pointLabelFontSize,this.pointLabelFontStyle,this.pointLabelFontFamily),i=0;i<this.valuesCount;i++)t=this.getPointPosition(i,d),e=this.ctx.measureText(C(this.templateString,{value:this.labels[i]})).width+5,0===i||i===this.valuesCount/2?(s=e/2,t.x+s>p&&(p=t.x+s,n=i),t.x-s<g&&(g=t.x-s,a=i)):i<this.valuesCount/2?t.x+e>p&&(p=t.x+e,n=i):i>this.valuesCount/2&&t.x-e<g&&(g=t.x-e,a=i);l=g,r=Math.ceil(p-this.width),o=this.getIndexAngle(n),h=this.getIndexAngle(a),c=r/Math.sin(o+Math.PI/2),u=l/Math.sin(h+Math.PI/2),c=f(c)?c:0,u=f(u)?u:0,this.drawingArea=d-(u+c)/2,this.setCenterPoint(u,c)},setCenterPoint:function(t,i){var e=this.width-i-this.drawingArea,s=t+this.drawingArea;this.xCenter=(s+e)/2,this.yCenter=this.height/2},getIndexAngle:function(t){var i=2*Math.PI/this.valuesCount;return t*i-Math.PI/2},getPointPosition:function(t,i){var e=this.getIndexAngle(t);return{x:Math.cos(e)*i+this.xCenter,y:Math.sin(e)*i+this.yCenter}},draw:function(){if(this.display){var t=this.ctx;if(n(this.yLabels,function(i,e){if(e>0){var s,n=e*(this.drawingArea/this.steps),o=this.yCenter-n;if(this.lineWidth>0)if(t.strokeStyle=this.lineColor,t.lineWidth=this.lineWidth,this.lineArc)t.beginPath(),t.arc(this.xCenter,this.yCenter,n,0,2*Math.PI),t.closePath(),t.stroke();else{t.beginPath();for(var a=0;a<this.valuesCount;a++)s=this.getPointPosition(a,this.calculateCenterOffset(this.min+e*this.stepValue)),0===a?t.moveTo(s.x,s.y):t.lineTo(s.x,s.y);t.closePath(),t.stroke()}if(this.showLabels){if(t.font=M(this.fontSize,this.fontStyle,this.fontFamily),this.showLabelBackdrop){var h=t.measureText(i).width;t.fillStyle=this.backdropColor,t.fillRect(this.xCenter-h/2-this.backdropPaddingX,o-this.fontSize/2-this.backdropPaddingY,h+2*this.backdropPaddingX,this.fontSize+2*this.backdropPaddingY)}t.textAlign="center",t.textBaseline="middle",t.fillStyle=this.fontColor,t.fillText(i,this.xCenter,o)}}},this),!this.lineArc){t.lineWidth=this.angleLineWidth,t.strokeStyle=this.angleLineColor;for(var i=this.valuesCount-1;i>=0;i--){if(this.angleLineWidth>0){var e=this.getPointPosition(i,this.calculateCenterOffset(this.max));t.beginPath(),t.moveTo(this.xCenter,this.yCenter),t.lineTo(e.x,e.y),t.stroke(),t.closePath()}var s=this.getPointPosition(i,this.calculateCenterOffset(this.max)+5);t.font=M(this.pointLabelFontSize,this.pointLabelFontStyle,this.pointLabelFontFamily),t.fillStyle=this.pointLabelFontColor;var o=this.labels.length,a=this.labels.length/2,h=a/2,l=h>i||i>o-h,r=i===h||i===o-h;t.textAlign=0===i?"center":i===a?"center":a>i?"left":"right",t.textBaseline=r?"middle":l?"bottom":"top",t.fillText(this.labels[i],s.x,s.y)}}}}}),s.addEvent(window,"resize",function(){var t;return function(){clearTimeout(t),t=setTimeout(function(){n(e.instances,function(t){t.options.responsive&&t.resize(t.render,!0)})},50)}}()),p?define(function(){return e}):"object"==typeof module&&module.exports&&(module.exports=e),t.Chart=e,e.noConflict=function(){return t.Chart=i,e}}).call(this),function(){"use strict";var t=this,i=t.Chart,e=i.helpers,s={scaleBeginAtZero:!0,scaleShowGridLines:!0,scaleGridLineColor:"rgba(0,0,0,.05)",scaleGridLineWidth:1,scaleShowHorizontalLines:!0,scaleShowVerticalLines:!0,barShowStroke:!0,barStrokeWidth:2,barValueSpacing:5,barDatasetSpacing:1,legendTemplate:'<ul class="<%=name.toLowerCase()%>-legend"><% for (var i=0; i<datasets.length; i++){%><li><span style="background-color:<%=datasets[i].fillColor%>"></span><%if(datasets[i].label){%><%=datasets[i].label%><%}%></li><%}%></ul>'};i.Type.extend({name:"Bar",defaults:s,initialize:function(t){var s=this.options;this.ScaleClass=i.Scale.extend({offsetGridLines:!0,calculateBarX:function(t,i,e){var n=this.calculateBaseWidth(),o=this.calculateX(e)-n/2,a=this.calculateBarWidth(t);return o+a*i+i*s.barDatasetSpacing+a/2},calculateBaseWidth:function(){return this.calculateX(1)-this.calculateX(0)-2*s.barValueSpacing},calculateBarWidth:function(t){var i=this.calculateBaseWidth()-(t-1)*s.barDatasetSpacing;return i/t}}),this.datasets=[],this.options.showTooltips&&e.bindEvents(this,this.options.tooltipEvents,function(t){var i="mouseout"!==t.type?this.getBarsAtEvent(t):[];this.eachBars(function(t){t.restore(["fillColor","strokeColor"])}),e.each(i,function(t){t.fillColor=t.highlightFill,t.strokeColor=t.highlightStroke}),this.showTooltip(i)}),this.BarClass=i.Rectangle.extend({strokeWidth:this.options.barStrokeWidth,showStroke:this.options.barShowStroke,ctx:this.chart.ctx}),e.each(t.datasets,function(i){var s={label:i.label||null,fillColor:i.fillColor,strokeColor:i.strokeColor,bars:[]};this.datasets.push(s),e.each(i.data,function(e,n){s.bars.push(new this.BarClass({value:e,label:t.labels[n],datasetLabel:i.label,strokeColor:i.strokeColor,fillColor:i.fillColor,highlightFill:i.highlightFill||i.fillColor,highlightStroke:i.highlightStroke||i.strokeColor}))},this)},this),this.buildScale(t.labels),this.BarClass.prototype.base=this.scale.endPoint,this.eachBars(function(t,i,s){e.extend(t,{width:this.scale.calculateBarWidth(this.datasets.length),x:this.scale.calculateBarX(this.datasets.length,s,i),y:this.scale.endPoint}),t.save()},this),this.render()},update:function(){this.scale.update(),e.each(this.activeElements,function(t){t.restore(["fillColor","strokeColor"])}),this.eachBars(function(t){t.save()}),this.render()},eachBars:function(t){e.each(this.datasets,function(i,s){e.each(i.bars,t,this,s)},this)},getBarsAtEvent:function(t){for(var i,s=[],n=e.getRelativePosition(t),o=function(t){s.push(t.bars[i])},a=0;a<this.datasets.length;a++)for(i=0;i<this.datasets[a].bars.length;i++)if(this.datasets[a].bars[i].inRange(n.x,n.y))return e.each(this.datasets,o),s;return s},buildScale:function(t){var i=this,s=function(){var t=[];return i.eachBars(function(i){t.push(i.value)}),t},n={templateString:this.options.scaleLabel,height:this.chart.height,width:this.chart.width,ctx:this.chart.ctx,textColor:this.options.scaleFontColor,fontSize:this.options.scaleFontSize,fontStyle:this.options.scaleFontStyle,fontFamily:this.options.scaleFontFamily,valuesCount:t.length,beginAtZero:this.options.scaleBeginAtZero,integersOnly:this.options.scaleIntegersOnly,calculateYRange:function(t){var i=e.calculateScaleRange(s(),t,this.fontSize,this.beginAtZero,this.integersOnly);e.extend(this,i)},xLabels:t,font:e.fontString(this.options.scaleFontSize,this.options.scaleFontStyle,this.options.scaleFontFamily),lineWidth:this.options.scaleLineWidth,lineColor:this.options.scaleLineColor,showHorizontalLines:this.options.scaleShowHorizontalLines,showVerticalLines:this.options.scaleShowVerticalLines,gridLineWidth:this.options.scaleShowGridLines?this.options.scaleGridLineWidth:0,gridLineColor:this.options.scaleShowGridLines?this.options.scaleGridLineColor:"rgba(0,0,0,0)",padding:this.options.showScale?0:this.options.barShowStroke?this.options.barStrokeWidth:0,showLabels:this.options.scaleShowLabels,display:this.options.showScale};this.options.scaleOverride&&e.extend(n,{calculateYRange:e.noop,steps:this.options.scaleSteps,stepValue:this.options.scaleStepWidth,min:this.options.scaleStartValue,max:this.options.scaleStartValue+this.options.scaleSteps*this.options.scaleStepWidth}),this.scale=new this.ScaleClass(n)},addData:function(t,i){e.each(t,function(t,e){this.datasets[e].bars.push(new this.BarClass({value:t,label:i,x:this.scale.calculateBarX(this.datasets.length,e,this.scale.valuesCount+1),y:this.scale.endPoint,width:this.scale.calculateBarWidth(this.datasets.length),base:this.scale.endPoint,strokeColor:this.datasets[e].strokeColor,fillColor:this.datasets[e].fillColor}))},this),this.scale.addXLabel(i),this.update()},removeData:function(){this.scale.removeXLabel(),e.each(this.datasets,function(t){t.bars.shift()},this),this.update()},reflow:function(){e.extend(this.BarClass.prototype,{y:this.scale.endPoint,base:this.scale.endPoint});
var t=e.extend({height:this.chart.height,width:this.chart.width});this.scale.update(t)},draw:function(t){var i=t||1;this.clear();this.chart.ctx;this.scale.draw(i),e.each(this.datasets,function(t,s){e.each(t.bars,function(t,e){t.hasValue()&&(t.base=this.scale.endPoint,t.transition({x:this.scale.calculateBarX(this.datasets.length,s,e),y:this.scale.calculateY(t.value),width:this.scale.calculateBarWidth(this.datasets.length)},i).draw())},this)},this)}})}.call(this),function(){"use strict";var t=this,i=t.Chart,e=i.helpers,s={segmentShowStroke:!0,segmentStrokeColor:"#fff",segmentStrokeWidth:2,percentageInnerCutout:50,animationSteps:100,animationEasing:"easeOutBounce",animateRotate:!0,animateScale:!1,legendTemplate:'<ul class="<%=name.toLowerCase()%>-legend"><% for (var i=0; i<segments.length; i++){%><li><span style="background-color:<%=segments[i].fillColor%>"></span><%if(segments[i].label){%><%=segments[i].label%><%}%></li><%}%></ul>'};i.Type.extend({name:"Doughnut",defaults:s,initialize:function(t){this.segments=[],this.outerRadius=(e.min([this.chart.width,this.chart.height])-this.options.segmentStrokeWidth/2)/2,this.SegmentArc=i.Arc.extend({ctx:this.chart.ctx,x:this.chart.width/2,y:this.chart.height/2}),this.options.showTooltips&&e.bindEvents(this,this.options.tooltipEvents,function(t){var i="mouseout"!==t.type?this.getSegmentsAtEvent(t):[];e.each(this.segments,function(t){t.restore(["fillColor"])}),e.each(i,function(t){t.fillColor=t.highlightColor}),this.showTooltip(i)}),this.calculateTotal(t),e.each(t,function(t,i){this.addData(t,i,!0)},this),this.render()},getSegmentsAtEvent:function(t){var i=[],s=e.getRelativePosition(t);return e.each(this.segments,function(t){t.inRange(s.x,s.y)&&i.push(t)},this),i},addData:function(t,i,e){var s=i||this.segments.length;this.segments.splice(s,0,new this.SegmentArc({value:t.value,outerRadius:this.options.animateScale?0:this.outerRadius,innerRadius:this.options.animateScale?0:this.outerRadius/100*this.options.percentageInnerCutout,fillColor:t.color,highlightColor:t.highlight||t.color,showStroke:this.options.segmentShowStroke,strokeWidth:this.options.segmentStrokeWidth,strokeColor:this.options.segmentStrokeColor,startAngle:1.5*Math.PI,circumference:this.options.animateRotate?0:this.calculateCircumference(t.value),label:t.label})),e||(this.reflow(),this.update())},calculateCircumference:function(t){return 2*Math.PI*(t/this.total)},calculateTotal:function(t){this.total=0,e.each(t,function(t){this.total+=t.value},this)},update:function(){this.calculateTotal(this.segments),e.each(this.activeElements,function(t){t.restore(["fillColor"])}),e.each(this.segments,function(t){t.save()}),this.render()},removeData:function(t){var i=e.isNumber(t)?t:this.segments.length-1;this.segments.splice(i,1),this.reflow(),this.update()},reflow:function(){e.extend(this.SegmentArc.prototype,{x:this.chart.width/2,y:this.chart.height/2}),this.outerRadius=(e.min([this.chart.width,this.chart.height])-this.options.segmentStrokeWidth/2)/2,e.each(this.segments,function(t){t.update({outerRadius:this.outerRadius,innerRadius:this.outerRadius/100*this.options.percentageInnerCutout})},this)},draw:function(t){var i=t?t:1;this.clear(),e.each(this.segments,function(t,e){t.transition({circumference:this.calculateCircumference(t.value),outerRadius:this.outerRadius,innerRadius:this.outerRadius/100*this.options.percentageInnerCutout},i),t.endAngle=t.startAngle+t.circumference,t.draw(),0===e&&(t.startAngle=1.5*Math.PI),e<this.segments.length-1&&(this.segments[e+1].startAngle=t.endAngle)},this)}}),i.types.Doughnut.extend({name:"Pie",defaults:e.merge(s,{percentageInnerCutout:0})})}.call(this),function(){"use strict";var t=this,i=t.Chart,e=i.helpers,s={scaleShowGridLines:!0,scaleGridLineColor:"rgba(0,0,0,.05)",scaleGridLineWidth:1,scaleShowHorizontalLines:!0,scaleShowVerticalLines:!0,bezierCurve:!0,bezierCurveTension:.4,pointDot:!0,pointDotRadius:4,pointDotStrokeWidth:1,pointHitDetectionRadius:20,datasetStroke:!0,datasetStrokeWidth:2,datasetFill:!0,legendTemplate:'<ul class="<%=name.toLowerCase()%>-legend"><% for (var i=0; i<datasets.length; i++){%><li><span style="background-color:<%=datasets[i].strokeColor%>"></span><%if(datasets[i].label){%><%=datasets[i].label%><%}%></li><%}%></ul>'};i.Type.extend({name:"Line",defaults:s,initialize:function(t){this.PointClass=i.Point.extend({strokeWidth:this.options.pointDotStrokeWidth,radius:this.options.pointDotRadius,display:this.options.pointDot,hitDetectionRadius:this.options.pointHitDetectionRadius,ctx:this.chart.ctx,inRange:function(t){return Math.pow(t-this.x,2)<Math.pow(this.radius+this.hitDetectionRadius,2)}}),this.datasets=[],this.options.showTooltips&&e.bindEvents(this,this.options.tooltipEvents,function(t){var i="mouseout"!==t.type?this.getPointsAtEvent(t):[];this.eachPoints(function(t){t.restore(["fillColor","strokeColor"])}),e.each(i,function(t){t.fillColor=t.highlightFill,t.strokeColor=t.highlightStroke}),this.showTooltip(i)}),e.each(t.datasets,function(i){var s={label:i.label||null,fillColor:i.fillColor,strokeColor:i.strokeColor,pointColor:i.pointColor,pointStrokeColor:i.pointStrokeColor,points:[]};this.datasets.push(s),e.each(i.data,function(e,n){s.points.push(new this.PointClass({value:e,label:t.labels[n],datasetLabel:i.label,strokeColor:i.pointStrokeColor,fillColor:i.pointColor,highlightFill:i.pointHighlightFill||i.pointColor,highlightStroke:i.pointHighlightStroke||i.pointStrokeColor}))},this),this.buildScale(t.labels),this.eachPoints(function(t,i){e.extend(t,{x:this.scale.calculateX(i),y:this.scale.endPoint}),t.save()},this)},this),this.render()},update:function(){this.scale.update(),e.each(this.activeElements,function(t){t.restore(["fillColor","strokeColor"])}),this.eachPoints(function(t){t.save()}),this.render()},eachPoints:function(t){e.each(this.datasets,function(i){e.each(i.points,t,this)},this)},getPointsAtEvent:function(t){var i=[],s=e.getRelativePosition(t);return e.each(this.datasets,function(t){e.each(t.points,function(t){t.inRange(s.x,s.y)&&i.push(t)})},this),i},buildScale:function(t){var s=this,n=function(){var t=[];return s.eachPoints(function(i){t.push(i.value)}),t},o={templateString:this.options.scaleLabel,height:this.chart.height,width:this.chart.width,ctx:this.chart.ctx,textColor:this.options.scaleFontColor,fontSize:this.options.scaleFontSize,fontStyle:this.options.scaleFontStyle,fontFamily:this.options.scaleFontFamily,valuesCount:t.length,beginAtZero:this.options.scaleBeginAtZero,integersOnly:this.options.scaleIntegersOnly,calculateYRange:function(t){var i=e.calculateScaleRange(n(),t,this.fontSize,this.beginAtZero,this.integersOnly);e.extend(this,i)},xLabels:t,font:e.fontString(this.options.scaleFontSize,this.options.scaleFontStyle,this.options.scaleFontFamily),lineWidth:this.options.scaleLineWidth,lineColor:this.options.scaleLineColor,showHorizontalLines:this.options.scaleShowHorizontalLines,showVerticalLines:this.options.scaleShowVerticalLines,gridLineWidth:this.options.scaleShowGridLines?this.options.scaleGridLineWidth:0,gridLineColor:this.options.scaleShowGridLines?this.options.scaleGridLineColor:"rgba(0,0,0,0)",padding:this.options.showScale?0:this.options.pointDotRadius+this.options.pointDotStrokeWidth,showLabels:this.options.scaleShowLabels,display:this.options.showScale};this.options.scaleOverride&&e.extend(o,{calculateYRange:e.noop,steps:this.options.scaleSteps,stepValue:this.options.scaleStepWidth,min:this.options.scaleStartValue,max:this.options.scaleStartValue+this.options.scaleSteps*this.options.scaleStepWidth}),this.scale=new i.Scale(o)},addData:function(t,i){e.each(t,function(t,e){this.datasets[e].points.push(new this.PointClass({value:t,label:i,x:this.scale.calculateX(this.scale.valuesCount+1),y:this.scale.endPoint,strokeColor:this.datasets[e].pointStrokeColor,fillColor:this.datasets[e].pointColor}))},this),this.scale.addXLabel(i),this.update()},removeData:function(){this.scale.removeXLabel(),e.each(this.datasets,function(t){t.points.shift()},this),this.update()},reflow:function(){var t=e.extend({height:this.chart.height,width:this.chart.width});this.scale.update(t)},draw:function(t){var i=t||1;this.clear();var s=this.chart.ctx,n=function(t){return null!==t.value},o=function(t,i,s){return e.findNextWhere(i,n,s)||t},a=function(t,i,s){return e.findPreviousWhere(i,n,s)||t};this.scale.draw(i),e.each(this.datasets,function(t){var h=e.where(t.points,n);e.each(t.points,function(t,e){t.hasValue()&&t.transition({y:this.scale.calculateY(t.value),x:this.scale.calculateX(e)},i)},this),this.options.bezierCurve&&e.each(h,function(t,i){var s=i>0&&i<h.length-1?this.options.bezierCurveTension:0;t.controlPoints=e.splineCurve(a(t,h,i),t,o(t,h,i),s),t.controlPoints.outer.y>this.scale.endPoint?t.controlPoints.outer.y=this.scale.endPoint:t.controlPoints.outer.y<this.scale.startPoint&&(t.controlPoints.outer.y=this.scale.startPoint),t.controlPoints.inner.y>this.scale.endPoint?t.controlPoints.inner.y=this.scale.endPoint:t.controlPoints.inner.y<this.scale.startPoint&&(t.controlPoints.inner.y=this.scale.startPoint)},this),s.lineWidth=this.options.datasetStrokeWidth,s.strokeStyle=t.strokeColor,s.beginPath(),e.each(h,function(t,i){if(0===i)s.moveTo(t.x,t.y);else if(this.options.bezierCurve){var e=a(t,h,i);s.bezierCurveTo(e.controlPoints.outer.x,e.controlPoints.outer.y,t.controlPoints.inner.x,t.controlPoints.inner.y,t.x,t.y)}else s.lineTo(t.x,t.y)},this),s.stroke(),this.options.datasetFill&&h.length>0&&(s.lineTo(h[h.length-1].x,this.scale.endPoint),s.lineTo(h[0].x,this.scale.endPoint),s.fillStyle=t.fillColor,s.closePath(),s.fill()),e.each(h,function(t){t.draw()})},this)}})}.call(this),function(){"use strict";var t=this,i=t.Chart,e=i.helpers,s={scaleShowLabelBackdrop:!0,scaleBackdropColor:"rgba(255,255,255,0.75)",scaleBeginAtZero:!0,scaleBackdropPaddingY:2,scaleBackdropPaddingX:2,scaleShowLine:!0,segmentShowStroke:!0,segmentStrokeColor:"#fff",segmentStrokeWidth:2,animationSteps:100,animationEasing:"easeOutBounce",animateRotate:!0,animateScale:!1,legendTemplate:'<ul class="<%=name.toLowerCase()%>-legend"><% for (var i=0; i<segments.length; i++){%><li><span style="background-color:<%=segments[i].fillColor%>"></span><%if(segments[i].label){%><%=segments[i].label%><%}%></li><%}%></ul>'};i.Type.extend({name:"PolarArea",defaults:s,initialize:function(t){this.segments=[],this.SegmentArc=i.Arc.extend({showStroke:this.options.segmentShowStroke,strokeWidth:this.options.segmentStrokeWidth,strokeColor:this.options.segmentStrokeColor,ctx:this.chart.ctx,innerRadius:0,x:this.chart.width/2,y:this.chart.height/2}),this.scale=new i.RadialScale({display:this.options.showScale,fontStyle:this.options.scaleFontStyle,fontSize:this.options.scaleFontSize,fontFamily:this.options.scaleFontFamily,fontColor:this.options.scaleFontColor,showLabels:this.options.scaleShowLabels,showLabelBackdrop:this.options.scaleShowLabelBackdrop,backdropColor:this.options.scaleBackdropColor,backdropPaddingY:this.options.scaleBackdropPaddingY,backdropPaddingX:this.options.scaleBackdropPaddingX,lineWidth:this.options.scaleShowLine?this.options.scaleLineWidth:0,lineColor:this.options.scaleLineColor,lineArc:!0,width:this.chart.width,height:this.chart.height,xCenter:this.chart.width/2,yCenter:this.chart.height/2,ctx:this.chart.ctx,templateString:this.options.scaleLabel,valuesCount:t.length}),this.updateScaleRange(t),this.scale.update(),e.each(t,function(t,i){this.addData(t,i,!0)},this),this.options.showTooltips&&e.bindEvents(this,this.options.tooltipEvents,function(t){var i="mouseout"!==t.type?this.getSegmentsAtEvent(t):[];e.each(this.segments,function(t){t.restore(["fillColor"])}),e.each(i,function(t){t.fillColor=t.highlightColor}),this.showTooltip(i)}),this.render()},getSegmentsAtEvent:function(t){var i=[],s=e.getRelativePosition(t);return e.each(this.segments,function(t){t.inRange(s.x,s.y)&&i.push(t)},this),i},addData:function(t,i,e){var s=i||this.segments.length;this.segments.splice(s,0,new this.SegmentArc({fillColor:t.color,highlightColor:t.highlight||t.color,label:t.label,value:t.value,outerRadius:this.options.animateScale?0:this.scale.calculateCenterOffset(t.value),circumference:this.options.animateRotate?0:this.scale.getCircumference(),startAngle:1.5*Math.PI})),e||(this.reflow(),this.update())},removeData:function(t){var i=e.isNumber(t)?t:this.segments.length-1;this.segments.splice(i,1),this.reflow(),this.update()},calculateTotal:function(t){this.total=0,e.each(t,function(t){this.total+=t.value},this),this.scale.valuesCount=this.segments.length},updateScaleRange:function(t){var i=[];e.each(t,function(t){i.push(t.value)});var s=this.options.scaleOverride?{steps:this.options.scaleSteps,stepValue:this.options.scaleStepWidth,min:this.options.scaleStartValue,max:this.options.scaleStartValue+this.options.scaleSteps*this.options.scaleStepWidth}:e.calculateScaleRange(i,e.min([this.chart.width,this.chart.height])/2,this.options.scaleFontSize,this.options.scaleBeginAtZero,this.options.scaleIntegersOnly);e.extend(this.scale,s,{size:e.min([this.chart.width,this.chart.height]),xCenter:this.chart.width/2,yCenter:this.chart.height/2})},update:function(){this.calculateTotal(this.segments),e.each(this.segments,function(t){t.save()}),this.render()},reflow:function(){e.extend(this.SegmentArc.prototype,{x:this.chart.width/2,y:this.chart.height/2}),this.updateScaleRange(this.segments),this.scale.update(),e.extend(this.scale,{xCenter:this.chart.width/2,yCenter:this.chart.height/2}),e.each(this.segments,function(t){t.update({outerRadius:this.scale.calculateCenterOffset(t.value)})},this)},draw:function(t){var i=t||1;this.clear(),e.each(this.segments,function(t,e){t.transition({circumference:this.scale.getCircumference(),outerRadius:this.scale.calculateCenterOffset(t.value)},i),t.endAngle=t.startAngle+t.circumference,0===e&&(t.startAngle=1.5*Math.PI),e<this.segments.length-1&&(this.segments[e+1].startAngle=t.endAngle),t.draw()},this),this.scale.draw()}})}.call(this),function(){"use strict";var t=this,i=t.Chart,e=i.helpers;i.Type.extend({name:"Radar",defaults:{scaleShowLine:!0,angleShowLineOut:!0,scaleShowLabels:!1,scaleBeginAtZero:!0,angleLineColor:"rgba(0,0,0,.1)",angleLineWidth:1,pointLabelFontFamily:"'Arial'",pointLabelFontStyle:"normal",pointLabelFontSize:10,pointLabelFontColor:"#666",pointDot:!0,pointDotRadius:3,pointDotStrokeWidth:1,pointHitDetectionRadius:20,datasetStroke:!0,datasetStrokeWidth:2,datasetFill:!0,legendTemplate:'<ul class="<%=name.toLowerCase()%>-legend"><% for (var i=0; i<datasets.length; i++){%><li><span style="background-color:<%=datasets[i].strokeColor%>"></span><%if(datasets[i].label){%><%=datasets[i].label%><%}%></li><%}%></ul>'},initialize:function(t){this.PointClass=i.Point.extend({strokeWidth:this.options.pointDotStrokeWidth,radius:this.options.pointDotRadius,display:this.options.pointDot,hitDetectionRadius:this.options.pointHitDetectionRadius,ctx:this.chart.ctx}),this.datasets=[],this.buildScale(t),this.options.showTooltips&&e.bindEvents(this,this.options.tooltipEvents,function(t){var i="mouseout"!==t.type?this.getPointsAtEvent(t):[];this.eachPoints(function(t){t.restore(["fillColor","strokeColor"])}),e.each(i,function(t){t.fillColor=t.highlightFill,t.strokeColor=t.highlightStroke}),this.showTooltip(i)}),e.each(t.datasets,function(i){var s={label:i.label||null,fillColor:i.fillColor,strokeColor:i.strokeColor,pointColor:i.pointColor,pointStrokeColor:i.pointStrokeColor,points:[]};this.datasets.push(s),e.each(i.data,function(e,n){var o;this.scale.animation||(o=this.scale.getPointPosition(n,this.scale.calculateCenterOffset(e))),s.points.push(new this.PointClass({value:e,label:t.labels[n],datasetLabel:i.label,x:this.options.animation?this.scale.xCenter:o.x,y:this.options.animation?this.scale.yCenter:o.y,strokeColor:i.pointStrokeColor,fillColor:i.pointColor,highlightFill:i.pointHighlightFill||i.pointColor,highlightStroke:i.pointHighlightStroke||i.pointStrokeColor}))},this)},this),this.render()},eachPoints:function(t){e.each(this.datasets,function(i){e.each(i.points,t,this)},this)},getPointsAtEvent:function(t){var i=e.getRelativePosition(t),s=e.getAngleFromPoint({x:this.scale.xCenter,y:this.scale.yCenter},i),n=2*Math.PI/this.scale.valuesCount,o=Math.round((s.angle-1.5*Math.PI)/n),a=[];return(o>=this.scale.valuesCount||0>o)&&(o=0),s.distance<=this.scale.drawingArea&&e.each(this.datasets,function(t){a.push(t.points[o])}),a},buildScale:function(t){this.scale=new i.RadialScale({display:this.options.showScale,fontStyle:this.options.scaleFontStyle,fontSize:this.options.scaleFontSize,fontFamily:this.options.scaleFontFamily,fontColor:this.options.scaleFontColor,showLabels:this.options.scaleShowLabels,showLabelBackdrop:this.options.scaleShowLabelBackdrop,backdropColor:this.options.scaleBackdropColor,backdropPaddingY:this.options.scaleBackdropPaddingY,backdropPaddingX:this.options.scaleBackdropPaddingX,lineWidth:this.options.scaleShowLine?this.options.scaleLineWidth:0,lineColor:this.options.scaleLineColor,angleLineColor:this.options.angleLineColor,angleLineWidth:this.options.angleShowLineOut?this.options.angleLineWidth:0,pointLabelFontColor:this.options.pointLabelFontColor,pointLabelFontSize:this.options.pointLabelFontSize,pointLabelFontFamily:this.options.pointLabelFontFamily,pointLabelFontStyle:this.options.pointLabelFontStyle,height:this.chart.height,width:this.chart.width,xCenter:this.chart.width/2,yCenter:this.chart.height/2,ctx:this.chart.ctx,templateString:this.options.scaleLabel,labels:t.labels,valuesCount:t.datasets[0].data.length}),this.scale.setScaleSize(),this.updateScaleRange(t.datasets),this.scale.buildYLabels()},updateScaleRange:function(t){var i=function(){var i=[];return e.each(t,function(t){t.data?i=i.concat(t.data):e.each(t.points,function(t){i.push(t.value)})}),i}(),s=this.options.scaleOverride?{steps:this.options.scaleSteps,stepValue:this.options.scaleStepWidth,min:this.options.scaleStartValue,max:this.options.scaleStartValue+this.options.scaleSteps*this.options.scaleStepWidth}:e.calculateScaleRange(i,e.min([this.chart.width,this.chart.height])/2,this.options.scaleFontSize,this.options.scaleBeginAtZero,this.options.scaleIntegersOnly);e.extend(this.scale,s)},addData:function(t,i){this.scale.valuesCount++,e.each(t,function(t,e){var s=this.scale.getPointPosition(this.scale.valuesCount,this.scale.calculateCenterOffset(t));this.datasets[e].points.push(new this.PointClass({value:t,label:i,x:s.x,y:s.y,strokeColor:this.datasets[e].pointStrokeColor,fillColor:this.datasets[e].pointColor}))},this),this.scale.labels.push(i),this.reflow(),this.update()},removeData:function(){this.scale.valuesCount--,this.scale.labels.shift(),e.each(this.datasets,function(t){t.points.shift()},this),this.reflow(),this.update()},update:function(){this.eachPoints(function(t){t.save()}),this.reflow(),this.render()},reflow:function(){e.extend(this.scale,{width:this.chart.width,height:this.chart.height,size:e.min([this.chart.width,this.chart.height]),xCenter:this.chart.width/2,yCenter:this.chart.height/2}),this.updateScaleRange(this.datasets),this.scale.setScaleSize(),this.scale.buildYLabels()},draw:function(t){var i=t||1,s=this.chart.ctx;this.clear(),this.scale.draw(),e.each(this.datasets,function(t){e.each(t.points,function(t,e){t.hasValue()&&t.transition(this.scale.getPointPosition(e,this.scale.calculateCenterOffset(t.value)),i)},this),s.lineWidth=this.options.datasetStrokeWidth,s.strokeStyle=t.strokeColor,s.beginPath(),e.each(t.points,function(t,i){0===i?s.moveTo(t.x,t.y):s.lineTo(t.x,t.y)},this),s.closePath(),s.stroke(),s.fillStyle=t.fillColor,s.fill(),e.each(t.points,function(t){t.hasValue()&&t.draw()})},this)}})}.call(this);

/**
 * The Circle Menu object represents a choice menu of multiple menu items. The type of data provider value for a circle menu control should point to a property in the data provider that would follow the same rules as hard coding an array of items.<br><br>
 * <b>Sample Declaration</b><br>
 * <pre>
 * {
 *   component: $ui.CircleMenu,
 *    items: [
 *    {
 *        caption: 'music',
 *        visible: false,
 *        img: 'img/music.png'
 *    },
 *    {
 *        caption: 'maps',
 *        img: 'img/maps.png'
 *    }],
 *    onclick: function(item) {
 *        console.log(item.caption + ' clicked');
 *    }
 *}
 * @namespace CircleMenu
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {$ui.CircleMenuItem[]} [items] - The items property is an array of menu items to be displayed in the control
 * @property {CircleMenuClickEvent} [onclick] - This event fires when an item in the menu is clicked. The parameter passed to the event is [the item]{@link $ui.CircleMenuItem} which was clicked.
 */
function $ui_CircleMenu(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom,'ui-circle-menu');
	
	// Holds our indicators
	object._protected.indicators = [];
	
	// Create our inner scrollable area
	object.dom.inner = document.createElement('div');
	$ui.addClass(object.dom.inner, 'inner');
	object.dom.appendChild(object.dom.inner);
	
	// Create indicator area
	object.dom.indicatorContainer = document.createElement('div');
	$ui.addClass(object.dom.indicatorContainer, 'indicator-container');
	object.dom.appendChild(object.dom.indicatorContainer);
	
	// Items property
	if (object.items == undefined) {
		object.items = [];
	}
	object._protected.items = object.items;
	Object.defineProperty(object, 'items', {
		get: function() {return this._protected.items;},
		set: function() {
			console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','items'));					
		},
		configurable: false}
	);
	
	// Re layout the menu items
	object._recalculateLayout = function() {
		if (this.items.length === 0) return;
		var i,
			x,
			y,
			item,
			coord,
			visibleItems = [],
			offsetHeight = this.dom.offsetHeight,
			offsetWidth = this.dom.offsetWidth,
			coordinates = [];
		// Gather only our visible items
		for (i = 0; i < this.items.length; i++) {
			item = this.items[i];
			if (item.visible == true) {
				visibleItems.push(item);
			}
		}
		var numItems = visibleItems.length,
			numIndicators = Math.ceil(numItems/6),
			indicator,
			size = visibleItems[0].getSize();
			
		// Clear old indicators
		for (i = 0; i < this._protected.indicators.length; i++) {
			indicator = this._protected.indicators[i];
			indicator.parentNode.removeChild(indicator);
		}
		this._protected.indicators = [];
			
		// Draw our page indicators if necessary
		if (numIndicators > 1) {
			this.dom.indicatorContainer.style.display = 'block';
			this.dom.inner.style.cursor = 'pointer';
			// Handle our gestures
			this._protected.hammer = new Hammer(this.dom.inner);
			this._protected.hammer.on('pan', this._onpan);
			this._protected.hammer.on('panend', this._onpanend);
			this._protected.hammer.on('pancancel', this._onpanend);
			this._protected.hammer.on('swipeleft', this._onswipeleft);
			this._protected.hammer.on('swiperight', this._onswiperight);
			// Set our indicators
			for (i = 0; i < numIndicators; i++) {
				indicator = document.createElement('div');
				indicator._index = i;
				$ui.addClass(indicator,'indicator');
				this.dom.indicatorContainer.appendChild(indicator);
				this._protected.indicators.push(indicator);
				indicator.inner = document.createElement('div');
				$ui.addClass(indicator.inner, 'inner theme-circle-menu-indicator');
				if (i == 0) {
					$ui.addClass(indicator.inner,'theme-circle-menu-indicator-selected');
				}
				indicator.appendChild(indicator.inner);
			}
			this._protected.selectedIndicator = this._protected.indicators[0];
			this.dom.indicatorContainer.style.width = (numIndicators * 40) + 'px';
			this.dom.inner.style['-webkit-transition'] = '-webkit-transform 0.1s ease-out';
			this.dom.inner.style['-webkit-transform'] = 'translate3d(0px,0px,0px)';
		} else {
			this.dom.indicatorContainer.style.display = 'none';
			this.dom.inner.style.cursor = 'default';
			this._protected.hammer = undefined;
			this._protected.selectedIndicator = undefined;
		}
		this.dom.inner.style.width = (numIndicators * 100) + '%';
			
		// Determine our layout
		if ($system && $system.isClientDevice) {
			var coord,
				row = 0,
				col = 0,
				maxItems = (numItems > 6) ? 6 : numItems,
				slot = Math.floor(offsetWidth/2),
				xOffset = Math.floor(slot/2 - size/2),
				rowHeight = Math.floor(offsetHeight/3),
				yOffset = Math.floor(rowHeight/2 - size/2);
			// Loop through and set our coordinates
			for (i = 0; i < maxItems; i++) {
				coord = {
					X: (col * slot) + xOffset,
					Y: (row * rowHeight) + yOffset
				};
				coordinates.push(coord);
				col++
				if (col > 1) {
					row++;
					col = 0;
				}
			}
		} else {
			switch (true) {
				case (numItems <= 3):
					var buffer = (numItems === 2) ? Math.floor(size/2) : 0, // This provides some spacing on the left/right
						slot = Math.floor((offsetWidth-(buffer*2))/numItems),
						xOffset = Math.floor(slot/2 - size/2);
					y = Math.floor(offsetHeight/2 - size/2);
					for (i = 0; i < numItems; i++) {
						coord = {
							X: (i * slot) + buffer + xOffset,
							Y: y
						};
						coordinates.push(coord);
					}
					break;
				case (numItems <= 6):
						var slot = Math.floor(offsetWidth/3),
							xOffset = Math.floor(slot/2 - size/2),
							row = Math.floor(offsetHeight/2),
							yOffset = Math.floor(row/2 - size/2);
						// Top row
						for (i = 0; i < 3; i++) {
							coord = {
								X: (i * slot) + xOffset,
								Y: yOffset
							};
							coordinates.push(coord);
						}
						// Now bottom row
						var buffer = ((numItems-3) === 2) ? Math.floor(size/2) : 0;
						slot = Math.floor((offsetWidth-(buffer*2))/(numItems-3));
						xOffset = Math.floor(slot/2 - size/2);
						for (i = 3; i < numItems; i++) {
							coord = {
								X: ((i-3) * slot) + buffer + xOffset,
								Y: row + yOffset
							};
							coordinates.push(coord);
						}
					break;				
				case (numItems > 6):
					var numInserted = 0,
						page = 0;
					while (numInserted < numItems) {
						var slot = Math.floor(offsetWidth/3),
							xOffset = Math.floor(slot/2 - size/2) + (page * offsetWidth),
							row = Math.floor(offsetHeight/2),
							yOffset = Math.floor(row/2 - size/2);
						// Top row
						for (i = 0; (i < 3) && (numInserted < numItems); i++) {
							coord = {
								X: (i * slot) + xOffset,
								Y: yOffset
							};
							coordinates.push(coord);
							numInserted++;
						}
						if (numInserted < numItems) {
							// Now bottom row
							var buffer = ((numItems - numInserted) === 2) ? Math.floor(size/2) : 0,
								numSlots = ((numItems - numInserted) >= 3) ? 3 : (numItems - numInserted);
							slot = Math.floor((offsetWidth-(buffer*2))/numSlots);
							xOffset = Math.floor(slot/2 - size/2) + (page * offsetWidth);
							for (i = 3; (i < numItems) && (numInserted < numItems) && (i < 6); i++) {
								coord = {
									X: ((i-3) * slot) + buffer + xOffset,
									Y: row + yOffset
								};
								coordinates.push(coord);
								numInserted++;
							}
						}
						page++;
					}
					break;
			}
		}
		// Set our coordinates
		for (i = 0; i < visibleItems.length; i++) {
			item = visibleItems[i];
			coord = coordinates[i];
			item.dom.style['-webkit-transform'] = 'translate('+coord.X+'px,'+coord.Y+'px)';
		}
	}.$bind(object);
	
	// Reset our transition flag for menu items to know not to click when in transition
	object._resetTransition = function() {
		this._protected.inTransition = false;
	}.$bind(object);
	
	// Handle the dragging of the menu
	object._onpan = function(event) {
		if (this._protected.selectedIndicator == undefined) return;
		this._protected.inTransition = true;
		if (this._protected.swiping == true) return;
		var location = 0;
		if (this._protected.selectedIndicator._index > 0) {
			location = (this._protected.selectedIndicator._index * this.dom.offsetWidth)*(-1);
		}
		this.dom.inner.style['-webkit-transition'] = '';
		this.dom.inner.style['-webkit-transform'] = 'translate3d('+ (location + event.deltaX) + 'px,0px,0px)';
	}.$bind(object);
	
	// Handle the drag end of the menu
	object._onpanend = function(event) {
		window.setTimeout(this._resetTransition,0);
		// Don't adjust if there was a swipe gesture
		if (this._protected.swiping == true) {
			this._protected.swiping = false;
			return;
		}
		if(Math.abs(event.deltaX) > (this.dom.offsetWidth / 2)) {
			if(event.deltaX > 0) {
				if (this._protected.selectedIndicator && this._protected.selectedIndicator._index > 0) {
					this._decreaseIndicator();
				} else {
					this.dom.inner.style['-webkit-transition'] = '-webkit-transform 0.1s ease-out';
					this.dom.inner.style['-webkit-transform'] = 'translate3d(-'+ (this._protected.selectedIndicator._index * this.dom.offsetWidth) +'px,0px,0px)';
				}
			} else {
				if (this._protected.selectedIndicator && this._protected.selectedIndicator._index < this._protected.indicators.length -1) {
					this._increaseIndicator();
				} else {
					this.dom.inner.style['-webkit-transition'] = '-webkit-transform 0.1s ease-out';
					this.dom.inner.style['-webkit-transform'] = 'translate3d(-'+ (this._protected.selectedIndicator._index * this.dom.offsetWidth) +'px,0px,0px)';
				}
			}	
		} else {
			this.dom.inner.style['-webkit-transition'] = '-webkit-transform 0.1s ease-out';
			this.dom.inner.style['-webkit-transform'] = 'translate3d(-'+ (this._protected.selectedIndicator._index * this.dom.offsetWidth) +'px,0px,0px)';
		}
	}.$bind(object);
	
	// Handle the swipe left of the menu
	object._onswipeleft = function(event) {
		this._protected.swiping = true;
		this._increaseIndicator();
	}.$bind(object);
	
	// Handle the swipe right of the menu
	object._onswiperight = function(event) {
		this._protected.swiping = true;
		this._decreaseIndicator();
	}.$bind(object);
	
	// Increases the indicator location and current selected indicator
	object._increaseIndicator = function() {
		if (this._protected.selectedIndicator == undefined) return;
		if (this._protected.selectedIndicator._index <= this._protected.indicators.length - 2) {
			this._protected.selectedIndicator = this._protected.indicators[this._protected.selectedIndicator._index + 1];
			$ui.addClass(this._protected.selectedIndicator.inner,'theme-circle-menu-indicator-selected');
			var i,
				indicator;
			for (i = 0; i < this._protected.indicators.length; i++) {
				indicator = this._protected.indicators[i];
				if (indicator != this._protected.selectedIndicator) {
					$ui.removeClass(indicator.inner,'theme-circle-menu-indicator-selected');
				}
			}
		} 	
		this.dom.inner.style['-webkit-transition'] = '-webkit-transform 0.1s ease-out';
		this.dom.inner.style['-webkit-transform'] = 'translate3d(-'+ (this._protected.selectedIndicator._index * this.dom.offsetWidth) +'px,0px,0px)';
	}.$bind(object);
	
	// Decreases the indicator location and current selected indicator
	object._decreaseIndicator = function() {
		if (this._protected.selectedIndicator == undefined) return;
		if (this._protected.selectedIndicator._index > 0) {
			this._protected.selectedIndicator = this._protected.indicators[this._protected.selectedIndicator._index - 1];
			$ui.addClass(this._protected.selectedIndicator.inner,'theme-circle-menu-indicator-selected');
			var i,
				indicator;
			for (i = 0; i < this._protected.indicators.length; i++) {
				indicator = this._protected.indicators[i];
				if (indicator != this._protected.selectedIndicator) {
					$ui.removeClass(indicator.inner,'theme-circle-menu-indicator-selected');
				}
			}
		} 	
		this.dom.inner.style['-webkit-transition'] = '-webkit-transform 0.1s ease-out';
		this.dom.inner.style['-webkit-transform'] = 'translate3d(-'+ (this._protected.selectedIndicator._index * this.dom.offsetWidth) +'px,0px,0px)';
	}.$bind(object);
	
	// Private function to add a new item to the list
	object._addItem = function(item) {
		item.parent = this;
		itemDom = new $ui_CircleMenuItem(item, this.screen);
		if (itemDom) {
			this.dom.inner.appendChild(itemDom);
			return true;
		} else {
			return false;
		}
	}.$bind(object);
	
	/** 
	 * You can add an item to the end of the menu by calling the addItem function and passing in an object that matches the a menu item
	 * @function addItem
	 * @memberof $ui.CircleMenu
	 * @param {$ui.CircleMenuItem} item - Item to be added to the menu
	 */
	object.addItem = function(item) {
		if (this._addItem(item)) {
			this.items.push(item);
			return true;
		} else {
			return false;
		}
		this._recalculateLayout();
	}.$bind(object);
	
	/** 
	 * You can refresh all the items in a menu by calling the refreshItems function with an array of new items
	 * @function refreshItems
	 * @memberof $ui.CircleMenu
	 * @param {$ui.CircleMenuItem[]} items - Array of items to refresh the menu
	 */
	object.refreshItems = function(itemArray) {
		if (itemArray == undefined) return; // No data provided
		var i,
			item;
		if (this.items) {
			// Remove all existing items first
			for (i = this.items.length - 1; i >= 0; i--) {
				item = this.items[i];
				try {
					if (item.dom && item.dom.parentNode) {
						item.dom.parentNode.removeChild(item.dom);
					}
				} catch (ex) {
					console.log('$ui.List: ' + ex);
				}
				this.items.pop();
				if (item._destroy) {
					item._destroy();
				}
			}
		}
		this.addItemBatch(itemArray);
	}.$bind(object);
	
	/** 
	 * This function is much like the refreshItems function but instead it loads a list of circle menu items to the end of the current menu and does not replace the existing menu items.
	 * @function addItemBatch
	 * @memberof $ui.CircleMenu
	 * @param {$ui.CircleMenuItem[]} items - Array of items to be added to the menu
	 */
	object.addItemBatch = function(itemArray) {
		var i,
			item;
		// Add all new items into the list
		for (i = 0; i < itemArray.length; i++) {
			item = itemArray[i];
			if (this._addItem(item)) {
				this.items.push(item);
			}
		}
		this._recalculateLayout();
	}.$bind(object);
	
	/** 
	 * Insert item works similar to addItem but instead will insert the item into the menu at the index specified. If an invalid index is specified it will result in failure to insert the item. To insert an item at the top of a menu call insert with the index of 0.
	 * @function insertItem
	 * @memberof $ui.CircleMenu
	 * @param {$ui.CircleMenuItem} item - Item to be inserted into the menu
	 * @param {number} index - Index to insert the item
	 */
	object.insertItem = function(item, index) {
		item.parent = this;
		if (index < 0) {
			return false;
		} else if (this.items.length == 0) {
			this.addItem(item);
			return true;
		} else if (index > this.items.length - 1) {
			this.addItem(item);
			return true;
		} else { // Insert it at the index
			var existingItem = this.items[index],
				itemDom = new $ui_CircleMenuItem(item, this.screen);
			this.items.splice(index, 0, item);
			this.dom.inner.insertBefore(itemDom, existingItem.dom);
			return true;
		} 
		return false;
	}.$bind(object);
	
	// Private function to handle provider updates
	object._providerUpdate = function(value) {
		this.refreshItems(value);
	}.$bind(object);
	
	// Handle resize of screen
	object._onresize = function() {
		this._recalculateLayout();
	}.$bind(object);
	
	// If there is no data provider then just create the items
	if (!object.provider) {
		var i,
			item,
			itemDom;
		for (i = 0; i < object.items.length; i++) {
			item = object.items[i];
			object._addItem(item);
		}
		// Re-calculate once the screen dimensions have been calculated
		setTimeout(object._onresize,0); 
	}	
	
	return object.dom;
}

/**
 * The {@link $ui.CircleMenu} <b>onclick</b> event will fire when the user clicks a menu item
 * @callback CircleMenuClickEvent
 * @param {$ui.CircleMenuItem} item - The menu item that the user clicked
 */
/**
 * A circle menu item is used within a [Circle Menu]{@link $ui.CircleMenu}.  <b>NOTE: It cannot be defined on its own outside of a circle menu</b> 
 * @namespace CircleMenuItem
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {string} caption - Text to appear on the menu item
 * @property {string} img - Path to the image to be displayed in the menu item
 */
function $ui_CircleMenuItem(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom,'menu-item');
	
	// Create inner circle
	object.dom.inner = document.createElement('div');
	object.dom.inner.model = object;
	$ui.addClass(object.dom.inner,'circle theme-border-color theme-screen-background-color');
	object.dom.appendChild(object.dom.inner);
	object.dom.inner.onclick = function(event) {
		if (this.model.parent._protected.inTransition == true) return; // Don't want to click while user is swiping
		this.model._raiseInteractionEvent('data-interaction-click');
		$ui.playTouchSound();
		if (this.model.parent.onclick) {
			this.model.parent.onclick(this.model);
		}
	}
	object.dom.inner.ontouchstart = function() {
		$ui.addClass(this,'theme-brand-background-color');
	}
	object.dom.inner.ontouchend = function() {
		$ui.removeClass(this,'theme-brand-background-color');
	}
	object.dom.inner.ontouchcancel = object.dom.inner.ontouchend;
	if (!$ui.isMobileDevice()) {
		object.dom.inner.onmousedown = object.dom.inner.ontouchstart;
		object.dom.inner.onmouseup = object.dom.inner.ontouchend;
		object.dom.inner.onmouseleave = object.dom.inner.ontouchend;
	}
	// Add our mark for automation
	if (object.id) {
		object.dom.inner.setAttribute('data-interaction-click', object.id);
	}
	
	// Create the icon area 
	object.dom.icon = document.createElement('div');
	$ui.addClass(object.dom.icon,'icon');
	object.dom.inner.appendChild(object.dom.icon);
	
	// Image Property
	if (object.img) {
		object.dom.icon.style.backgroundImage = 'url("'+ object.img + '")';
	}
	object._protected.img = object.img;
	Object.defineProperty(object, 'img', {
		get: function() {return this._protected.img;},
		set: function(value) {
			if (value == this._protected.img) return;
			this._protected.img = value;
			if (value == undefined) {
				this.dom.icon.style.backgroundImage = '';
			} else {
				this.dom.icon.style.backgroundImage = 'url("'+ value + '")';
			}
		},
		configurable: false}
	);
	
	// Caption Property
	object.dom.captionDiv = document.createElement('div');
	$ui.addClass(object.dom.captionDiv,'caption theme-text-color');
	object.dom.appendChild(object.dom.captionDiv);
	if (object.caption) {
		object.dom.captionDiv.textContent = object.caption;
	}
	object._protected.caption = object.caption;
	Object.defineProperty(object, 'caption', {
		get: function() {return this._protected.caption;},
		set: function(value) {
			if (value == this._protected.caption) return;
			this._protected.caption = value;
			if (value == undefined) {
				this.dom.captionDiv.textContent = '';
			} else {
				this.dom.captionDiv.textContent = value;
			}
		},
		configurable: false}
	);
	
	// Returns the size of the menu item
	object.getSize = function() {
		return this.dom.offsetWidth;
	}
	object.getSize = object.getSize.$bind(object);
	
	// Handle Visibility change
	object._setVisible = function(value) {
		if (this.parent) {
			this.parent._recalculateLayout();
		}
	}
	object._setVisible = object._setVisible.$bind(object);
	
	return object.dom;
}
/**
 * A Column represents a column of user interface items in a {@link $ui.ColumnLayout}
 * @namespace Column
 * @memberof $ui
 * @property {number} [span=1] - Specifies the span of the column.
 * @property {$ui.CoreComponent[]} [content] - Specifies the controls to be displayed in this column
*/
function $ui_Column(object, screen){
	$ui_CoreComponent.call(this, object, screen);
	if (object) {
		$ui.addClass(object.dom, 'ui-column');
		
		// Set our span
		if (object.span) {
			object.dom.style.width = (object._spanPercentage * object.span) + '%';
		} else {
			object.dom.style.width = object._spanPercentage + '%';
		}
		
		// content property
		if (object.content == undefined) {
			object.content = [];
		}
		object._protected.content = object.content;
		Object.defineProperty(object, 'content', {
			get: function() {return this._protected.content;},
			set: function() {
				console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','content'));
			},
			configurable: false}
		);
		
		// Now create the content
		var j,
			control;
		for (j = 0; j < object.content.length; j++) {
			control = object.content[j];
			controlDom = $ui.createControl(control, screen);
			if (controlDom) {
				object.dom.appendChild(controlDom);
			}
		}
		
		/** 
		 * Validate all the controls contained in this column (including nested controls) and return the boolean result
		 * @function validate
		 * @memberof $ui.Column
		 * @returns {boolean}
		 */
		object.validate = function() {
			var i,
				control,
				result = true;
			for (i = 0; i < this.content.length; i++) {
				control = this.content[i];
				if (control.validate)  {
					if (control.validate() == false) {
						result = false;
					}
				}
			}
			return result;
		}.$bind(object);
		
		// This function is called to cascade down a visibility change to child controls
		object._cascadeVisibility = function() {
			var i,
				control;			
			for (i = 0; i < this.content.length; i++) {
				control = this.content[i];
				if (control._cascadeVisibility) {
					control._cascadeVisibility();
				} else {
					if (control._onshow) {
						control._onshow();
					}
				}
			}
		}.$bind(object);
		
		// Cascade our visibility when it is set to "true"
		object._setVisible = function(value) {
			if (value == true) {
				this._cascadeVisibility();
			}
		}.$bind(object);
		
		return object.dom;
	}
}

/**
 * A Column layout specifies a set of columns which contain controls.  The number of columns, or their span, will determine the percentage width for each column
 * @namespace ColumnLayout
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {$ui.Column[]} columns - Contains all of the columns for this ColumnLayout
 * @property {boolean} [padding=false] - Specify <b>true</b> if you wish each of the columns to have padding inside them
 * @property {boolean} [fillToParent=false] - If set to <b>true</b> this column layout will grow to 100% of the height of its container.
*/
function $ui_ColumnLayout(object, screen){
	$ui_CoreComponent.call(this, object, screen);
	// Make sure this is only added to a HomeScreen
	if (object) {
		$ui.addClass(object.dom, 'ui-column-layout');
		
		// Check for padding
		if (object.padding == true) {
			$ui.addClass(object.dom, 'padding');
		}
		
		// Columns property
		if (object.columns == undefined) {
			object.columns = [];
		}
		object._protected.columns = object.columns;
		Object.defineProperty(object, 'columns', {
			get: function() {return this._protected.columns;},
			set: function() {
				console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','columns'));
			},
			configurable: false}
		);
		
		// fillToParent property
		if (object.fillToParent != true) {
			object.fillToParent = false;
		} else {
			$ui.addClass(object.dom,'fill');
		}
		object._protected.fillToParent = object.fillToParent;
		Object.defineProperty(object, 'fillToParent', {
			get: function() {return this._protected.fillToParent;},
			set: function(value) {
				if (value == this._protected.fillToParent) return;
				if (value == true) {
					$ui.addClass(this.dom, 'fill');
				} else {
					$ui.removeClass(this.dom,'fill');
				}
				this._protected.fillToParent = value;
			},
			configurable: false}
		);
		
		// Cycle through columns
		var i,
			j,
			column,
			spanPercentage,
			spanCount = 0,
			control,
			controlDom;
		// First move through to understand what a span of 1 is equal to
		for (i = 0; i < object.columns.length; i++) {
			column = object.columns[i];
			if (column.span) {
				spanCount = spanCount + column.span;
			} else {
				spanCount++;
			}
		}
		// Figure out our percentage
		if (spanCount == 0) {
			spanPercentage = 100;
		} else {
			spanPercentage = 100/spanCount;
		}
		// Now create the columns
		for (i = 0; i < object.columns.length; i++) {
			column = object.columns[i];
			column._spanPercentage = spanPercentage;
			if (column.component != $ui.Column) continue;
			new $ui_Column(column, screen);
			object.dom.appendChild(column.dom);
		}
		// Add a div to the end to ensure the container this column layout is embedded in grows to the height of the 
		// tallest column
		object.dom.clearElement = document.createElement('div');
		$ui.addClass(object.dom.clearElement, 'clear-element');
		object.dom.appendChild(object.dom.clearElement);
		
		/** 
		 * Validate all the controls contained in this column layout (including nested controls) and return the boolean result
		 * @function validate
		 * @memberof $ui.ColumnLayout
		 * @returns {boolean}
		 */
		object.validate = function() {
			var i,
				column,
				result = true;
			for (i = 0; i < this.columns.length; i++) {
				column = this.columns[i];
				if (column.validate() == false) {
						result = false;
				}
			}
			return result;
		}.$bind(object);
		
		// This function is called to cascade down a visibility change to child controls
		object._cascadeVisibility = function() {
			var i,
				column;
			for (i = 0; i < this.columns.length; i++) {
				column = this.columns[i];
				if (column._cascadeVisibility) {
					column._cascadeVisibility();
				}
			}
		}.$bind(object);
		
		// Cascade our visibility when it is set to "true"
		object._setVisible = function(value) {
			if (value == true) {
				this._cascadeVisibility();
			}
		}.$bind(object);
		
		return object.dom;	
	}
}

/**
 * The Control Group object represents a grouping of multiple different controls.  This component can be useful when you want to group different controls together for toggling visibility.<br><br>
 * <b>Sample Declaration</b><br>
 * <pre>
 * {
 *   component: $ui.ControlGroup,
 *    id: 'myGrouping',
 *    content: [
 *       {
 *           component: $ui.Header,
 *           caption: 'My Header',
 *       },
 *       {
 *           component: $ui.List,
 *           style: $ui.GenericListItem
 *       }
 *    ]
 *}
 * @namespace ControlGroup
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {$ui.CoreComponent[]} [content] - The content property is an array of control definitions to be displayed in the control
*/
function $ui_ControlGroup(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom,'ui-control-group');
	
	// Content property
	if (object.content == undefined) {
		object.content = [];
	}
	object._protected.content = object.content;
	Object.defineProperty(object, 'content', {
		get: function() {return this._protected.content;},
		set: function() {
			console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','content'));			
		},
		configurable: false}
	);
	if (object.content) {
		var i,
			item,
			itemDom;
		for (i = 0; i < object.content.length; i++) {
			item = object.content[i];
			itemDom = $ui.createControl(item, object.screen);
			if (itemDom) {
				object.dom.appendChild(itemDom);
			}
		}
	}	
	
	return object.dom;
}
/*! Hammer.JS - v2.0.4 - 2014-09-28
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2014 Jorik Tangelder;
 * Licensed under the MIT license */
!function(a,b,c,d){"use strict";function e(a,b,c){return setTimeout(k(a,c),b)}function f(a,b,c){return Array.isArray(a)?(g(a,c[b],c),!0):!1}function g(a,b,c){var e;if(a)if(a.forEach)a.forEach(b,c);else if(a.length!==d)for(e=0;e<a.length;)b.call(c,a[e],e,a),e++;else for(e in a)a.hasOwnProperty(e)&&b.call(c,a[e],e,a)}function h(a,b,c){for(var e=Object.keys(b),f=0;f<e.length;)(!c||c&&a[e[f]]===d)&&(a[e[f]]=b[e[f]]),f++;return a}function i(a,b){return h(a,b,!0)}function j(a,b,c){var d,e=b.prototype;d=a.prototype=Object.create(e),d.constructor=a,d._super=e,c&&h(d,c)}function k(a,b){return function(){return a.apply(b,arguments)}}function l(a,b){return typeof a==kb?a.apply(b?b[0]||d:d,b):a}function m(a,b){return a===d?b:a}function n(a,b,c){g(r(b),function(b){a.addEventListener(b,c,!1)})}function o(a,b,c){g(r(b),function(b){a.removeEventListener(b,c,!1)})}function p(a,b){for(;a;){if(a==b)return!0;a=a.parentNode}return!1}function q(a,b){return a.indexOf(b)>-1}function r(a){return a.trim().split(/\s+/g)}function s(a,b,c){if(a.indexOf&&!c)return a.indexOf(b);for(var d=0;d<a.length;){if(c&&a[d][c]==b||!c&&a[d]===b)return d;d++}return-1}function t(a){return Array.prototype.slice.call(a,0)}function u(a,b,c){for(var d=[],e=[],f=0;f<a.length;){var g=b?a[f][b]:a[f];s(e,g)<0&&d.push(a[f]),e[f]=g,f++}return c&&(d=b?d.sort(function(a,c){return a[b]>c[b]}):d.sort()),d}function v(a,b){for(var c,e,f=b[0].toUpperCase()+b.slice(1),g=0;g<ib.length;){if(c=ib[g],e=c?c+f:b,e in a)return e;g++}return d}function w(){return ob++}function x(a){var b=a.ownerDocument;return b.defaultView||b.parentWindow}function y(a,b){var c=this;this.manager=a,this.callback=b,this.element=a.element,this.target=a.options.inputTarget,this.domHandler=function(b){l(a.options.enable,[a])&&c.handler(b)},this.init()}function z(a){var b,c=a.options.inputClass;return new(b=c?c:rb?N:sb?Q:qb?S:M)(a,A)}function A(a,b,c){var d=c.pointers.length,e=c.changedPointers.length,f=b&yb&&d-e===0,g=b&(Ab|Bb)&&d-e===0;c.isFirst=!!f,c.isFinal=!!g,f&&(a.session={}),c.eventType=b,B(a,c),a.emit("hammer.input",c),a.recognize(c),a.session.prevInput=c}function B(a,b){var c=a.session,d=b.pointers,e=d.length;c.firstInput||(c.firstInput=E(b)),e>1&&!c.firstMultiple?c.firstMultiple=E(b):1===e&&(c.firstMultiple=!1);var f=c.firstInput,g=c.firstMultiple,h=g?g.center:f.center,i=b.center=F(d);b.timeStamp=nb(),b.deltaTime=b.timeStamp-f.timeStamp,b.angle=J(h,i),b.distance=I(h,i),C(c,b),b.offsetDirection=H(b.deltaX,b.deltaY),b.scale=g?L(g.pointers,d):1,b.rotation=g?K(g.pointers,d):0,D(c,b);var j=a.element;p(b.srcEvent.target,j)&&(j=b.srcEvent.target),b.target=j}function C(a,b){var c=b.center,d=a.offsetDelta||{},e=a.prevDelta||{},f=a.prevInput||{};(b.eventType===yb||f.eventType===Ab)&&(e=a.prevDelta={x:f.deltaX||0,y:f.deltaY||0},d=a.offsetDelta={x:c.x,y:c.y}),b.deltaX=e.x+(c.x-d.x),b.deltaY=e.y+(c.y-d.y)}function D(a,b){var c,e,f,g,h=a.lastInterval||b,i=b.timeStamp-h.timeStamp;if(b.eventType!=Bb&&(i>xb||h.velocity===d)){var j=h.deltaX-b.deltaX,k=h.deltaY-b.deltaY,l=G(i,j,k);e=l.x,f=l.y,c=mb(l.x)>mb(l.y)?l.x:l.y,g=H(j,k),a.lastInterval=b}else c=h.velocity,e=h.velocityX,f=h.velocityY,g=h.direction;b.velocity=c,b.velocityX=e,b.velocityY=f,b.direction=g}function E(a){for(var b=[],c=0;c<a.pointers.length;)b[c]={clientX:lb(a.pointers[c].clientX),clientY:lb(a.pointers[c].clientY)},c++;return{timeStamp:nb(),pointers:b,center:F(b),deltaX:a.deltaX,deltaY:a.deltaY}}function F(a){var b=a.length;if(1===b)return{x:lb(a[0].clientX),y:lb(a[0].clientY)};for(var c=0,d=0,e=0;b>e;)c+=a[e].clientX,d+=a[e].clientY,e++;return{x:lb(c/b),y:lb(d/b)}}function G(a,b,c){return{x:b/a||0,y:c/a||0}}function H(a,b){return a===b?Cb:mb(a)>=mb(b)?a>0?Db:Eb:b>0?Fb:Gb}function I(a,b,c){c||(c=Kb);var d=b[c[0]]-a[c[0]],e=b[c[1]]-a[c[1]];return Math.sqrt(d*d+e*e)}function J(a,b,c){c||(c=Kb);var d=b[c[0]]-a[c[0]],e=b[c[1]]-a[c[1]];return 180*Math.atan2(e,d)/Math.PI}function K(a,b){return J(b[1],b[0],Lb)-J(a[1],a[0],Lb)}function L(a,b){return I(b[0],b[1],Lb)/I(a[0],a[1],Lb)}function M(){this.evEl=Nb,this.evWin=Ob,this.allow=!0,this.pressed=!1,y.apply(this,arguments)}function N(){this.evEl=Rb,this.evWin=Sb,y.apply(this,arguments),this.store=this.manager.session.pointerEvents=[]}function O(){this.evTarget=Ub,this.evWin=Vb,this.started=!1,y.apply(this,arguments)}function P(a,b){var c=t(a.touches),d=t(a.changedTouches);return b&(Ab|Bb)&&(c=u(c.concat(d),"identifier",!0)),[c,d]}function Q(){this.evTarget=Xb,this.targetIds={},y.apply(this,arguments)}function R(a,b){var c=t(a.touches),d=this.targetIds;if(b&(yb|zb)&&1===c.length)return d[c[0].identifier]=!0,[c,c];var e,f,g=t(a.changedTouches),h=[],i=this.target;if(f=c.filter(function(a){return p(a.target,i)}),b===yb)for(e=0;e<f.length;)d[f[e].identifier]=!0,e++;for(e=0;e<g.length;)d[g[e].identifier]&&h.push(g[e]),b&(Ab|Bb)&&delete d[g[e].identifier],e++;return h.length?[u(f.concat(h),"identifier",!0),h]:void 0}function S(){y.apply(this,arguments);var a=k(this.handler,this);this.touch=new Q(this.manager,a),this.mouse=new M(this.manager,a)}function T(a,b){this.manager=a,this.set(b)}function U(a){if(q(a,bc))return bc;var b=q(a,cc),c=q(a,dc);return b&&c?cc+" "+dc:b||c?b?cc:dc:q(a,ac)?ac:_b}function V(a){this.id=w(),this.manager=null,this.options=i(a||{},this.defaults),this.options.enable=m(this.options.enable,!0),this.state=ec,this.simultaneous={},this.requireFail=[]}function W(a){return a&jc?"cancel":a&hc?"end":a&gc?"move":a&fc?"start":""}function X(a){return a==Gb?"down":a==Fb?"up":a==Db?"left":a==Eb?"right":""}function Y(a,b){var c=b.manager;return c?c.get(a):a}function Z(){V.apply(this,arguments)}function $(){Z.apply(this,arguments),this.pX=null,this.pY=null}function _(){Z.apply(this,arguments)}function ab(){V.apply(this,arguments),this._timer=null,this._input=null}function bb(){Z.apply(this,arguments)}function cb(){Z.apply(this,arguments)}function db(){V.apply(this,arguments),this.pTime=!1,this.pCenter=!1,this._timer=null,this._input=null,this.count=0}function eb(a,b){return b=b||{},b.recognizers=m(b.recognizers,eb.defaults.preset),new fb(a,b)}function fb(a,b){b=b||{},this.options=i(b,eb.defaults),this.options.inputTarget=this.options.inputTarget||a,this.handlers={},this.session={},this.recognizers=[],this.element=a,this.input=z(this),this.touchAction=new T(this,this.options.touchAction),gb(this,!0),g(b.recognizers,function(a){var b=this.add(new a[0](a[1]));a[2]&&b.recognizeWith(a[2]),a[3]&&b.requireFailure(a[3])},this)}function gb(a,b){var c=a.element;g(a.options.cssProps,function(a,d){c.style[v(c.style,d)]=b?a:""})}function hb(a,c){var d=b.createEvent("Event");d.initEvent(a,!0,!0),d.gesture=c,c.target.dispatchEvent(d)}var ib=["","webkit","moz","MS","ms","o"],jb=b.createElement("div"),kb="function",lb=Math.round,mb=Math.abs,nb=Date.now,ob=1,pb=/mobile|tablet|ip(ad|hone|od)|android/i,qb="ontouchstart"in a,rb=v(a,"PointerEvent")!==d,sb=qb&&pb.test(navigator.userAgent),tb="touch",ub="pen",vb="mouse",wb="kinect",xb=25,yb=1,zb=2,Ab=4,Bb=8,Cb=1,Db=2,Eb=4,Fb=8,Gb=16,Hb=Db|Eb,Ib=Fb|Gb,Jb=Hb|Ib,Kb=["x","y"],Lb=["clientX","clientY"];y.prototype={handler:function(){},init:function(){this.evEl&&n(this.element,this.evEl,this.domHandler),this.evTarget&&n(this.target,this.evTarget,this.domHandler),this.evWin&&n(x(this.element),this.evWin,this.domHandler)},destroy:function(){this.evEl&&o(this.element,this.evEl,this.domHandler),this.evTarget&&o(this.target,this.evTarget,this.domHandler),this.evWin&&o(x(this.element),this.evWin,this.domHandler)}};var Mb={mousedown:yb,mousemove:zb,mouseup:Ab},Nb="mousedown",Ob="mousemove mouseup";j(M,y,{handler:function(a){var b=Mb[a.type];b&yb&&0===a.button&&(this.pressed=!0),b&zb&&1!==a.which&&(b=Ab),this.pressed&&this.allow&&(b&Ab&&(this.pressed=!1),this.callback(this.manager,b,{pointers:[a],changedPointers:[a],pointerType:vb,srcEvent:a}))}});var Pb={pointerdown:yb,pointermove:zb,pointerup:Ab,pointercancel:Bb,pointerout:Bb},Qb={2:tb,3:ub,4:vb,5:wb},Rb="pointerdown",Sb="pointermove pointerup pointercancel";a.MSPointerEvent&&(Rb="MSPointerDown",Sb="MSPointerMove MSPointerUp MSPointerCancel"),j(N,y,{handler:function(a){var b=this.store,c=!1,d=a.type.toLowerCase().replace("ms",""),e=Pb[d],f=Qb[a.pointerType]||a.pointerType,g=f==tb,h=s(b,a.pointerId,"pointerId");e&yb&&(0===a.button||g)?0>h&&(b.push(a),h=b.length-1):e&(Ab|Bb)&&(c=!0),0>h||(b[h]=a,this.callback(this.manager,e,{pointers:b,changedPointers:[a],pointerType:f,srcEvent:a}),c&&b.splice(h,1))}});var Tb={touchstart:yb,touchmove:zb,touchend:Ab,touchcancel:Bb},Ub="touchstart",Vb="touchstart touchmove touchend touchcancel";j(O,y,{handler:function(a){var b=Tb[a.type];if(b===yb&&(this.started=!0),this.started){var c=P.call(this,a,b);b&(Ab|Bb)&&c[0].length-c[1].length===0&&(this.started=!1),this.callback(this.manager,b,{pointers:c[0],changedPointers:c[1],pointerType:tb,srcEvent:a})}}});var Wb={touchstart:yb,touchmove:zb,touchend:Ab,touchcancel:Bb},Xb="touchstart touchmove touchend touchcancel";j(Q,y,{handler:function(a){var b=Wb[a.type],c=R.call(this,a,b);c&&this.callback(this.manager,b,{pointers:c[0],changedPointers:c[1],pointerType:tb,srcEvent:a})}}),j(S,y,{handler:function(a,b,c){var d=c.pointerType==tb,e=c.pointerType==vb;if(d)this.mouse.allow=!1;else if(e&&!this.mouse.allow)return;b&(Ab|Bb)&&(this.mouse.allow=!0),this.callback(a,b,c)},destroy:function(){this.touch.destroy(),this.mouse.destroy()}});var Yb=v(jb.style,"touchAction"),Zb=Yb!==d,$b="compute",_b="auto",ac="manipulation",bc="none",cc="pan-x",dc="pan-y";T.prototype={set:function(a){a==$b&&(a=this.compute()),Zb&&(this.manager.element.style[Yb]=a),this.actions=a.toLowerCase().trim()},update:function(){this.set(this.manager.options.touchAction)},compute:function(){var a=[];return g(this.manager.recognizers,function(b){l(b.options.enable,[b])&&(a=a.concat(b.getTouchAction()))}),U(a.join(" "))},preventDefaults:function(a){if(!Zb){var b=a.srcEvent,c=a.offsetDirection;if(this.manager.session.prevented)return void b.preventDefault();var d=this.actions,e=q(d,bc),f=q(d,dc),g=q(d,cc);return e||f&&c&Hb||g&&c&Ib?this.preventSrc(b):void 0}},preventSrc:function(a){this.manager.session.prevented=!0,a.preventDefault()}};var ec=1,fc=2,gc=4,hc=8,ic=hc,jc=16,kc=32;V.prototype={defaults:{},set:function(a){return h(this.options,a),this.manager&&this.manager.touchAction.update(),this},recognizeWith:function(a){if(f(a,"recognizeWith",this))return this;var b=this.simultaneous;return a=Y(a,this),b[a.id]||(b[a.id]=a,a.recognizeWith(this)),this},dropRecognizeWith:function(a){return f(a,"dropRecognizeWith",this)?this:(a=Y(a,this),delete this.simultaneous[a.id],this)},requireFailure:function(a){if(f(a,"requireFailure",this))return this;var b=this.requireFail;return a=Y(a,this),-1===s(b,a)&&(b.push(a),a.requireFailure(this)),this},dropRequireFailure:function(a){if(f(a,"dropRequireFailure",this))return this;a=Y(a,this);var b=s(this.requireFail,a);return b>-1&&this.requireFail.splice(b,1),this},hasRequireFailures:function(){return this.requireFail.length>0},canRecognizeWith:function(a){return!!this.simultaneous[a.id]},emit:function(a){function b(b){c.manager.emit(c.options.event+(b?W(d):""),a)}var c=this,d=this.state;hc>d&&b(!0),b(),d>=hc&&b(!0)},tryEmit:function(a){return this.canEmit()?this.emit(a):void(this.state=kc)},canEmit:function(){for(var a=0;a<this.requireFail.length;){if(!(this.requireFail[a].state&(kc|ec)))return!1;a++}return!0},recognize:function(a){var b=h({},a);return l(this.options.enable,[this,b])?(this.state&(ic|jc|kc)&&(this.state=ec),this.state=this.process(b),void(this.state&(fc|gc|hc|jc)&&this.tryEmit(b))):(this.reset(),void(this.state=kc))},process:function(){},getTouchAction:function(){},reset:function(){}},j(Z,V,{defaults:{pointers:1},attrTest:function(a){var b=this.options.pointers;return 0===b||a.pointers.length===b},process:function(a){var b=this.state,c=a.eventType,d=b&(fc|gc),e=this.attrTest(a);return d&&(c&Bb||!e)?b|jc:d||e?c&Ab?b|hc:b&fc?b|gc:fc:kc}}),j($,Z,{defaults:{event:"pan",threshold:10,pointers:1,direction:Jb},getTouchAction:function(){var a=this.options.direction,b=[];return a&Hb&&b.push(dc),a&Ib&&b.push(cc),b},directionTest:function(a){var b=this.options,c=!0,d=a.distance,e=a.direction,f=a.deltaX,g=a.deltaY;return e&b.direction||(b.direction&Hb?(e=0===f?Cb:0>f?Db:Eb,c=f!=this.pX,d=Math.abs(a.deltaX)):(e=0===g?Cb:0>g?Fb:Gb,c=g!=this.pY,d=Math.abs(a.deltaY))),a.direction=e,c&&d>b.threshold&&e&b.direction},attrTest:function(a){return Z.prototype.attrTest.call(this,a)&&(this.state&fc||!(this.state&fc)&&this.directionTest(a))},emit:function(a){this.pX=a.deltaX,this.pY=a.deltaY;var b=X(a.direction);b&&this.manager.emit(this.options.event+b,a),this._super.emit.call(this,a)}}),j(_,Z,{defaults:{event:"pinch",threshold:0,pointers:2},getTouchAction:function(){return[bc]},attrTest:function(a){return this._super.attrTest.call(this,a)&&(Math.abs(a.scale-1)>this.options.threshold||this.state&fc)},emit:function(a){if(this._super.emit.call(this,a),1!==a.scale){var b=a.scale<1?"in":"out";this.manager.emit(this.options.event+b,a)}}}),j(ab,V,{defaults:{event:"press",pointers:1,time:500,threshold:5},getTouchAction:function(){return[_b]},process:function(a){var b=this.options,c=a.pointers.length===b.pointers,d=a.distance<b.threshold,f=a.deltaTime>b.time;if(this._input=a,!d||!c||a.eventType&(Ab|Bb)&&!f)this.reset();else if(a.eventType&yb)this.reset(),this._timer=e(function(){this.state=ic,this.tryEmit()},b.time,this);else if(a.eventType&Ab)return ic;return kc},reset:function(){clearTimeout(this._timer)},emit:function(a){this.state===ic&&(a&&a.eventType&Ab?this.manager.emit(this.options.event+"up",a):(this._input.timeStamp=nb(),this.manager.emit(this.options.event,this._input)))}}),j(bb,Z,{defaults:{event:"rotate",threshold:0,pointers:2},getTouchAction:function(){return[bc]},attrTest:function(a){return this._super.attrTest.call(this,a)&&(Math.abs(a.rotation)>this.options.threshold||this.state&fc)}}),j(cb,Z,{defaults:{event:"swipe",threshold:10,velocity:.65,direction:Hb|Ib,pointers:1},getTouchAction:function(){return $.prototype.getTouchAction.call(this)},attrTest:function(a){var b,c=this.options.direction;return c&(Hb|Ib)?b=a.velocity:c&Hb?b=a.velocityX:c&Ib&&(b=a.velocityY),this._super.attrTest.call(this,a)&&c&a.direction&&a.distance>this.options.threshold&&mb(b)>this.options.velocity&&a.eventType&Ab},emit:function(a){var b=X(a.direction);b&&this.manager.emit(this.options.event+b,a),this.manager.emit(this.options.event,a)}}),j(db,V,{defaults:{event:"tap",pointers:1,taps:1,interval:300,time:250,threshold:2,posThreshold:10},getTouchAction:function(){return[ac]},process:function(a){var b=this.options,c=a.pointers.length===b.pointers,d=a.distance<b.threshold,f=a.deltaTime<b.time;if(this.reset(),a.eventType&yb&&0===this.count)return this.failTimeout();if(d&&f&&c){if(a.eventType!=Ab)return this.failTimeout();var g=this.pTime?a.timeStamp-this.pTime<b.interval:!0,h=!this.pCenter||I(this.pCenter,a.center)<b.posThreshold;this.pTime=a.timeStamp,this.pCenter=a.center,h&&g?this.count+=1:this.count=1,this._input=a;var i=this.count%b.taps;if(0===i)return this.hasRequireFailures()?(this._timer=e(function(){this.state=ic,this.tryEmit()},b.interval,this),fc):ic}return kc},failTimeout:function(){return this._timer=e(function(){this.state=kc},this.options.interval,this),kc},reset:function(){clearTimeout(this._timer)},emit:function(){this.state==ic&&(this._input.tapCount=this.count,this.manager.emit(this.options.event,this._input))}}),eb.VERSION="2.0.4",eb.defaults={domEvents:!1,touchAction:$b,enable:!0,inputTarget:null,inputClass:null,preset:[[bb,{enable:!1}],[_,{enable:!1},["rotate"]],[cb,{direction:Hb}],[$,{direction:Hb},["swipe"]],[db],[db,{event:"doubletap",taps:2},["tap"]],[ab]],cssProps:{userSelect:"none",touchSelect:"none",touchCallout:"none",contentZooming:"none",userDrag:"none",tapHighlightColor:"rgba(0,0,0,0)"}};var lc=1,mc=2;fb.prototype={set:function(a){return h(this.options,a),a.touchAction&&this.touchAction.update(),a.inputTarget&&(this.input.destroy(),this.input.target=a.inputTarget,this.input.init()),this},stop:function(a){this.session.stopped=a?mc:lc},recognize:function(a){var b=this.session;if(!b.stopped){this.touchAction.preventDefaults(a);var c,d=this.recognizers,e=b.curRecognizer;(!e||e&&e.state&ic)&&(e=b.curRecognizer=null);for(var f=0;f<d.length;)c=d[f],b.stopped===mc||e&&c!=e&&!c.canRecognizeWith(e)?c.reset():c.recognize(a),!e&&c.state&(fc|gc|hc)&&(e=b.curRecognizer=c),f++}},get:function(a){if(a instanceof V)return a;for(var b=this.recognizers,c=0;c<b.length;c++)if(b[c].options.event==a)return b[c];return null},add:function(a){if(f(a,"add",this))return this;var b=this.get(a.options.event);return b&&this.remove(b),this.recognizers.push(a),a.manager=this,this.touchAction.update(),a},remove:function(a){if(f(a,"remove",this))return this;var b=this.recognizers;return a=this.get(a),b.splice(s(b,a),1),this.touchAction.update(),this},on:function(a,b){var c=this.handlers;return g(r(a),function(a){c[a]=c[a]||[],c[a].push(b)}),this},off:function(a,b){var c=this.handlers;return g(r(a),function(a){b?c[a].splice(s(c[a],b),1):delete c[a]}),this},emit:function(a,b){this.options.domEvents&&hb(a,b);var c=this.handlers[a]&&this.handlers[a].slice();if(c&&c.length){b.type=a,b.preventDefault=function(){b.srcEvent.preventDefault()};for(var d=0;d<c.length;)c[d](b),d++}},destroy:function(){this.element&&gb(this,!1),this.handlers={},this.session={},this.input.destroy(),this.element=null}},h(eb,{INPUT_START:yb,INPUT_MOVE:zb,INPUT_END:Ab,INPUT_CANCEL:Bb,STATE_POSSIBLE:ec,STATE_BEGAN:fc,STATE_CHANGED:gc,STATE_ENDED:hc,STATE_RECOGNIZED:ic,STATE_CANCELLED:jc,STATE_FAILED:kc,DIRECTION_NONE:Cb,DIRECTION_LEFT:Db,DIRECTION_RIGHT:Eb,DIRECTION_UP:Fb,DIRECTION_DOWN:Gb,DIRECTION_HORIZONTAL:Hb,DIRECTION_VERTICAL:Ib,DIRECTION_ALL:Jb,Manager:fb,Input:y,TouchAction:T,TouchInput:Q,MouseInput:M,PointerEventInput:N,TouchMouseInput:S,SingleTouchInput:O,Recognizer:V,AttrRecognizer:Z,Tap:db,Pan:$,Swipe:cb,Pinch:_,Rotate:bb,Press:ab,on:n,off:o,each:g,merge:i,extend:h,inherit:j,bindFn:k,prefixed:v}),typeof define==kb&&define.amd?define(function(){return eb}):"undefined"!=typeof module&&module.exports?module.exports=eb:a[c]=eb}(window,document,"Hammer");
//# sourceMappingURL=hammer.min.map
$ui.themeDark = {
	backgroundImageColor: '#D94646',
	inHeadUnit: true,
	chart: { // Not in CSS because charts are <canvas>
		color: '#747474', //#F0F0F0
		color_OK: '#D94646',//#FAD60A
		color_GOOD: '#D94646',//#FDBF2F
		color_GREAT: '#D94646', //#A3D525
		color_RANDOM1: '#D94646', //#97BBCD
	},
	variables: [
		{
			name: '@brand-color',
			value: '#D94646'
		},
		{
			name: '@highlight-text-color',
			value: '#FFFFFF'
		},
		{
			name: '@foreground-color',
			value: '#FFFFFF'
		},
		{
			name: '@border-color',
			value: '#FFFFFF'
		},
		{
			name: '@background-color',
			value: '#000000'
		},
		{
			name: '@dark-color',
			value: '#747474'
		},
		{
			name: '@profile-wedge-color',
			value: '#D94646'// #FDBF2F
		},
		{
			name: '@green-color',
			value: '#779933'
		}
	],
	classList: [
		{
			className: '.theme-border-color',
			properties: [
				{
					name: 'border-color',
					value: '@border-color !important'
				}
			]
		},
		{
			className: '.theme-brand-border-color',
			properties: [
				{
					name: 'border-color',
					value: '@brand-color !important'
				}
			]
		},
		{
			className: '.theme-tile-border-color',
			properties: [
				{
					name: 'border-color',
					value: '@brand-color !important'
				}
			]
		},
		{
			className: '.theme-dark-border-color',
			properties: [
				{
					name: 'border-color',
					value: '@dark-color !important'
				}
			]
		},
		{
			className: '.theme-text-color',
			properties: [
				{
					name: 'color',
					value: '@foreground-color'
				}
			]
		},
		{
			className: '.theme-dark-text-color',
			properties: [
				{
					name: 'color',
					value: '@dark-color'
				}
			]
		},
		{
			className: '.theme-highlight-text-color',
			properties: [
				{
					name: 'color',
					value: '@highlight-text-color'
				}
			]
		},
		{
			className: '.theme-brand-text-color',
			properties: [
				{
					name: 'color',
					value: '@brand-color'
				}
			]
		},
		{
			className: '.theme-hint-text-color',
			properties: [
				{
					name: 'color',
					value: '#999999'
				}
			]
		},
		{
			className: '.theme-warning-text-color',
			properties: [
				{
					name: 'color',
					value: 'red'
				}
			]
		},
		{
			className: '.theme-screen-background-color',
			properties: [
				{
					name: 'background-color',
					value: '@background-color'
				}
			]
		},
		{
			className: '.theme-brand-background-color',
			properties: [
				{
					name: 'background-color',
					value: '@brand-color'
				}
			]
		},
		{
			className: '.theme-light-background-color',
			properties: [
				{
					name: 'background-color',
					value: '@foreground-color'
				}
			]
		},
		{
			className: '.theme-dark-background-color',
			properties: [
				{
					name: 'background-color',
					value: '@dark-color'
				}
			]
		},
		/****************  Call Button ******************/
		{
			className: '.theme-call-button',
			properties: [
				{
					name: 'background-color',
					value: '@green-color'
				}
			]
		},
		/****************  Generic List Items ******************/
		{
			className: '.theme-generic-list-accent-color',
			properties: [
				{
					name: 'color',
					value: '@brand-color'
				}
			]
		},
		/****************  Segmented Control ******************/
		{
			className: '.theme-segmented-control',
			properties: [
				{
					name: 'border-color',
					value: '@foreground-color'
				},
				{
					name: 'background-color',
					value: '@background-color'
				},
				{
					name: 'color',
					value: '@foreground-color'
				}
			]
		},
		/****************  Posts ******************/
		{
			className: '.theme-post-control',
			properties: [
				{
					name: 'color',
					value: '#D3D3D3'
				},
				{
					name: 'background-color',
					value: '@background-color'
				}
			]
		},
		/****************  Profile ******************/
		{
			className: '.theme-profile-vehicle-background-color',
			properties: [
				{
					name: 'background-color',
					value: '@background-color' // Light theme should be same as border color
				}
			]
		},
		{
			className: '.theme-profile-wedge-background-color',
			properties: [
				{
					name: 'background-color',
					value: '@profile-wedge-color'
				}
			]
		},
		{
			className: '.theme-profile-rank',
			properties: [
				{
					name: 'background-color',
					value: '@profile-wedge-color'
				},
				{
					name: 'color',
					value: '@highlight-text-color'
				}
			]
		},
		{
			className: '.theme-profile-rank-text-color',
			properties: [
				{
					name: 'color',
					value: '@highlight-text-color' // Light theme should be @dark-color
				}
			]
		},
		{
			className: '.theme-profile-label-text-color',
			properties: [
				{
					name: 'color',
					value: '@border-color' 
				}
			]
		},
		{
			className: '.theme-profile-stats',
			properties: [
				{
					name: 'border-color',
					value: '@brand-color' // Light theme should be @border-color
				},
				{
					name: 'background-color',
					value: '@background-color'
				}
			]
		},
		{
			className: '.theme-profile-number-color',
			properties: [
				{
					name: 'color',
					value: '@profile-wedge-color'
				}
			]
		},
		{
			className: '.theme-profile-avatar',
			properties: [
				{
					name: 'background-color',
					value: '@dark-color' // Light theme should be @border-color
				},
				{
					name: 'border-color',
					value: '@brand-color' // Light theme should be white
				},
				{
					name: 'box-shadow',
					value: 'inherit' // Light theme should be 0px 0px 7px #B6B6B6; 
				}
			]
		},
		/****************  On Off Switch ******************/
		{
			className: '.theme-on-off-switch',
			properties: [
				{
					name: 'background-image',
					value: 'linear-gradient(to top, @dark-color, #B9B9B9 80%);' 
				}
			]
		},
		{
			className: '.theme-on-off-switch-inner-ring',
			properties: [
				{
					name: 'border-color',
					value: '@background-color' 
				},
				{
					name: 'background-image',
					value: 'linear-gradient(to top,#B9B9B9,#5c5c5c 25%);' 
				}
			]
		},
		{
			className: '.theme-on-off-switch-inner-ring-on',
			properties: [
				{
					name: 'border-color',
					value: '@background-color' 
				},
				{
					name: 'background-image',
					value: 'linear-gradient(to bottom, #B9B9B9, #5c5c5c 25%);' 
				}
			]
		},
		{
			className: '.theme-on-off-switch-indicator-on',
			properties: [
				{
					name: 'background-color',
					value: '@green-color'
				}
			]
		},
		{
			className: '.theme-on-off-switch',
			properties: [
				{
					name: 'background-image',
					value: 'linear-gradient(to top,#747474, #B9B9B9 50%);' 
				}
			]
		},
		/****************  Circle Menu ******************/
		{
			className: '.theme-circle-menu-indicator',
			properties: [
				{
					name: 'background-color',
					value: '@dark-color' 
				}
			]
		},
		{
			className: '.theme-circle-menu-indicator-selected',
			properties: [
				{
					name: 'background-color',
					value: '@foreground-color' 
				}
			]
		}
	]
};

$ui.themeLight = {
	backgroundImageColor: '#D94646',
	inHeadUnit: true,
	chart: { // Not in CSS because charts are <canvas>
		color: '#747474', //#F0F0F0
		color_OK: '#D94646',//#FAD60A
		color_GOOD: '#D94646',//#FDBF2F
		color_GREAT: '#D94646', //#A3D525
		color_RANDOM1: '#D94646', //#97BBCD
	},
	variables: [
		{
			name: '@brand-color',
			value: '#D94646'
		},
		{
			name: '@highlight-text-color',
			value: '#FFFFFF'
		},
		{
			name: '@foreground-color',
			value: '#FFFFFF'
		},
		{
			name: '@border-color',
			value: '#FFFFFF'
		},
		{
			name: '@background-color',
			value: '#000000'
		},
		{
			name: '@dark-color',
			value: '#747474'
		},
		{
			name: '@profile-wedge-color',
			value: '#D94646'// #FDBF2F
		}
	],
	classList: [
		{
			className: '.theme-border-color',
			properties: [
				{
					name: 'border-color',
					value: '@border-color !important'
				}
			]
		},
		{
			className: '.theme-brand-border-color',
			properties: [
				{
					name: 'border-color',
					value: '@brand-color !important'
				}
			]
		},
		{
			className: '.theme-tile-border-color',
			properties: [
				{
					name: 'border-color',
					value: '@brand-color !important'
				}
			]
		},
		{
			className: '.theme-dark-border-color',
			properties: [
				{
					name: 'border-color',
					value: '@dark-color !important'
				}
			]
		},
		{
			className: '.theme-text-color',
			properties: [
				{
					name: 'color',
					value: '@foreground-color'
				}
			]
		},
		{
			className: '.theme-dark-text-color',
			properties: [
				{
					name: 'color',
					value: '@dark-color'
				}
			]
		},
		{
			className: '.theme-highlight-text-color',
			properties: [
				{
					name: 'color',
					value: '@highlight-text-color'
				}
			]
		},
		{
			className: '.theme-brand-text-color',
			properties: [
				{
					name: 'color',
					value: '@brand-color'
				}
			]
		},
		{
			className: '.theme-screen-background-color',
			properties: [
				{
					name: 'background-color',
					value: '@background-color'
				}
			]
		},
		{
			className: '.theme-brand-background-color',
			properties: [
				{
					name: 'background-color',
					value: '@brand-color'
				}
			]
		},
		{
			className: '.theme-light-background-color',
			properties: [
				{
					name: 'background-color',
					value: '@foreground-color'
				}
			]
		},
		{
			className: '.theme-dark-background-color',
			properties: [
				{
					name: 'background-color',
					value: '@dark-color'
				}
			]
		},
		/****************  Generic List Items ******************/
		{
			className: '.theme-generic-list-accent-color',
			properties: [
				{
					name: 'color',
					value: '@brand-color'
				}
			]
		},
		/****************  Segmented Control ******************/
		{
			className: '.theme-segmented-control',
			properties: [
				{
					name: 'border-color',
					value: '@foreground-color'
				},
				{
					name: 'background-color',
					value: '@background-color'
				},
				{
					name: 'color',
					value: '@foreground-color'
				}
			]
		},
		/****************  Posts ******************/
		{
			className: '.theme-post-control',
			properties: [
				{
					name: 'color',
					value: '#D3D3D3'
				},
				{
					name: 'background-color',
					value: '@background-color'
				}
			]
		},
		/****************  Profile ******************/
		{
			className: '.theme-profile-vehicle-background-color',
			properties: [
				{
					name: 'background-color',
					value: '@background-color' // Light theme should be same as border color
				}
			]
		},
		{
			className: '.theme-profile-wedge-background-color',
			properties: [
				{
					name: 'background-color',
					value: '@profile-wedge-color'
				}
			]
		},
		{
			className: '.theme-profile-rank',
			properties: [
				{
					name: 'background-color',
					value: '@profile-wedge-color'
				},
				{
					name: 'color',
					value: '@highlight-text-color'
				}
			]
		},
		{
			className: '.theme-profile-rank-text-color',
			properties: [
				{
					name: 'color',
					value: '@highlight-text-color' // Light theme should be @dark-color
				}
			]
		},
		{
			className: '.theme-profile-label-text-color',
			properties: [
				{
					name: 'color',
					value: '@border-color' 
				}
			]
		},
		{
			className: '.theme-profile-stats',
			properties: [
				{
					name: 'border-color',
					value: '@brand-color' // Light theme should be @border-color
				},
				{
					name: 'background-color',
					value: '@background-color'
				}
			]
		},
		{
			className: '.theme-profile-number-color',
			properties: [
				{
					name: 'color',
					value: '@profile-wedge-color'
				}
			]
		},
		{
			className: '.theme-profile-avatar',
			properties: [
				{
					name: 'background-color',
					value: '@dark-color' // Light theme should be @border-color
				},
				{
					name: 'border-color',
					value: '@brand-color' // Light theme should be white
				},
				{
					name: 'box-shadow',
					value: 'inherit' // Light theme should be 0px 0px 7px #B6B6B6; 
				}
			]
		}
	]
};

/**
 * The CoreTile object represents the abstract base class for all tile controls. <br><br>
 * <b>NOTE: This base class should never be declared in a screen's declaration. It will not actually render and return a tile. It is simply an abstract base class.</b>
 * @namespace CoreTile
 * @memberof $ui
 * @extends $ui.CoreComponent
 */
function $ui_CoreTile(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	if (object) {
		$ui.addClass(object.dom,'ui-tile theme-text-color theme-tile-border-color theme-screen-background-color');
		object._contentShowing = false;
		/** 
		 * The size of a tile. This property should be set by the internal code of a derivative Tile class.
		 * @name _size
		 * @memberof $ui.CoreTile
		 * @protected
		 * @type {$ui.TileSize}
		 */
		if (object._size && (object._size != $ui.TileSize.STANDARD)) {
			$ui.addClass(object.dom, object._size);
		}
		object._protected._size = object._size;
		Object.defineProperty(object, '_size', {
			get: function() {return this._protected._size;},
			set: function() {
				console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','_size'));			
			},
			configurable: false}
		);
		
		// Create our loading area
		object.dom.loadingDiv = document.createElement('div');
		$ui.addClass(object.dom.loadingDiv, 'loading');
		object.dom.appendChild(object.dom.loadingDiv);
		object.dom.spinner = new $ui_Spinner({component: $ui.Spinner, size: $ui.Spinner.SMALL},screen);
		object.dom.loadingDiv.appendChild(object.dom.spinner);
		
		// Create our content area
		object.dom.contentDiv = document.createElement('div');
		$ui.addClass(object.dom.contentDiv, 'content');
		object.dom.appendChild(object.dom.contentDiv);	
		
		/** 
		 * This function is to be called when a tile needs to be toggled between the loading state and content state. 
		 * @function showContent
		 * @memberof $ui.CoreTile
		 * @param {boolean} value - The value parameter represents the boolean state of visibility of the tile content.
		 */
		object.showContent = function(value) {
			if (value == this._contentShowing) return;
			if (value) {
				this.dom.loadingDiv.style.display = 'none';
				this.dom.contentDiv.style.display = 'inherit';
			} else {
				this.dom.loadingDiv.style.display = 'inline';
				this.dom.contentDiv.style.display = 'none';
			}
			this._contentShowing = value;
		}.$bind(object);
	}
}
/**
 * The CoreTileDonutChart is the abstract base class of any donut chart tiles. This base class should never be declared in a screen's declaration.
 * <b>NOTE: It will not actually render and return a tile. It is simply an abstract base class.</b>
 * @namespace CoreTileDonutChart
 * @memberof $ui
 * @extends $ui.CoreTile
 */
function $ui_CoreTileDonutChart(object, screen) {
	// Set our default animation
	if (object.animated == undefined) {
		object.animated = true;
	}
	$ui_CoreTile.call(this, object, screen);
	if (object) {
		$ui.addClass(object.dom,'ui-tile-donut-chart');

		// Create our chart area
		object.dom.chartDiv = document.createElement('div');
		$ui.addClass(object.dom.chartDiv, 'chart'); // Base class styling
		object.dom.contentDiv.appendChild(object.dom.chartDiv);
		
		// Create our canvas area
		object.dom.canvas = document.createElement('canvas');
		object.dom.chartDiv.appendChild(object.dom.canvas);

		// Create our chart
		object.chart = new Chart(object.dom.canvas.getContext('2d'));
		
		/** 
		 * This function takes a value parameter which is an array of data point objects. These data point objects defined a section of the chart and consist of two properties representing value and color
		 * @function _setData
		 * @memberof $ui.CoreTileDonutChart
		 * @param {object[]} value - Array of data points. <br/><b>Example:</b>
		 * <pre>
		 * [
		 *   {
		 *      value: 10,
		 *      color: '#000000',
		 *   },
		 *   {
		 *      value: 90,
		 *      color: '#FEFEFE',
		 *   }
		 * ]
		 * </pre>
		 * @protected
		 */
		object._setData = function(data) {
			this._protected.data = data;
			this.chart.Doughnut(data,{showTooltips: false, animation: this.animated, segmentStrokeColor : "transparent",});
		}.$bind(object);
		
		// Create the caption area
		object.dom.caption = document.createElement('div');
		$ui.addClass(object.dom.caption,'caption');
		object.dom.contentDiv.appendChild(object.dom.caption);
		
		/** 
		 * This function will set the caption of the Donut chart.
		 * @function _setCaption
		 * @memberof $ui.CoreTileDonutChart
		 * @param {string} value - Text for the caption
		 * @protected
		 */
		object._setCaption = function(value) {
			this.dom.caption.innerHTML = value;
		}.$bind(object);
		
		// Create the accent area
		object.dom.accent = document.createElement('div');
		$ui.addClass(object.dom.accent,'accent');
		object.dom.contentDiv.appendChild(object.dom.accent);
		object.dom.accent.style.color = $ui.theme.chart.color;
		
		/** 
		 * This function will set the accent text of the Donut chart
		 * @function _setAccent
		 * @memberof $ui.CoreTileDonutChart
		 * @param {string} value - Text for the accent
		 * @protected
		 */
		object._setAccent = function(value) {
			if (value == undefined) {
				$ui.removeClass(this.dom.contentDiv, 'has-accent');
				this.dom.accent.textContent = '';
				this.accent = value;
				return;
			}
			this.accent = value;
			$ui.addClass(this.dom.contentDiv, 'has-accent');
			this.dom.accent.textContent = value;
		}.$bind(object);
	}
}
/**
 * The CoreTileGauge is the abstract base class of any gauge chart tiles.
 * <b>NOTE: It will not actually render and return a tile. It is simply an abstract base class.</b><br><br>
 * <b>Sample Declaration:</b>
 * <pre>
 * {
 *    min: 0,
 *    max: 1.5,
 *    value: 1
 *}
 * </pre>
 * @namespace CoreTileGauge
 * @memberof $ui
 * @extends $ui.CoreTile
 * @property {number} min - This is the minimum numeric value that you want to display at the left hand side of the gauge
 * @property {number} max - This is the maximum numeric value that you want to display at the right hand side of the gauge
 * @property {number} value - The numeric value you want to display. This should be between min and max.
 */
function $ui_CoreTileGauge(object, screen) {
	if (object) object._size = undefined; // Always square
	$ui_CoreTile.call(this, object, screen);
	if (object) {
		$ui.addClass(object.dom,'ui-tile-gauge');

		// Create our title area
		object.dom.titleDiv = document.createElement('div');
		$ui.addClass(object.dom.titleDiv,'title');
		object.dom.contentDiv.appendChild(object.dom.titleDiv);
		
		/** 
		 * This function will set the title of the gauge chart.
		 * @function _setTitle
		 * @memberof $ui.CoreTileGauge
		 * @param {string} value - Value to be used as the title
		 * @protected
		 */
		object._setTitle = function(value) {
			if (value == undefined || value == null) value = '';
			object.dom.titleDiv.textContent = value;
		}.$bind(object);
		
		// Create our chart area
		object.dom.chartDiv = document.createElement('div');
		$ui.addClass(object.dom.chartDiv, 'chart'); // Base class styling
		object.dom.contentDiv.appendChild(object.dom.chartDiv);
		
		// Create our canvas area
		object.dom.canvas = document.createElement('canvas');
		object.dom.canvas.width = 200;
		object.dom.canvas.height = 200;
		$ui.addClass(object.dom.canvas,'graph-canvas');
		object.dom.chartDiv.appendChild(object.dom.canvas);

		// Add our bottom labels
		object.dom.labels = document.createElement('div');
		$ui.addClass(object.dom.labels, 'labels-area');
		object.dom.chartDiv.appendChild(object.dom.labels);
		
		// Min Label
		object.dom.minLabel = document.createElement('div');
		$ui.addClass(object.dom.minLabel, 'label');
		$ui.addClass(object.dom.minLabel, 'left');
		object.dom.labels.appendChild(object.dom.minLabel);
		
		// Max Label
		object.dom.maxLabel = document.createElement('div');
		$ui.addClass(object.dom.maxLabel, 'label');
		$ui.addClass(object.dom.maxLabel, 'right');
		object.dom.labels.appendChild(object.dom.maxLabel);
		
		// Accent Label
		object.dom.accentLabel = document.createElement('div');
		$ui.addClass(object.dom.accentLabel, 'label');
		$ui.addClass(object.dom.accentLabel, 'center');
		object.dom.labels.appendChild(object.dom.accentLabel);
		/** 
		 * This function will set the title of the gauge chart.
		 * @function _setAccent
		 * @memberof $ui.CoreTileGauge
		 * @param {string} value - Value to use as the accent text
		 * @protected
		 */
		object._setAccent = function(value) {
			if (value == undefined || value == null) value = '';
			object.dom.accentLabel.textContent = value;
		}
		object._setAccent = object._setAccent.$bind(object);
		
		// Value Label
		object.dom.valueDiv = document.createElement('div');
		$ui.addClass(object.dom.valueDiv, 'value');
		object.dom.chartDiv.appendChild(object.dom.valueDiv);
		
		// Create our chart Context 
		var ctx = object.dom.canvas.getContext('2d');
		object.dom.ctx = ctx;
		object._width = object.dom.canvas.width;
		object._height = object.dom.canvas.height;
		
		// This will render our filled in area
		object._renderLoop = function() {
			if (this._degrees > this._newDegrees) {
				return;
			}
			requestAnimationFrame(this._renderLoop)
			
			//Angle in radians = angle in degrees * PI / 180
			var ctx = this.dom.ctx,
				radians = this._degrees * Math.PI / 180;
			
			//Clear the canvas every time a chart is drawn
			ctx.clearRect(0, 0, this._width, this._height);
		
			//Background 180 degree arc
			ctx.beginPath();
			ctx.strokeStyle = $ui.theme.chart.color;
			ctx.lineWidth = 40;
			ctx.arc(this._width/2, this._height/2, 80, 0 - 180*Math.PI/180, Math.PI/180, false); //you can see the arc now
			ctx.stroke();
			
			// Now render our value
			ctx.beginPath();
			ctx.strokeStyle = this._color;
			//The arc starts from the rightmost end. If we deduct 180 degrees from the angles
			//the arc will start from the leftmost end
			ctx.arc(this._width/2, this._height/2, 80, 0 - 180*Math.PI/180, radians - 180*Math.PI/180, false); 
			//you can see the arc now
			ctx.stroke();
			
			if (this._degrees <= this._newDegrees) {
				this._degrees = this._degrees + this._step;
			}
			
		}.$bind(object);
		
		// This function will populate the control with the current values and then render the control
		object._populateData = function() {
			// Correct any bad data
			if (this.min == undefined) this.min = 0;
			if (this.max == undefined) this.max = 100;
			if (this.value == undefined) this.value = this.min;
			if (this.value < this.min) this.value = this.min;
			
			// Set our labels
			this.dom.minLabel.textContent = this.min;
			this.dom.maxLabel.textContent = this.max;
			this.dom.valueDiv.textContent = this.value;
			
			var percent = ((this.value - this.min)/this.max);
			this._newDegrees = percent * 180;
			switch (true) {
				case (percent < 0.33):
					this._color = $ui.theme.chart.color_GREAT;
					this._step = 2;
					break;
				case (percent < 0.77):
					this._color = $ui.theme.chart.color_GOOD;
					this._step = 7;
					break;
				default:
					this._color = $ui.theme.chart.color_OK;
					this._step = 10;
					break;
			}
			//this._degrees = 0;
			this._degrees = this._newDegrees - this._step;// temporary to stop slow animation
			this._renderLoop();
		}.$bind(object);
	}
}
/**
 * The DockLayout object represents a layout that allows for a static content and also scrolling content. The DockLayout will size itself to all the available space provided by its parent control.
 * <br><br><b>Sample Declaration</b>
 * <pre>
 * {
 *    component: $ui.DockLayout,
 *    dock: [
 *        {
 *            component: $ui.SegmentedControl,
 *            options: ['one','two']
 *        }
 *    ],
 *    content: [
 *        {
 *            component: $ui.List
 *        }
 *    ]
 *}
 * </pre>
 * @namespace DockLayout
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {$ui.CoreComponent[]} dock - This array holds all of the component definitions for the docked content
 * @property {$ui.CoreComponent[]} content - This array holds all of the component definitions for the scrollable area of the dock layout
 * @property {$ui.DockLayout.DockLocation} [location=$ui.DockLayout.DockLocation.TOP] - This property allows you to set the location of the docked content.
 */
function $ui_DockLayout(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom,'ui-dock-layout');
	
	// Create our dock area
	object.dom.dock = document.createElement('div');
	$ui.addClass(object.dom.dock, 'dock');
	
	var i,
		control,
		controlDom;
	
	// Load our dock
	if (object.dock) {
		for (i = 0; i < object.dock.length; i++) {
			control = object.dock[i];
			controlDom = $ui.createControl(control, screen);
			if (controlDom) {
				object.dom.dock.appendChild(controlDom);
			}
		}
	}
	
	// Create our contents area
	object.dom.contentDiv = document.createElement('div');
	$ui.addClass(object.dom.contentDiv, 'contents');
	
	// Load our contents
	if (object.content) {
		for (i = 0; i < object.content.length; i++) {
			control = object.content[i];
			controlDom = $ui.createControl(control, screen);
			if (controlDom) {
				object.dom.contentDiv.appendChild(controlDom);
			}
		}
	}
	
	// Check our dock location
	if (object.location === $ui.DockLayout.DockLocation.BOTTOM) {
		object.dom.appendChild(object.dom.contentDiv);
		object.dom.appendChild(object.dom.dock)
	} else {
		object.dom.appendChild(object.dom.dock)
		object.dom.appendChild(object.dom.contentDiv);
	}
	
	return object.dom;
}
/**
 * The generic list item type is used with the {@link $ui.List} component. A List component will define the type of list item it wishes to display by setting the <b>style</b> property of the control. 
 * <br><br><b>Sample Declaration</b>
 * <pre>
 * {
 *   img: 'thumbnails/foo.png',
 *   title: 'This is my title',
 *   accent: '6 hours ago',
 *   caption: 'My summary description'
 *}
 * </pre>
 * @namespace GenericListItem
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {string} [img] - Represents the path to the image that will appear in the list item
 * @property {string} title - Represents the main title to display
 * @property {string} [accent] - Represents the accent text to go along with the title and caption
 * @property {string} [caption] - Represents the main text to show in the list item
 */
function $ui_GenericListItem(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom, 'ui-generic-list-item theme-text-color theme-screen-background-color theme-dark-border-color');
	
	if ($ui.theme.inHeadUnit == true) {
		$ui.addClass(object.dom, 'in-head-unit');
	}
	
	// Create the image
	object.dom.img = document.createElement('div');
	$ui.addClass(object.dom.img,'img');
	object.dom.appendChild(object.dom.img);
	
	// Details section
	object.dom.details = document.createElement('div');
	$ui.addClass(object.dom.details,'details');
	object.dom.appendChild(object.dom.details);
	
	// Title
	object.dom.titleArea = document.createElement('div');
	$ui.addClass(object.dom.titleArea,'title');
	object.dom.details.appendChild(object.dom.titleArea);

	// Caption
	object.dom.captionDiv = document.createElement('div');
	$ui.addClass(object.dom.captionDiv,'caption');
	object.dom.details.appendChild(object.dom.captionDiv);
	
	// Accent
	object.dom.accent = document.createElement('div');
	$ui.addClass(object.dom.accent,'accent theme-generic-list-accent-color');
	object.dom.details.appendChild(object.dom.accent);
	
	// Load the image
	object._loadImage = function() {
		if(this.img != undefined && this.img != null && this.img != '') {
			// Image Loader
			this._loader = new Image();
			this._loader.model = object;
			this._loader.onload = function() {
				this.model.dom.img.style.backgroundImage = 'url("'+ this.model.img + '")';
				this.model.dom.img.style.opacity = '1.0';
				this.model._loader = undefined;
			}
			this._loader.onerror = function() {
				this.model.dom.img.style.backgroundImage = '';
				this.model.dom.img.style.opacity = '1.0';
				this.model._loader = undefined;
			}
			this._loader.src = object.img;
		} else {
			this.dom.img.style.opacity = '1.0';
			this.dom.loader = undefined;
		}
	}.$bind(object);
	
	// img property
	object._loadImage();
	object._protected.img = object.img;
	Object.defineProperty(object, 'img', {
		get: function() {return this._protected.img;},
		set: function(value) {
			if (value == this._protected.img) return;
			this._protected.img = value;
			this._loadImage();
		},
		configurable: false}
	);
	
	// Caption property
	if (object.caption) {
		object.dom.captionDiv.textContent = object.caption;
	} else {
		$ui.addClass(object.dom, 'no-caption');
	}
	object._protected.caption = object.caption;
	Object.defineProperty(object, 'caption', {
		get: function() {return this._protected.caption;},
		set: function(value) {
			if (value == this._protected.caption) return;
			this._protected.caption = value;
			if (value == undefined) {
				$ui.addClass(this.dom, 'no-caption');
			} else {
				$ui.removeClass(this.dom, 'no-caption');
				this.dom.captionDiv.textContent = value;
			}
		},
		configurable: false}
	);
	
	// accent Property
	if(object.accent != undefined) {
		object.dom.accent.textContent = object.accent;
		$ui.addClass(object.dom, 'has-accent');
	} 
	object._protected.accent = object.accent;
	Object.defineProperty(object, 'accent', {
		get: function() {return this._protected.accent;},
		set: function(value) {
			if (value == this._protected.accent) return;
			this._protected.accent = value;
			if (value == undefined) {
				$ui.removeClass(this.dom, 'has-accent');
			} else {
				$ui.addClass(this.dom, 'has-accent');
			}
		},
		configurable: false}
	);
	
	// Title Property
	object.dom.titleArea.textContent = object.title;
	object._protected.title = object.title;
	Object.defineProperty(object, 'title', {
		get: function() {return this._protected.title;},
		set: function(value) {
			if (value == this._protected.title) return;
			this._protected.title = value;
			this.dom.titleArea.textContent = value;
		},
		configurable: false}
	);
	
	// Handle our touch events
	object.dom.ontouchstart = function() {
		$ui.removeClass(this, 'theme-screen-background-color');
		$ui.addClass(this, 'theme-brand-background-color');
		$ui.removeClass(this, 'theme-text-color');
		$ui.addClass(this, 'theme-highlight-text-color');
		// Update our accent text
		if (this.model.dom && this.model.dom.accent) {
			$ui.removeClass(this.model.dom.accent, 'theme-generic-list-accent-color');
		}
	}
	object.dom.ontouchend = function() {
		$ui.removeClass(this, 'theme-brand-background-color');
		$ui.addClass(this, 'theme-screen-background-color');
		$ui.removeClass(this, 'theme-highlight-text-color');
		$ui.addClass(this, 'theme-text-color');
		// Update our accent text
		if (this.model.dom && this.model.dom.accent) {
			$ui.addClass(this.model.dom.accent, 'theme-generic-list-accent-color');
		}
	}
	object.dom.ontouchcancel = object.dom.ontouchend;
	if (!$ui.isMobileDevice()) {
		object.dom.onmousedown = object.dom.ontouchstart;
		object.dom.onmouseup = object.dom.ontouchend;
		object.dom.onmouseleave = object.dom.ontouchend;
	}

	// Pass the onclick back to the list
	object.dom.addEventListener('click', function() {
		if (this.model.parent.onaction == undefined) return;
		var event = new ListEvent(this.model, $ui.GenericListItem.GenericListEvent.ONCLICK);
		this.model.parent._onaction(this.model, event);
		$ui.playTouchSound();
	},false);

	return object.dom;
}
/**
 * The Header object represents a screen separator with a caption.  This component can be useful when you wish to label different areas of the screen.  Headers can also be used as
 * an item in a {@link $ui.List} control<br><br>
 * <b>Sample Declaration</b><br>
 * <pre>
 * {
 *   component: $ui.Header,
 *   caption: 'My Lovely Header'
 * }
 * @namespace Header
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {string} [caption] - The caption to be displayed in the control
*/
function $ui_Header(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom,'ui-header theme-text-color theme-brand-border-color');
	if ($ui.theme.inHeadUnit == true) {
		$ui.addClass(object.dom, 'in-head-unit');
	}
	if (object.caption) {
		object.dom.textContent = object.caption;
	}
	
	return object.dom;
}
/**
 * The image list item type is used with the {@link $ui.List} component. A List component will define the type of list item it wishes to display by setting the <b>style</b> property of the control. 
 * <br><br><b>Sample Declaration</b>
 * <pre>
 * {
 *   img: 'thumbnails/foo.png',
 *   caption: 'My summary description'
 *}
 * </pre>
 * @namespace ImageListItem
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {string} img - Represents the path to the image that will appear in the list item
 * @property {string} [caption] - Represents the main text to show in the list item
 */
function $ui_ImageListItem(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom, 'ui-image-list-item');
	
	// Create the image
	object.dom.img = document.createElement('div');
	$ui.addClass(object.dom.img,'img');
	object.dom.appendChild(object.dom.img);
	
	if(object.img != undefined && object.img != null && object.img != '') {
		// Image Loader
		object._loader = new Image();
		object._loader.model = object;
		object._loader.onload = function() {
			this.model.dom.img.style.backgroundImage = 'url("'+ this.model.img + '")';
			this.model.dom.img.style.opacity = '1.0';
			this.model._loader = undefined;
		}
		object._loader.onerror = function() {
			this.model.dom.img.style.backgroundImage = '';
			this.model.dom.img.style.opacity = '1.0';
			this.model._loader = undefined;
		}
		object._loader.src = object.img;
	} else {
		object.dom.img.style.opacity = '1.0';
		object.dom.loader = undefined;
	}
	

	// Caption
	object.dom.captionDiv = document.createElement('div');
	$ui.addClass(object.dom.captionDiv,'caption theme-highlight-text-color');
	object.dom.appendChild(object.dom.captionDiv);
	if (object.caption) {
		object.dom.captionDiv.textContent = object.caption;
	} else {
		$ui.addClass(object.dom.captionDiv, 'no-caption');
	}

	// Pass the onclick back to the list
	object.dom.addEventListener('click', function() {
		if (this.model.parent.onaction == undefined) return;
		var event = new ListEvent(this.model, $ui.ImageListItem.ImageListEvent.ONCLICK);
		this.model.parent._onaction(this.model, event);
		$ui.playTouchSound();
	},false);

	return object.dom;
}
/**
 * An input can provide either single line or multi-line input with various different display options and interactions<br>
 * <b>Sample Declaration</b>
 * <pre>
 * {
 *     component: $ui.Input,
 *     hint: 'Password',
 *     password: true,
 *     onenterkey: function() {
 *        // Login
 *    }
 * }
 * @namespace Input
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {string} [text] - The text that is contained in the input
 * @property {string} [hint] - The to show up as background "hint" text to let the user know what to enter into the control
 * @property {number} [tabIndex] - Optionally set the tab index for this input
 * @property {$ui.Input.InputType} [inputType] - Optionally set the type of input for this field. By default it is text.
 * @property {boolean} [password=false] - Set this value to <b>true</b> if you wish to have a password mask on the control
 * @property {boolean} [warning=false] - This <b>read only</b> flag will be set to <b>true</b> if the control has a validation error.
 * @property {boolean} [multiLine=false] - Set this value to <b>true</b> if you wish the control to allow for multi-line input
 * @property {number} [minLinesToShow=1] - This optional property allows you to specify how many lines high a multiLine input should be by default. 
 * The minLinesToShow property is ignored if multiLine is not set to <b>true</b>. The property is also ignored if it is not greater than 1 which is the default.<br><br> 
 * The control will then show a minimum number of lines as specified, but will also grow as the user types in content that will extend that minimum number just like it regularly does with a multiLine input.
 * @property {number} [maxLinesToShow=1] - This optional property allows you to specify how many lines high a multiLine input should grow to. The maxLinesToShow property is ignored if multiLine is not set to <b>true</b>. The property is also ignored if it is not greater than 1 which is the default. The control will then grow to a maximum number of lines as specified.
 * @property {GenericEvent} [onenterkey] - This event will fire when the user presses the enter key on their keyboard
 * @property {GenericEvent} [onchange] - The onchange event will fire whenever the user types in the input box. <i>NOTE: It will not fire when the text property is changed programatically.</i>
 * @property {GenericEvent} [onfocus] - The onfocus event will fire whenever the input received the focus.
 * @property {GenericEvent} [onblur] - The onblur event will fire whenever the input box loses focus.
 * @property {GenericEvent} [onvalidate] - The onvalidate event will fire when the <b>validate()</b> function is called. If you wish to have the validation fail, return <b>false</b> from your function. When validate() is called it will perform internal validation based on the <b>inputType</b> and also call the onvalidate function.  If either returns false the input will go into its warning state 
 */
function $ui_Input(object, screen){
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom, 'ui-input');
	object.dom.style.borderColor = $ui.theme.borderColor;
	
	if ($ui.isApple == true) {
		$ui.addClass(object.dom, 'iOS');
	}
	
	if ($ui.theme.inHeadUnit == true) {
		$ui.addClass(object.dom, 'in-head-unit');
	}
	
	// inputType property
	object._protected.inputType = object.inputType;
	Object.defineProperty(object, 'inputType', {
		get: function() {return this._protected.inputType;},
		set: function() {
			console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','inputType'));
		},
		configurable: false}
	);
	
	// Warning property
	object.warning = false;
	object._protected.warning = object.warning;
	Object.defineProperty(object, 'warning', {
		get: function() {return this._protected.warning;},
		set: function() {
			console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','warning'));
		},
		configurable: false}
	);
	
	// Configure our placeholder
	object.dom.placeholder = document.createElement('div');
	$ui.addClass(object.dom.placeholder,'placeholder theme-hint-text-color');
	object.dom.appendChild(object.dom.placeholder);

	// Multi-Line property
	object._protected.multiLine = object.multiLine;
	Object.defineProperty(object, 'multiLine', {
		get: function() {return this._protected.multiLine;},
		set: function() {
			console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','multiLine'));
		},
		configurable: false}
	);
	
	// Private function called from the base class for setting the enabled state
	object._setEnabled = function(value) {
		if (value == true) {
			this.dom.input.removeAttribute('readonly');
			// TODO: Set Color
		} else {
			this.dom.input.setAttribute('readonly','true');
			// TODO: Set Color
		}
	}.$bind(object);
	
	// Style our enabled state
	if (object.enabled == false) {
		object._setEnabled(false);
	}
	
	// Figure out if we need to set the placeholder/hint
	object.computePlaceholder = function() {
		var small = (this.dom.input.value == '' || this.dom.input.value == undefined) ? false : true;
		if (small) {
			$ui.addClass(this.dom.placeholder,'draw-small');
			$ui.addClass(this.dom.input, 'small-placeholder');
			if (this.dom.textAreaSize != undefined) {
				$ui.addClass(this.dom.textAreaSize, 'small-placeholder');
			}
		} else {
			$ui.removeClass(this.dom.placeholder,'draw-small')
			$ui.removeClass(this.dom.input, 'small-placeholder');
			if (this.dom.textAreaSize != undefined) {
				$ui.removeClass(this.dom.textAreaSize, 'small-placeholder');
			}
		}
	}.$bind(object);
	
	// See if it is single or multi-line input
	if (object.multiLine == true) {
		object.dom.input = document.createElement('textarea');
		$ui.addClass(object.dom.input, 'textarea');
		object.dom.appendChild(object.dom.input);
		object.dom.textAreaSize = document.createElement('div');
		$ui.addClass(object.dom.textAreaSize, 'textarea-size');
		object.dom.appendChild(object.dom.textAreaSize);
		// Check for text
		if (object.text) {
			object.dom.input.value = object.text;
			object.dom.textAreaSize.innerHTML = object.text;
		}
		if ((object.minLinesToShow != undefined) && (parseInt(object.minLinesToShow) > 1)) {
			var minHeight = object.minLinesToShow * 35;
			object.dom.textAreaSize.style['min-height'] = minHeight + 'px';
		}
		if ((object.maxLinesToShow != undefined) && (parseInt(object.maxLinesToShow) > 1)) {
			var maxHeight = (object.maxLinesToShow -1) * 35;
			object.dom.textAreaSize.style['max-height'] = maxHeight + 'px';
			object.dom.input.style['overflow-y'] = 'scroll';
			object.dom.input.onscroll = function() {
				if (this.scrollTop > 0) {
					this.model.dom.placeholder.style.display = 'none';
				} else {
					this.model.dom.placeholder.style.display = 'inherit';
				}
			}
		}
	} else {
		// Create our actual input box
		object.dom.input = document.createElement('input');		
		if(object.password == true){
			object.dom.input.setAttribute('type', 'password');
		}
		else {
			object.dom.input.setAttribute('type', 'text');
		}
		$ui.addClass(object.dom.input, 'text');
		object.dom.input.style.color = $ui.theme.textColor;
		// Check for text
		if (object.text) {
			object.dom.input.setAttribute('value',object.text);
		}
		object.dom.appendChild(object.dom.input);
	} 
	// Set our automation markers
	if (object.id) {
		object.dom.input.setAttribute('data-interaction-input',object.id);
	}
		
	object.dom.input.onfocus = function() {
		this.model.dom.style.borderColor = $ui.theme.color;
		$ui.addClass(this.model.dom, 'theme-brand-border-color');
		if (this.model.onfocus) {
			this.model.onfocus();
		}
	}
	
	object.dom.input.onblur = function() {
		$ui.removeClass(this.model.dom, 'theme-brand-border-color');
		if (this.model.onblur) {
			this.model.onblur();
		}
	}
	
	// Assign our pointers
	object.dom.input.model = object;
	object.computePlaceholder();
	
	// tabIndex property
	if (object.tabIndex != undefined) {
		object.dom.input.tabIndex = object.tabIndex;
	}
	object._protected.tabIndex = object.tabIndex;
	Object.defineProperty(object, 'tabIndex', {
		get: function() {return this._protected.tabIndex;},
		set: function() {
			console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','tabIndex'));
		},
		configurable: false}
	);
	
	// Prevent FastClick for dom.input if-and-only-if it's multiline input field if it's Apple Device
	if($ui.isApple === true) {
		if(object.multiLine === true) {
			object.dom.input.addEventListener('touchstart',function(e) {
				e.stopPropagation();
			},false);
			object.dom.input.addEventListener('touchend',function(e) {
				e.stopPropagation();
			},false);
		}
	} else {
		object.dom.input.addEventListener('touchstart',function(e) {
			e.stopPropagation();
		},false);
		object.dom.input.addEventListener('touchend',function(e) {
			e.stopPropagation();
		},false);
	}
	
	// Trap the keyup to trigger the event
	object.dom.input.addEventListener('keyup',function(e) {
		// See if they pressed enter
		if ((e.keyCode == 13) && (this.model.onenterkey)) {
			this.model.onenterkey();
		} 
	},false);
	
	// Trap the keydown to check input types
	object.dom.input.addEventListener('keydown',function(e) {
		// Check our input type
		if (this.model.inputType == $ui.Input.InputType.INTEGER || this.model.inputType == $ui.Input.InputType.FLOAT) {
			if (e.keyCode == 127 || e.keyCode == 8 || e.keyCode == 9 || e.keyCode == 13 || e.keyCode == 46 || e.keyCode == 37 || e.keyCode == 39) return;
			if ((e.keyCode >= 48 && e.keyCode <= 57) || (e.keyCode >= 96 && e.keyCode <= 105)) return;
			if ((e.keyCode == 110 || e.keyCode == 190) && this.model.inputType == $ui.Input.InputType.FLOAT) {
				return;
			}
			e.preventDefault();
		}
	},false);
	
	object.dom.input.addEventListener('input',function(e) {
		this.model._raiseInteractionEvent('data-interaction-input');
		this.model._protected.text = this.value;
		// Adjust our multi-line size by adjusting the outer div height
		if (this.model.multiLine == true) {
			this.model.dom.textAreaSize.innerHTML = this.value.replace(new RegExp('\n', 'g'), '<br>&nbsp;');//this.value;
		} 
		// Calculate our placeholder position and update the data provider
		this.model.computePlaceholder();
		this.model._updateData(this.model.text);
		// Fire our onchange event
		if (this.model.onchange) {
			this.model.onchange();
		}
	},false);
	
	
	// Text Property
	object._protected.text = object.text;
	Object.defineProperty(object, 'text', {
		get: function() {return this._protected.text;},
		set: function(value) {
			if (value == this._protected.text) return;
			this._setText(value);
			this._updateData(this.text);
		},
		configurable: false}
	);
	
	/**
	* This function will set focus to the input control
	* @function setFocus
	* @memberof $ui.Input
	*/
	object.setFocus = function(value) {
		this.dom.input.focus();
	}.$bind(object);
	
	// Private function to set the text
	object._setText = function(value) {
		if (value == undefined) {
			value = '';
		}
		this._protected.warning = false;
		$ui.removeClass(this.dom.input, 'theme-warning-text-color');
		$ui.removeClass(this.dom.placeholder, 'theme-warning-text-color');
		this._protected.text = value;
		if (this.multiLine == true) {
			$ui.removeClass(this.dom.input, 'placeholder');
			this.dom.input.value = value;
			this.dom.textAreaSize.innerHTML = value;
			this.dom.input.onblur();
		} else {
			this.dom.input.value = this._protected.text;
		}
		this.computePlaceholder();
	}.$bind(object);
	
	// Hint Property
	if (object.hint == undefined) {
		object.hint = '';
	}
	object.dom.placeholder.textContent = object.hint;
	object._protected.hint = object.hint;
	Object.defineProperty(object, 'hint', {
		get: function() {return this._protected.hint;},
		set: function(value) {
			if (value == undefined) value = '';
			if (value == this._protected.hint) return;
			this._protected.hint = value;
			this.dom.placeholder.textContent = value;
			this.computePlaceholder();
		},
		configurable: false}
	);
	
	/**
	* This function will validate the contents of the input control and return <b>false</b> if the contents are not valid
	* @function validate
	* @returns {boolean}
	* @memberof $ui.Input
	*/
	object.validate = function() {
		// Check for custom validation
		if (this.onvalidate) {
			if (this.onvalidate() == false) {
				this._protected.warning = true;
			}
		}
		if (this._protected.warning == true) {
			$ui.addClass(this.dom.input,'theme-warning-text-color');
			$ui.addClass(this.dom.placeholder, 'theme-warning-text-color');
		} else {
			$ui.removeClass(this.dom.input,'theme-warning-text-color');
			$ui.removeClass(this.dom.placeholder, 'theme-warning-text-color');
			if (this._protected.hadNoHint == true) {
				this.hint = undefined;
			} else {
				this.dom.placeholder.textContent = this.hint;
			}
		}
		return !this._protected.warning;
	}.$bind(object);
	
	// Private function to handle provider updates
	object._providerUpdate = function(value) {
		this._setText(value);
	}.$bind(object);
	
	return object.dom;
}



/**
 * This object defines the type of background to be shown on the screen.<br><br>
 * <b>Sample Code:</b><br>
 * <pre>
 * {
 *   img: 'img/background.png', 
 *   repeat: true, 
 *}
 * </pre>
 * @class ScreenBackground
 * @param {string} img - Path to the background image
 * @param {boolean} [repeat=false] - Whether or not you want the background repeated/tiled
 */
function ScreenBackground(img, repeat) {
	/** 
	 * Path to the background image
	 * @member {string} img
	 * @memberOf ScreenBackground
	 */
	if (img == null) throw new Error('ScreenBackground: img cannot be null');
	if (img == undefined) throw new Error('ScreenBackground: img cannot be undefined');
	this.img = img;
	/** 
	 * Whether or not you want the background repeated/tiled
	 * @member {boolean} [repeat=false]
	 * @memberOf ScreenBackground
	 */
	if (repeat == undefined || repeat == null) {
		this.repeat = false;
	}
}
/**
 * The segmented control provides an actionable item for the user to choose between multiple options.
 * A segmented control's width will fill the width of the container in which it is a member.<br><br>
 * <b>Sample Declaration</b><br>
 * <pre>
 * {
 *   component: $ui.SegmentedControl,
 *   selectedIndex: 0,
 *   options: ['One', 'Two', 'Three'],
 *   onclick: function() {
 *      alert('You clicked: ' + this.options[this.selectedIndex]);
 *   }
 *}
 * @namespace SegmentedControl
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {number} [selectedIndex=0] - Represents the index of the option you want to be selected. This property will also be updated whenever a user selects an option from the control. 
 * @property {string[]} options - This property represents the options provided by the control. It is an array of string values that will be displayed
 * @property {GenericEvent} [onclick] - The onclick event will fire when the user selects/clicks an option in the control. You can retrieve which option was selected by inspecting the <b>selectedIndex</b> property.
 */
function $ui_SegmentedControl(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom,'ui-segmented-control theme-segmented-control');
	if ($ui.theme.inHeadUnit == true) {
		$ui.addClass(object.dom, 'in-head-unit');
	}
	object.domOptions = [];
	
	/** 
	 * You can set the selected index for the control by using this function. This function will also raise the <i>onclick</i> event as though a user just clicked the control.
	 * @function setSelectedIndex
	 * @memberof $ui.SegmentedControl
	 * @param {number} index - Item to be added to the menu
	 */
	object.setSelectedIndex = function(index) {
		if (this.selectedIndex != index) {
			this.selectedIndex = index;
			// Trigger the onclick
			if (this.onclick) {
				this.onclick(); 
			}
		} 
		this._setSelectedIndex(index);
	}.$bind(object);
	
	// Private function to set the selected index for the control
	object._setSelectedIndex = function(index) {
		if (this.options) {
			var i,
				option;
			for (i = 0; i < this.domOptions.length; i++) {
				option = this.domOptions[i];
				if (i == index) {
					option._setSelected(true);
				} else {
					option._setSelected(false);
				}
			}
		}
	}.$bind(object);
	
	// Go through our options
	if (object.options) {
		var i,
			option, 
			percentage = 100/object.options.length;
		
		for (i = 0; i < object.options.length; i++) {
			option = document.createElement('div');
			$ui.addClass(option,'button');
			if (i == 0) {
				$ui.addClass(option,'left');
			} else if (i == object.options.length -1) {
				$ui.addClass(option,'right');
			}
			option.model = object;
			option.index = i;
			option.selected = false;
			option.style.width = percentage + '%';
			option.style.left = (i * percentage) + '%';
			option.textContent = object.options[i];
			object.domOptions.push(option);
			object.dom.appendChild(option);
			
			// Pass the onclick back to the list
			option.addEventListener('click', function() {
				if (this.model.enabled == false) return;
				if (this.selected) return;
				this.model.setSelectedIndex(this.index);
			},false);
			
			// Change the selected state for the button
			option._setSelected = function(value) {
				this.selected = value;
				if (value == true) {
					$ui.addClass(this,'selected');
					$ui.addClass(this,'theme-brand-background-color');
					$ui.addClass(this,'theme-highlight-text-color');
				} else {
					$ui.removeClass(this,'selected');
					$ui.removeClass(this,'theme-brand-background-color');
					$ui.removeClass(this,'theme-highlight-text-color');
				}
			}.$bind(option);
		}
	}
	// Set our selected index
	if (object.selectedIndex) {
		object._setSelectedIndex(object.selectedIndex);
	} else {
		object.selectedIndex = 0;
		object._setSelectedIndex(0);
	}
	
	return object.dom;
}

/**
 * The SplitView object represents two vertical columns for layout components. The SplitView will size itself to all the available space provided by its parent control.
 * <br><br><b>Sample Declaration</b>
 * <pre>
 * {
 *    component: $ui.SplitView,
 *    left: [
 *        {
 *            component: $ui.SegmentedControl
 *        }
 *    ],
 *    right: [
 *        {
 *            component: $ui.Spinner
 *        }
 *    ]
 * }
 * </pre>
 * @namespace SplitView
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {$ui.CoreComponent[]} left - This array holds all of the component definitions for the left side of the split view
 * @property {$ui.CoreComponent[]} right - This array holds all of the component definitions for the right side of the split view
 */
function $ui_SplitView(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom,'ui-split-view');
	
	var i,
		control,
		controlDom;
	
	// Create our left column
	object.dom.leftCol = document.createElement('div');
	$ui.addClass(object.dom.leftCol, 'col');
	$ui.addClass(object.dom.leftCol, 'left theme-brand-border-color');
	object.dom.appendChild(object.dom.leftCol);
	
	// Load our left column
	if (object.left) {
		for (i = 0; i < object.left.length; i++) {
			control = object.left[i];
			controlDom = $ui.createControl(control, screen);
			if (controlDom) {
				object.dom.leftCol.appendChild(controlDom);
			}
		}
	}
	
	// Create our right column
	object.dom.rightCol = document.createElement('div');
	$ui.addClass(object.dom.rightCol, 'col');
	$ui.addClass(object.dom.rightCol, 'right');
	object.dom.appendChild(object.dom.rightCol);
	
	// Load our right column
	if (object.right) {
		for (i = 0; i < object.right.length; i++) {
			control = object.right[i];
			controlDom = $ui.createControl(control, screen);
			if (controlDom) {
				object.dom.rightCol.appendChild(controlDom);
			}
		}
	}
	
	return object.dom;
}
/**
 * The Tab object represents a tab within a {@link $ui.TabbedPane}.  A tab represents a container of multiple other controls
 * <br><br><b>Sample Declaration</b>
 * <pre>
 * {
 *    component: $ui.Tab,
 *    content: [
 *        {
 *            component: $ui.Spinner
 *        }
 *    ]
 * }
 * </pre>
 * @namespace Tab
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {$ui.CoreComponent[]} content - This array holds all of the component definitions to be displayed in the tab
 * @property {boolean} [selected=false] - This property, when set to <i>true</i> will specify that the tab should be the default selected tab in the [Tabbed Pane]{@link $ui.TabbedPane}.  The Tabbed Pane will select only the first tab it encounters with selected set to <i>true</i> as the selected tab.
 */
function $ui_Tab(object, screen) {
	// All tabs are invisible by default
	object.visible = false;
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom,'ui-tab');
	// Set our default
	if (object.selected != true) {
		object.selected = false;
	}
	
	var i,
		control,
		controlDom;
	// Load our contents
	if (object.content) {
		for (i = 0; i < object.content.length; i++) {
			control = object.content[i];
			controlDom = $ui.createControl(control, screen);
			if (controlDom) {
				object.dom.appendChild(controlDom);
			}
		}
	}
	
	return object.dom;
}
/**
 * The TabbedPane object represents a container that has one or more {@link $ui.Tab} objects.<br><br>
 * A Tabbed Pane will cover the entire area of the control it is contained by. The control will cycle through all of the defined Tabs and see which one has been specified as the first selected tab. If no tabs are found with the specified <b>selected:true</b> property, it will select the first tab in the list.
 * <br><br><b>Sample Declaration</b>
 * <pre>
 * {
 *    component: $ui.TabbedPane,
 *    tabs: [
 *        {
 *            component: $ui.Tab,
 *            selected: true
 *        }
 *    ]
 * }
 * </pre>
 * @namespace TabbedPane
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {$ui.Tab[]} content - This array holds all of the {@link $ui.Tab} objects that are to be controlled by the tabbed pane
*/
function $ui_TabbedPane(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom,'ui-tabbed-pane');
	// Set our default selected tab
	object._selectedTab = undefined;
	
	var i,
		control,
		controlDom,
		selectedTab;
	// Load our tabs
	if (object.tabs) {
		for (i = 0; i < object.tabs.length; i++) {
			control = object.tabs[i];
			if (control.component != $ui.Tab) continue;
			control.parent = object;
			controlDom = $ui.createControl(control, screen);
			if (controlDom) {
				object.dom.appendChild(controlDom);
			}
			// See if it is the selected tab
			if ((control.selected === true) && (object._selectedTab == undefined)) {
				object._selectedTab = control;
			}
		}
	}
	
	/** 
	 * This function will set the selected tab to the value passed in as a parameter
	 * @function selectTab
	 * @memberof $ui.TabbedPane
	 * @param {$ui.Tab} tab - Tab to select
	 */
	object.selectTab = function(tab) {
		if (tab == undefined) return;
		if (tab.component != $ui.Tab) return;
		if (tab === this._selectedTab) return;
		// Unselect all tabs
		var i,
			item;
		for (i = 0; i < this.tabs.length; i++) {
			item = this.tabs[i];
			item.selected = false;
			item.visible = false;
		}
		// Now select the desired tab
		this._selectTab(tab);
	}.$bind(object);
	
	// Private function to select a tab
	object._selectTab = function(tab) {
		if (tab == undefined) return;
		if (tab.component != $ui.Tab) return;
		object._selectedTab = tab;
		tab.selected = true;
		tab.visible = true;
	}.$bind(object);
	
	// Set our selected tab
	if ((object._selectedTab == undefined) && (object.tabs.length > 0)){
		object._selectedTab = object.tabs[0];
	}
	if (object._selectedTab != undefined) {
		object._selectTab(object._selectedTab);
	}
	
	return object.dom;
}
/**
 * The Tile Group object represents a container that holds one or more tiles that inherit from {@link $ui.CoreTile}.
 * <br><br><b>Sample Declaration</b>
 * <pre>
 * {
 *    component: $ui.TileGroup,
 *    tiles: [
 *        {
 *            component: $ui.TileCool,
 *            value: 70
 *        {
 *    ]
 * }
 * </pre>
 * @namespace TileGroup
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {$ui.CoreTile[]} tiles - This array holds all of the Tiles which are to be displayed
 */
function $ui_TileGroup(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom,'ui-tile-group');
	if ($ui.theme.inHeadUnit == true) {
		$ui.addClass(object.dom,'in-head-unit');
	}
	
	// Set our default tile size
	object._tileSize = 256;
	object._thresholdWidth = 1024;
	
	// Create the inner area for the tiles
	object.dom.inner = document.createElement('div');
	$ui.addClass(object.dom.inner, 'group-inner');
	object.dom.appendChild(object.dom.inner);
	
	// Create a matrix for keeping track of open slots
	object.matrix = [];

	// From the row and column number set the top left of the tile
	object._setTileTopLeft = function(tile, rowNum, colNum) {
		tile.dom.style.top = ((rowNum  * this._tileSize) + 'px');
		tile.dom.style.left = ((colNum * this._tileSize) + 'px');
	}.$bind(object);
	
	// Best position the tile in the group
	object._positionTile = function(tile) {
		var row,
			colNum,
			rowNum,
			found = false;
		
		if (tile._size == undefined) { 
			// Will fit in a 1x1 slot..find first slot and insert
			for (rowNum = 0; rowNum < this.matrix.length; rowNum++) {
				row = this.matrix[rowNum];
				for (colNum = 0; colNum < row.length; colNum++) {
					if (row[colNum] === 0) {
						// This space is empty. Now mark it as taken
						row[colNum] = 1;
						this._setTileTopLeft(tile,rowNum,colNum);
						found = true;
						break;
					}
				}
				if (found == true) break;
			}
		} else if (tile._size == $ui.TileSize.WIDE) { 
			// Will fit in a 1x2 slot..find first slot and insert
			for (rowNum = 0; rowNum < this.matrix.length; rowNum++) {
				row = this.matrix[rowNum];
				for (colNum = 0; colNum < row.length; colNum++) {
					if (row[colNum] === 0) {
						if ((colNum+1 <= row.length) && (row[colNum+1] === 0)){
							// This space is empty. Now mark it as taken
							row[colNum] = 1;
							row[colNum+1] = 1;
							this._setTileTopLeft(tile,rowNum,colNum);
							found = true;
							break;
						}
					}
				}
				if (found == true) break;
			}
		} else if (tile._size == $ui.TileSize.TALL) { 
			// Will fit in a 2x1 slot..find first slot and insert
			for (rowNum = 0; rowNum < this.matrix.length; rowNum++) {
				row = this.matrix[rowNum];
				for (colNum = 0; colNum < row.length; colNum++) {
					if (row[colNum] === 0) {
						if ((rowNum+1 < this.matrix.length) && (this.matrix[rowNum+1][colNum] === 0)){
							// This space is empty. Now mark it as taken
							row[colNum] = 1;
							this.matrix[rowNum+1][colNum] = 1;
							this._setTileTopLeft(tile,rowNum,colNum);
							found = true;
							break;
						}
					}
				}
				if (found == true) break;
			}
		} else if (tile._size == $ui.TileSize.SQUARE) { 
			// Will fit in a 2x2 slot..find first slot and insert
			for (rowNum = 0; rowNum < this.matrix.length; rowNum++) {
				row = this.matrix[rowNum];
				for (colNum = 0; colNum < row.length; colNum++) {
					if (row[colNum] === 0) {
						if ((rowNum+1 < this.matrix.length) && (this.matrix[rowNum+1][colNum] === 0) &&
							(colNum+1 < row.length) && (this.matrix[rowNum+1][colNum+1] === 0)){
							// This space is empty. Now mark it as taken
							row[colNum] = 1;
							row[colNum+1] = 1;
							this.matrix[rowNum+1][colNum] = 1;
							this.matrix[rowNum+1][colNum+1] = 1;
							this._setTileTopLeft(tile,rowNum,colNum);
							found = true;
							break;
						}
					}
				}
				if (found == true) break;
			}
		}
		
		// See if no open slot was found
		if (found == false) {
			if (tile._size == undefined) {
				// Add one row and take the first slot
				if (object._is3Columns == true) {
					this.matrix.push([1,0,0]);
				} else {
					this.matrix.push([1,0,0,0]);
				}
				this._setTileTopLeft(tile,this.matrix.length-1,0);
			} else if (tile._size == $ui.TileSize.WIDE) {
				// Add one row and take the first two slots
				if (object._is3Columns == true) {
					this.matrix.push([1,1,0]);
				} else {
					this.matrix.push([1,1,0,0]);
				}
				this._setTileTopLeft(tile,this.matrix.length-1,0);
			} else {
				// Add one row and try again
				if (object._is3Columns == true) {
					this.matrix.push([0,0,0]);
				} else {
					this.matrix.push([0,0,0,0]);
				}
				this._positionTile(tile);
			}
		}
	}.$bind(object);
	
	// Figure out our height based on the matrix
	object._recalculateHeight = function() {
		this.dom.inner.style.height = ((this.matrix.length * this._tileSize) + 'px');
	}.$bind(object);
	
	// Cycle through content
	if (object.tiles) {
		var i,
			control,
			controlDom;
		for (i = 0; i < object.tiles.length; i++) {
			control = object.tiles[i];
			controlDom = $ui.createControl(control, screen);
			if (controlDom) {
				object.dom.inner.appendChild(controlDom);
			}
		}
		object._recalculateHeight();
	}
	
	// Layout all the tiles
	object._layoutTiles = function() {
		var i;
		if (this._is3Columns == false) {
			this.matrix = [];
			this.matrix.push([0,0,0,0]);
		} else {
			this.matrix = [];
			this.matrix.push([0,0,0]);
		}
		// Cycle through our tiles and position them
		for (i = 0; i < this.tiles.length; i++) {
			this._positionTile(this.tiles[i]);
		}
		this._recalculateHeight();
	}.$bind(object);
	
	// Handle resize of screen
	object._onresize = function() {
		if ($ui.options.isClientDevice != true) {
			if ((this._is3Columns == true) && (this.dom.offsetWidth >= this._thresholdWidth)) {
				this._layoutTiles();
			} else if ((this._is3Columns == false) && (this.dom.offsetWidth < this._thresholdWidth)){
				this._layoutTiles();
			}
		}
	}.$bind(object);
	
	// Properly layout the control once animation ends
	object._onshow = function() {
		if ($ui.options.isClientDevice != true) {
			this._is3Columns = (this.dom.offsetWidth < this._thresholdWidth);
			this._layoutTiles();
		}
		this.dom.style.visibility = 'visible';
	}.$bind(object);
	
	return object.dom;
}
/**
 * The Toggle allows a user to move something from a checked/unchecked state typically denoting off/on.
 * <br><br><b>Sample Declaration</b>
 * <pre>
 * {
 *    component: $ui.Toggle,
 *    style: $ui.Toggle.Style.OnOff,
 *    position: 1
 * }
 * </pre>
 * @namespace Toggle
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {number} [position=0] - Represents the position of the switch. 0 represents <b>off</b>, 1 represents <b>on</b> and -1 represents <b>on</b> in reverse direction
 * @property {string} [align=left] - Optionally specify the alignment of the caption as "left", "right" or "center"
 * @property {string} [caption] - Caption to appear with the toggle
 * @property {string} [negativeLabel] - Optional label for the Negative position of an On-Off-On style toggle
 * @property {string} [positiveLabel] - Optional label for the Positive position of an On-Off-On style toggle
 * @property {number} [duration=0] - How long the switch should stay in the <b>on</b> position in milliseconds. A value of 0 means no duration.
 * @property {GenericEvent} [onclick] - Fires when a user clicks the control or changes its state
 */
function $ui_Toggle(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom,'ui-toggle');
		
	if ($ui.theme.inHeadUnit == true) {
		$ui.addClass(object.dom, 'in-head-unit');
	}
	
	// Create our bottom border
	object.dom.bottomBorder = document.createElement('div');
	$ui.addClass(object.dom.bottomBorder, 'bottom-border theme-dark-background-color');
	object.dom.appendChild(object.dom.bottomBorder);
	
	// Create our caption area
	object.dom.caption = document.createElement('span');
	$ui.addClass(object.dom.caption,'caption theme-text-color');
	object.dom.appendChild(object.dom.caption);
	
	// Create our duration area
	object.dom.duration = document.createElement('div');
	$ui.addClass(object.dom.duration, 'duration');
	object.dom.appendChild(object.dom.duration);
	// Bottom
	object.dom.duration.bottomDiv = document.createElement('div');
	$ui.addClass(object.dom.duration.bottomDiv, 'bottom');
	object.dom.duration.appendChild(object.dom.duration.bottomDiv);
	// Number
	object.dom.duration.number = document.createElement('div');
	$ui.addClass(object.dom.duration.number, 'number theme-highlight-text-color');
	object.dom.duration.bottomDiv.appendChild(object.dom.duration.number);
	// Bar
	object.dom.duration.bar = document.createElement('div');
	$ui.addClass(object.dom.duration.bar, 'bar theme-brand-background-color');
	object.dom.duration.bottomDiv.appendChild(object.dom.duration.bar);
	
	// style property
	if (object.style == undefined) {
		object.style = $ui.Toggle.Style.OnOff;
	}
	$ui.addClass(object.dom, object.style);
	object._protected.style = object.style;
	Object.defineProperty(object, 'style', {
		get: function() {return this._protected.style;},
		set: function(value) {
			if (value == undefined) value = $ui.Toggle.Style.OnOff;
			if (value == this._protected.style) return;
			$ui.removeClass(this.dom, this._protected.style);
			if (this._protected.style == $ui.Toggle.Style.OnOff) {
				this.dom.removeChild(this.dom.innerToggle);
			} else if (this._protected.style == $ui.Toggle.Style.Momentary) {
				this.dom.removeChild(this.dom.momentary);
			} else if (this._protected.style == $ui.Toggle.Style.OnOffOn) {
				this.dom.removeChild(this.dom.innerToggle);
			}
			this._protected.style = value;
			$ui.addClass(this.dom, this._protected.style);
			if (value == $ui.Toggle.Style.OnOff) {
				this._createOnOffStyle();
				this._setPosition(this.position);
			} else if (value == $ui.Toggle.Style.Momentary) {
				this._createMomentaryStyle();
			} else if (value == $ui.Toggle.Style.OnOffOn) {
				this._createOnOffOnStyle();
				this._setPosition(this.position);
			}
		},
		configurable: false}
	);
	
	// Handles creating our on-off style of toggle switch
	object._createOnOffStyle = function() {
		// Create our inner Toggle area
		this.dom.innerToggle = document.createElement('div');
		this.dom.innerToggle.model = this;
		$ui.addClass(this.dom.innerToggle, 'inner-toggle theme-border-color');
		this.dom.appendChild(this.dom.innerToggle);
		// Create our inner slide
		this.dom.slide = document.createElement('div');
		$ui.addClass(this.dom.slide,'slide');
		this.dom.innerToggle.appendChild(this.dom.slide);
		// Create our yes area
		this.dom.left = document.createElement('div');
		$ui.addClass(this.dom.left,'left');
		this.dom.slide.appendChild(this.dom.left);
		// Create our button area
		this.dom.button = document.createElement('div');
		$ui.addClass(this.dom.button,'button theme-border-color');
		this.dom.slide.appendChild(this.dom.button);
		this.dom.button.inner = document.createElement('div');
		$ui.addClass(this.dom.button.inner, 'button-inner theme-brand-border-color');
		this.dom.button.appendChild(this.dom.button.inner);
		// Create our right area
		this.dom.right = document.createElement('div');
		$ui.addClass(this.dom.right,'right');
		this.dom.slide.appendChild(this.dom.right);
		// Fire the onclick
		this.dom.innerToggle.addEventListener('click', function() {
			if (this.model.enabled == false) return;
			if (this.model._protected.isCountingDown == true) return;
			$ui.playTouchSound();
			if (this.model.position == 0) {
				this.model.position = 1;
			} else {
				this.model.position = 0;
			}
			if (this.model.onclick) {
				this.model.onclick(this.model);
			}
		},false);
	}.$bind(object);
	
	// Handles creating our on-off-on style of toggle switch
	object._createOnOffOnStyle = function() {
		// Create our inner Toggle area
		this.dom.innerToggle = document.createElement('div');
		this.dom.innerToggle.model = this;
		$ui.addClass(this.dom.innerToggle, 'inner-toggle theme-border-color');
		this.dom.appendChild(this.dom.innerToggle);
		// Create our inner slide
		this.dom.slide = document.createElement('div');
		$ui.addClass(this.dom.slide,'slide');
		this.dom.innerToggle.appendChild(this.dom.slide);
		// Create our left area
		this.dom.left = document.createElement('div');
		$ui.addClass(this.dom.left,'left');
		this.dom.slide.appendChild(this.dom.left);
		this.dom.left.label = document.createElement('div');
		$ui.addClass(this.dom.left.label, 'label theme-dark-text-color');
		this.dom.left.appendChild(this.dom.left.label);
		if (this.negativeLabel != undefined && this.style == $ui.Toggle.Style.OnOffOn) {
			this.dom.left.label.textContent = this.negativeLabel;
		}	
		// Create our button area
		this.dom.button = document.createElement('div');
		$ui.addClass(this.dom.button,'button theme-border-color');
		this.dom.slide.appendChild(this.dom.button);
		this.dom.button.inner = document.createElement('div');
		$ui.addClass(this.dom.button.inner, 'button-inner theme-brand-border-color');
		this.dom.button.appendChild(this.dom.button.inner);
		// Create our right area
		this.dom.right = document.createElement('div');
		$ui.addClass(this.dom.right,'right');
		this.dom.slide.appendChild(this.dom.right);
		this.dom.right.label = document.createElement('div');
		$ui.addClass(this.dom.right.label, 'label theme-dark-text-color');
		this.dom.right.appendChild(this.dom.right.label);
		if (this.positiveLabel != undefined && this.style == $ui.Toggle.Style.OnOffOn) {
			this.dom.right.label.textContent = this.positiveLabel;
		}	
		// Fire the onclick
		this.dom.innerToggle.onclick = function(event) {
			if (this.model.enabled == false) return;
			if (this.model._protected.isCountingDown == true) return;
			$ui.playTouchSound();
			var rect = this.getBoundingClientRect(),
				third = (rect.right - rect.left)/3;	
			if (event.clientX < (rect.left + third)) {
				this.model.position = -1; // Negative
			} else if (event.clientX > (rect.right - third)) {
				this.model.position = 1; // Positive
			} else {
				this.model.position = 0; // Off
			}
			if (this.model.onclick) {
				this.model.onclick(this.model);
			}
		};
	}.$bind(object);
	
	// Create our DOM for a momentary switch
	object._createMomentaryStyle = function() {
		this.dom.momentary = document.createElement('div');
		this.dom.momentary.model = this;
		$ui.addClass(this.dom.momentary, 'momentary theme-brand-background-color theme-highlight-text-color');
		this.dom.appendChild(this.dom.momentary);
		this.dom.momentary.onclick = function(event) {
			if (this.model._protected.isCountingDown == true) return;
			if (this.model.enabled == false) return;
			$ui.playTouchSound();
			this.model.position = 1;
			if (this.model.onclick) {
				this.model.onclick(this.model);
			}
			if (this.model.duration == undefined || this.model.duration <= 0) {
				var model = this.model;
				window.setTimeout(function() {
					model.position = 0;
				}, 500);
			}
		};
		this.dom.momentary.ontouchstart = function() {
			this.style.opacity = '0.7';
		};
		this.dom.momentary.ontouchend = function() {
			this.style.opacity = '';
		};
		this.dom.momentary.ontouchcancel = this.dom.momentary.ontouchend;
		if (!$ui.isMobileDevice()) {
			this.dom.momentary.onmousedown = this.dom.momentary.ontouchstart;
			this.dom.momentary.onmouseup = this.dom.momentary.ontouchend;
			this.dom.momentary.onmouseleave = this.dom.momentary.ontouchend;
		}
	}.$bind(object);
	
	// This is our standard toggle
	if (object.style == $ui.Toggle.Style.OnOff) {
		object._createOnOffStyle();
	} else if (object.style == $ui.Toggle.Style.Momentary) { // Our momentary switch styling
		object._createMomentaryStyle();
	} else if (object.style == $ui.Toggle.Style.OnOffOn) {
		object._createOnOffOnStyle();
	}
	
	// positiveLabel Property
	object._protected.positiveLabel = object.positiveLabel;
	Object.defineProperty(object, 'positiveLabel', {
		get: function() {return this._protected.positiveLabel;},
		set: function(value) {
			if (value == undefined) value = '';
			if (value == this._protected.positiveLabel) return;
			this._protected.positiveLabel = value;
			if (this.style == $ui.Toggle.Style.OnOffOn) {
				this.dom.right.label.textContent = value;
			}
		},
		configurable: false}
	);
	
	// negativeLabel Property
	object._protected.negativeLabel = object.negativeLabel;
	Object.defineProperty(object, 'negativeLabel', {
		get: function() {return this._protected.negativeLabel;},
		set: function(value) {
			if (value == undefined) value = '';
			if (value == this._protected.negativeLabel) return;
			this._protected.negativeLabel = value;
			if (this.style == $ui.Toggle.Style.OnOffOn) {
				this.dom.left.label.textContent = value;
			}
		},
		configurable: false}
	);
	
	// Caption Property
	if (object.caption != undefined) {
		object.dom.caption.textContent = object.caption;
	}	
	object._protected.caption = object.caption;
	Object.defineProperty(object, 'caption', {
		get: function() {return this._protected.caption;},
		set: function(value) {
			if (value == this._protected.caption) return;
			if (value == undefined) value = '';
			this._protected.caption = value;
			this.dom.caption.textContent = value;
		},
		configurable: false}
	);
	
	// align property
	if (object.align == 'center') {
		$ui.addClass(object.dom.caption,'align-center');
	} else if (object.align == 'right') {
		$ui.addClass(object.dom.caption,'align-right');
	} else {
		object.align = 'left';
		$ui.addClass(object.dom.caption,'align-left');
	}
	object._protected.align = object.align;
	Object.defineProperty(object, 'align', {
		get: function() {return this._protected.align;},
		set: function() {
			console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','align'));
		},
		configurable: false}
	);
	
	// Private function to set the position state
	object._setPosition = function(value) {
		if (value == undefined) {
			value = 0;
		}
		this._protected.position = value;
		if (this.style == $ui.Toggle.Style.OnOff) {
			if (value == 0) {
				$ui.removeClass(this.dom.innerToggle,'yes');
				$ui.removeClass(this.dom.innerToggle, 'theme-brand-background-color');
				$ui.removeClass(this.dom.button.inner,'theme-light-background-color');
				$ui.addClass(this.dom.innerToggle,'no');
			} else {
				$ui.removeClass(this.dom.innerToggle, 'no');
				$ui.addClass(this.dom.innerToggle,'yes theme-brand-background-color');
				$ui.addClass(this.dom.button.inner,'theme-light-background-color');
			}
		} else if (this.style == $ui.Toggle.Style.OnOffOn) {
			$ui.removeClass(this.dom.innerToggle, 'theme-brand-background-color');
			$ui.removeClass(this.dom.button.inner,'theme-light-background-color');
			if (value == 0) {
				$ui.removeClass(this.dom.innerToggle,'positive');
				$ui.removeClass(this.dom.innerToggle,'negative');
				this.dom.right.label.style.display = 'block';
				this.dom.left.label.style.display = 'block';
			} else if (value == 1) {
				$ui.removeClass(this.dom.innerToggle, 'negative');
				$ui.addClass(this.dom.innerToggle,'positive theme-brand-background-color');
				$ui.addClass(this.dom.button.inner,'theme-light-background-color');
				this.dom.right.label.style.display = 'none';
				this.dom.left.label.style.display = 'none';
			} else {
				$ui.removeClass(this.dom.innerToggle, 'positive');
				$ui.addClass(this.dom.innerToggle,'negative theme-brand-background-color');
				$ui.addClass(this.dom.button.inner,'theme-light-background-color');
				this.dom.right.label.style.display = 'none';
				this.dom.left.label.style.display = 'none';
			}
		}
	}.$bind(object);
	
	// duration Property
	if (object.duration == undefined) {
		object.duration = 0;
	}
	if (object.duration > 0) {
		object.dom.duration.style.display = 'block';
	}
	object._protected.duration = object.duration;
	Object.defineProperty(object, 'duration', {
		get: function() {return this._protected.duration;},
		set: function(value) {
			if (value == undefined) value = 0;
			if (value == this._protected.duration) return;
			this._protected.duration = value;
			if (value <= 0) {
				this.dom.duration.style.display = 'none';
			} else {
				this.dom.duration.style.display = 'block';
			}
		},
		configurable: false}
	);
	
	// position Property
	if (object.position == undefined) {
		object.position = 0;
	}
	object._setPosition(object.position);
	object._protected.position = object.position;
	Object.defineProperty(object, 'position', {
		get: function() {return this._protected.position;},
		set: function(value) {
			if (value == this._protected.position) return;
			this._protected.position = value;
			this._setPosition(value);
			this._updateData(value); // update our provider
			if (value == 0) {
				this._protected.isCountingDown = false;
				this.dom.duration.bottomDiv.style.opacity = 0;
				this.dom.duration.style['-webkit-transform'] = 'translate3d(0px, 0px, 0px)';
				if (this.style == $ui.Toggle.Style.OnOff || this.style == $ui.Toggle.Style.OnOffOn) {
					this.dom.innerToggle.style.opacity = 1;
				} else {
					this.dom.momentary.style.opacity = 1;
				}
			} else if ( this.duration && this.duration > 0) {
				this.dom.duration.bottomDiv.style.opacity = 1;
				if ($ui.options.isClientDevice == true) {
					this.dom.duration.style['-webkit-transform'] = 'translate3d(-20px, -10px, 0px)';
				} else {
					this.dom.duration.style['-webkit-transform'] = 'translate3d(-26px, -14px, 0px)';
				}
				this._protected.intervalCount = this.duration;
				this._protected.isCountingDown = true;
				this.dom.duration.bar.style.width = '100%';
				this.dom.duration.number.textContent = (this._protected.intervalCount/1000);
				this._protected.interval = window.setInterval(this._countDownInterval, 1000);
				if (this.style == $ui.Toggle.Style.OnOff || this.style == $ui.Toggle.Style.OnOffOn) {
					this.dom.innerToggle.style.opacity = 0.5;
				} else {
					this.dom.momentary.style.opacity = 0.5;
				}
			}
		},
		configurable: false}
	);
	
	// Handle our count down interval
	object._countDownInterval = function() {
		this._protected.intervalCount = this._protected.intervalCount - 1000;
		var rounded = this._protected.intervalCount / 1000;
		if (rounded < 0) {
			rounded = 0;
		}
		this.dom.duration.number.textContent = rounded;
		this.dom.duration.bar.style.width = (1 - (this._protected.duration - this._protected.intervalCount)/this._protected.duration) *100 + '%';
		if (this._protected.intervalCount <= 0) {
			window.clearInterval(this._protected.interval);
			this.position = 0;
		}
	}.$bind(object);
	
	// Private function to handle provider updates
	object._providerUpdate = function(value) {
		this._setPosition(value);
	}.$bind(object);
	
	object._ondestroy = function() {
		if (this._protected.interval) {
			window.clearInterval(this._protected.interval);
		}
	}.$bind(object);
	
	return object.dom;
}

/**
 * This is the object that represents a window instance in a head unit. It derives from {@link $ui.CoreScreen}. A WindowPane is declared as a JavaScript function and has various different properties. 
 * When a WindowPane is pushed onto the stack a new instance of the screen will be created and rendered.
 * <br><br><b>Sample Declaration</b>
 * <pre>
 * function MyWindowPane() {
 *   this.component = $ui.WindowPane;
 *   this.content = [
 *       {
 *          component: $ui.SegmentedControl,
 *       }
 *   ];
 *
 *   this.onshow = function() {
 *      console.log('I was just shown');
 *   }
 * }
 * </pre>
 * @namespace WindowPane
 * @memberof $ui
 * @extends $ui.CoreScreen
 * @property {ScreenBackground} [background] - This object defines the type of background to be shown on the screen
 * @property {$ui.CoreComponent[]} content - This object array specifies the list of controls that will be rendered in this screen
 * @property {string} [backCaption] - This property defines the text you would like to appear on the title bar with a back button. If this is left <i>undefined</i> then no back button will appear
 * @property {GenericEvent} [onbackclick] - This event fires when the user presses the "Back" button.  It allows you to run logic before the screen is popped off of the stack.  If you wish to block the "Back" action return <b>false</b> from your event handler
 */
function $ui_WindowPane(object, data) {
	$ui_CoreScreen.call(this, object, data);
	if (object) {
		$ui.addClass(object.dom,'ui-window-pane theme-screen-background-color');
		if ($ui.theme.inHeadUnit == true) {
			$ui.addClass(object.dom, 'in-head-unit');
		}
		
		// Set our width to that of our parent
		if (!object.width) {
			object.dom.style.width = window.innerWidth + 'px'; // default
		} else {
			object.dom.style.width = object.width + 'px';
		}
		
		// Create our background image div
		object.dom.backgroundDiv = document.createElement('div');
		$ui.addClass(object.dom.backgroundDiv,'background theme-screen-background-color');
		object.dom.appendChild(object.dom.backgroundDiv);
		
		if (object.backCaption) {
			object.dom.backBar = document.createElement('div');
			$ui.addClass(object.dom.backBar,'back-bar theme-screen-background-color theme-brand-border-color');
			$ui.addClass(object.dom,'has-back');
			object.dom.appendChild(object.dom.backBar);
			object.dom.backCaption = document.createElement('span');
			object.dom.backCaption.textContent = object.backCaption;
			object.dom.backCaption.model = object;
			$ui.addClass(object.dom.backCaption,'caption theme-text-color');
			object.dom.backBar.appendChild(object.dom.backCaption);
			object.dom.backCaption.onclick = function() {
				$ui.playTouchSound();
				if (this.model.onbackclick) {
					var allow = this.model.onbackclick();
					if (allow != false) {
						$ui.pop();
					}
				} else {
					$ui.pop();
				}
			};
			try {
				Object.defineProperty(object,"backCaption",{
					get:function() {
						return object.dom.backCaption.textContent;
					},set:function(newCaption) {
						console.log("RPW: setting caption to " + newCaption);
						object.dom.backCaption.textContent = newCaption;
					}
				});
			} catch (toIgnore) {
				console.log("RPW: ignoring " + toIgnore);
			}
		}

		/** 
		 * Set the background for the screen
		 * @function setBackground
		 * @memberof $ui.WindowPane
		 * @param {ScreenBackground} screenBackground - The background object to use for the screen.
		 */
		object.setBackground = function(screenBackground) {
			// Clear existing background
			if (this.background) {
				this.dom.backgroundDiv.style.opacity = '0';
			} 
			// Load new background
			if (screenBackground != undefined) {
				this.background = screenBackground;
				// Check for repeat
				if (this.background.repeat === true) {
					this.dom.backgroundDiv.style.backgroundRepeat = 'repeat';
				} else {
					this.dom.backgroundDiv.style.backgroundSize = 'cover';
				}
				// Load our image
				if (this.background.img) {
					this._loader = new Image();
					this._loader.model = this;
					this._loader.onload = function() {
						this.model.dom.backgroundDiv.style.backgroundImage = 'url("'+this.model.background.img+'")';
						this.model.dom.backgroundDiv.style.opacity = '1';
						this.model._loader = null;
					}
					this._loader.src = this.background.img;
				}
			}
		}.$bind(object);
				
		// Create our content div for the controls
		object.dom.contentDiv = document.createElement('div');
		$ui.addClass(object.dom.contentDiv, 'inner');
		object.dom.appendChild(object.dom.contentDiv);
		
		// content Property
		object._protected.content = object.content;
		Object.defineProperty(object, 'content', {
			get: function() {return this._protected.content;},
			set: function() {
				console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','content'));
			},
			configurable: false} 
		);
		
		// Implementing CoreContainerComponent Interface
		object._getControlListProperty = function() {
			return this.content;
		}.$bind(object);
		
		// Implementing CoreContainerComponent Interface
		object._getControlListDom = function() {
			return this.dom.contentDiv;
		}.$bind(object);
		
		// Create all the content
		if (object.content) {
			for (var i = 0; i < object.content.length; i++) {
				object._addComponent(object.content[i]);
			}
		}
		
		// Handle window pane resizes
		object._onwindowpaneresize = function() {
			// Set our width to that of our parent
			this.dom.style.width = '';
			this.dom.style.right = '0px';
		}.$bind(object);
		
		// Clean-up any listeners
		object._onbeforepop = function() {
			if (this.animated == true) {
				this.dom.style['-webkit-animation-delay'] = '';
				this.dom.style['-webkit-animation-name'] = 'ui-pane-slide-right';
			}
		}.$bind(object);
		
		// Initialize the screen
		object._initialize = function() {
			// Load the background if needed
			if (this.background) {
				this.setBackground(this.background);
			}
		}.$bind(object);
		
		return object.dom;
	}
}
/**
 * The Browser control represents the browser window including both the chrome and the viewer.<br><br>
 * This object will create an iframe area while in demo mode. But when in PhoneGap it will create a child browser window that it will overlay on the screen.<br><br>
 * <b>Sample Declaration</b><br>
 * <pre>
 * {
 *    component: $ui.Browser,
 *    src: 'http://workshoptwelve.com'
 * }
 * @namespace Browser
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {string} [src] - The url path of the browser
 * @property {GenericEvent} [onfavoriteclick] - Fired when the user selects to add a favorite
 * @property {GenericEvent} [onbookmarksclick] - Fired when a user wants to see their bookmarks
*/
function $ui_Browser(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom,'ui-browser');
	// Check to see if we are in the emulator
	if (window.$system && ($system.config.isEmulator == true)) {
		object._protected.isIFrame = false;
	} else {
		object._protected.isIFrame = true;
	}
	
	// Create our chrome
	object.dom.chrome = document.createElement('div');
	$ui.addClass(object.dom.chrome,'chrome theme-brand-border-color');
	object.dom.appendChild(object.dom.chrome);
	
	// URL input
	object.dom.inputDiv = document.createElement('div');
	$ui.addClass(object.dom.inputDiv,'inputDiv theme-light-background-color theme-brand-border-color');
	object.dom.chrome.appendChild(object.dom.inputDiv);
	object.dom.input = document.createElement('input');
	object.dom.input.model = object;
	object.dom.input.setAttribute('spellcheck','false');
	object.dom.inputDiv.appendChild(object.dom.input);
	// Handle focus and clearing
	object.dom.input.onclick = function(e) {
		if ((this.offsetWidth - e.offsetX) <= 30) {
			this.value = '';
		}
	}
	// Handle enter key
	object.dom.input.onkeyup = function(e) {
		if (e.keyCode == 13) {
			this.model.src = this.value;
		}
	}

	// Create our icon/spinner area
	object.dom.icon = document.createElement('div');
	$ui.addClass(object.dom.icon,'icon');
	object.dom.inputDiv.appendChild(object.dom.icon);
	object.dom.spinner = new $ui_Spinner({component: $ui.Spinner, size: $ui.Size.TINY, forceColor:'dark'},screen);
	object.dom.spinner.style.display = 'none';
	object.dom.icon.appendChild(object.dom.spinner);
	
	// Back button
	object._backBtn = {style: 'back',parent: object};
	new $ui_BrowserButton(object._backBtn,screen);
	object.dom.chrome.appendChild(object._backBtn.dom);
	object._backBtn.dom.onclick = function() {
		if (this.model.parent._protected.isIFrame == false) {
			var webview = this.model.parent.dom.contentWindow;
			if (webview.canGoBack() == true) {
				webview.back();	
			}
		}
	}
	
	// Next button
	object._nextBtn = {style: 'next',parent: object};
	new $ui_BrowserButton(object._nextBtn,screen);
	object.dom.chrome.appendChild(object._nextBtn.dom);
	object._nextBtn.dom.onclick = function() {
		if (this.model.parent._protected.isIFrame == false) {
			var webview = this.model.parent.dom.contentWindow;
			if (webview.canGoForward() == true) {
				webview.forward();	
			}
		}
	}
	
	// Stop/Refresh button
	object._refreshBtn = {style: 'stop',parent: object};
	new $ui_BrowserButton(object._refreshBtn,screen);
	object.dom.chrome.appendChild(object._refreshBtn.dom);
	object._refreshBtn.dom.onclick = function() {
		if (this.model.parent._protected.isIFrame == false) {
			var webview = this.model.parent.dom.contentWindow;
			if (this.model.style == 'stop') {
				webview.stop();
			} else {
				webview.reload();
			}
		}
	}
	
	// New Tab button
	object._newTabBtn = {style: 'new-tab',parent: object};
	new $ui_BrowserButton(object._newTabBtn,screen);
	object.dom.chrome.appendChild(object._newTabBtn.dom);
	object._newTabBtn.dom.onclick = function() {
		if (this.model.parent._protected.isIFrame == false) {
			$ui.toast('Sorry! Tabs aren\'t enabled yet in the emulator');
		}
	}
	
	// Favorite Button
	object._favoriteBtn = {style: 'favorite',parent: object};
	new $ui_BrowserButton(object._favoriteBtn,screen);
	object.dom.chrome.appendChild(object._favoriteBtn.dom);
	object._favoriteBtn.dom.onclick = function() {
		if (this.model.parent._protected.isIFrame == false) {
			if (this.model.parent.onfavoriteclick) {
				this.model.parent.onfavoriteclick();
			}
		}
	}
	
	// Bookmarks Button
	object._bookmarksBtn = {style: 'bookmarks',parent: object};
	new $ui_BrowserButton(object._bookmarksBtn,screen);
	object.dom.chrome.appendChild(object._bookmarksBtn.dom);
	object._bookmarksBtn.dom.onclick = function() {
		if (this.model.parent._protected.isIFrame == false) {
			if (this.model.parent.onbookmarksclick) {
				this.model.parent.onbookmarksclick();
			}
		}
	};
	
	// Create our Browser display area
	object.dom.browserDiv = document.createElement('div');
	$ui.addClass(object.dom.browserDiv,'browserDiv');
	object.dom.appendChild(object.dom.browserDiv);
	object.dom.browserDiv.model = object;
	
	// If we are displaying in an iframe for demo purposes
	if (object._protected.isIFrame === true) {
		object.dom.contentWindow = document.createElement('iframe');
	} else {
		object.dom.contentWindow = document.createElement('webview');
	}
	$ui.addClass(object.dom.contentWindow, 'window');
	object.dom.browserDiv.appendChild(object.dom.contentWindow);
	
	// Src Property
	object._protected.src = object.src;
	Object.defineProperty(object, 'src', {
		get: function() {return this._protected.src;},
		set: function(value) {
			if (value == this._protected.src) return;
			this._protected.src = value;
			this._setSrc(value);
		},
		configurable: false}
	);
	
	// Internal function to set the url
	object._setSrc = function(value) {
		this.dom.input.value = value;
		this._onstartload();
		this.dom.contentWindow.src = value;
	}.$bind(object);
	
	// Triggered when content is starting to load
	object._onstartload = function() {
		this.dom.spinner.style.display = '';
		this._refreshBtn.setStyle('stop');
		$ui.removeClass(this.dom.icon,'page');	
		if (this._protected.isIFrame == false) {
			if (event != undefined && event.isTopLevel == true) {
				this.dom.input.value = event.url;
				this._protected.src = event.url;
			}
		}
	}.$bind(object);
	
	// Triggered when content is fully loaded
	object._onload = function() {
		this.dom.spinner.style.display = 'none';
		$ui.addClass(this.dom.icon,'page');
		this._refreshBtn.setStyle('refresh');	
	}.$bind(object);
	
	// Handle clearing the UI before the pop animation
	object._onbeforepop = function() {
		this.dom.contentWindow.style.display = 'none';
	}.$bind(object);
	
	// Handle loading on show
	object._onshow = function() {
		// Wait for show to load the URL
		if (this.src) {
			this._setSrc(this.src);
		}
		this.dom.contentWindow.style.visibility = 'visible';
		// Need to add detection here. If added to the iframe before inserted into
		// the DOM, it will fire twice
		if (this._protected.isIFrame === true) {
			this.dom.contentWindow.onload = object._onload;
		} else {
			this.dom.contentWindow.addEventListener("loadstart", this._onstartload);
       		this.dom.contentWindow.addEventListener("loadstop", this._onload);
			// Hack for scaling webviews in a Chrome App.. Scaling issue
			this.dom.contentWindow.style.width = this.dom.browserDiv.offsetWidth + 'px';
			this.dom.contentWindow.style.height = this.dom.browserDiv.offsetHeight + 'px';
		}
	}.$bind(object);

	// Private function to do cleanup
	object._ondestroy = function() {
		if (this._protected.isIFrame == false) {
			this.dom.contentWindow.removeEventListener("loadstart", this._onstartload);
       		this.dom.contentWindow.removeEventListener("loadstop", this._onload);
		}
 	}.$bind(object);
	
	// Handle the sizing of the screen for the <webview>
	object._onresize = function() {
		// Hack for webviews in Chrome App... Scaling issue
		if (this._protected.isIFrame == false) {
			var webview = this.dom.contentWindow;
			webview.style.display = 'none';
			setTimeout(function() {webview.style.display = 'block';},500);
		}
	}.$bind(object);
	
	return object.dom;
}
function $ui_BrowserButton(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom,'button');
	
	// Set our style
	if (object.style) {
		$ui.addClass(object.dom, object.style);
	}
	
	// Handle the click
	object.dom.onclick = function() {
		if (this.model.enabled === false) return;
		$ui.playTouchSound();
		if (this.model.onclick) {
			this.model.onclick();
		}
	}
	object.dom.ontouchstart = function() {
		if (this.model.enabled === false) return;
		$ui.addClass(this,'theme-brand-background-color');
	}
	object.dom.ontouchend = function() {
		if (this.model.enabled === false) return;
		$ui.removeClass(this,'theme-brand-background-color');
	}
	object.dom.ontouchcancel = object.dom.ontouchend;
	if (!$ui.isMobileDevice()) {
		object.dom.onmousedown = object.dom.ontouchstart;
		object.dom.onmouseup = object.dom.ontouchend;
	}

	// Public function to set the style of the button
	object.setStyle = function(value) {
		if (value == this.style) return;
		if (this.style != undefined) {
			$ui.removeClass(this.dom,this.style);
		}
		$ui.addClass(this.dom, value);
		this.style = value;
	}.$bind(object);
	
	return object.dom;
}
/**
 * The color list item type is used with the {@link $ui.List} component.  
 * <br><br><b>Sample Declaration</b>
 * <pre>
 * {
 *   color: '#FFFFFF',
 *}
 * </pre>
 * @namespace ColorListItem
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {string} color - A valid CSS color value
 * @property {boolean} [selected=false] - Whether or not this is a selected color
 */
function $ui_ColorListItem(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom, 'ui-color-list-item');
	
	// color Property
	if (object.color != undefined) {
		object.dom.style.backgroundColor = object.color;	
	} 
	object._protected.color = object.color;
	Object.defineProperty(object, 'color', {
		get: function() {return this._protected.color;},
		set: function(value) {
			if (value == this._protected.color) return;
			this._protected.color = value;
			if (color == undefined) {
				this.dom.style.backgroundColor = '';
			} else {
				this.dom.style.backgroundColor = value;
			}
		},
		configurable: false}
	);
	
	// selected Property
	if (object.selected == true) {
		$ui.addClass(object.dom,'selected');
	} else {
		object.selected = false;
	}
	object._protected.selected = object.selected;
	Object.defineProperty(object, 'selected', {
		get: function() {return this._protected.selected;},
		set: function(value) {
			if (value == this._protected.selected) return;
			if (value == undefined) value = false;
			this._protected.selected = value;
			if (value == false) {
				$ui.removeClass(object.dom,'selected');
			} else {
				$ui.addClass(object.dom,'selected');
			}
		},
		configurable: false}
	);

	// Pass the onclick back to the list
	object.dom.addEventListener('click', function() {
		var i,
			item;
		for (i= 0; i< this.model.parent.items.length; i++) {
			item = this.model.parent.items[i];
			if (item != this.model) {
				item.selected = false;
			}
		}
		this.model.selected = true;
		if (this.model.parent.onaction) {
			var event = new ListEvent(this.model, $ui.ColorListItem.ColorListEvent.ONCLICK);
			this.model.parent._onaction(this.model, event);
		}
		$ui.playTouchSound();
	},false);

	return object.dom;
}
/**
 * The DialPad object a phone dialer keypad component<br><br>
 * <b>Sample Declaration</b><br>
 * <pre>
 * {
 *    component: $ui.DialPad,
 *    onkeypadpress: function(key) {
 *       console.log(key);
 *    }
 * }
 * @namespace DialPad
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {KeyPadPressEvent} [onkeypadpress] - The event which will fire when a button on the keypad is pressed
 * @property {$ui.DialPadNumber} number - Class holding the number which has been entered into the keypad.
 */
function $ui_DialPad(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom, 'ui-dial-pad');

	if (!object.number) {
		object.number = {};
	}

	object.dom.number = new $ui_DialPadNumber(object.number, screen);
	object.dom.appendChild(object.dom.number);

	object._buttons = [{
		caption: '1',
	}, {
		caption: '2',
		letters: 'ABC'
	}, {
		caption: '3',
		letters: 'DEF'
	}, {
		caption: '4',
		letters: 'GHI'
	}, {
		caption: '5',
		letters: 'JKL'
	}, {
		caption: '6',
		letters: 'MNO'
	}, {
		caption: '7',
		letters: 'PQRS'
	}, {
		caption: '8',
		letters: 'TUV'
	}, {
		caption: '9',
		letters: 'WXYZ'
	}, {
		caption: '*',
		center: true
	}, {
		caption: '0',
		letters: '+'
	}, {
		caption: '#',
		center: true
	}];

	var i,
		button;
	for (i = 0; i < object._buttons.length; i++) {
		button = object._buttons[i];
		button.parent = object;
		dom = new $ui_DialPadButton(button, screen);
		object.dom.appendChild(dom);
	}
	
	// Create the dial button
	object.dom.dialButton = new $ui_DialPadButton({
			parent: object,
			letters: 'Call',
			dial: true
		}, screen);
	object.dom.appendChild(object.dom.dialButton);

	return object.dom;
}

/**
 * @namespace DialPadKey
 * @memberof $ui
 * @property {string} caption - The number or letter on the button
 * @property {string} [letters] - Optional secondary letters for the button such as "ABC"
 */

/**
 * The {@link $ui.DialPad} <b>onkeypadpress</b> event will fire when the user clicks a keypad button
 * @callback KeyPadPressEvent
 * @param {$ui.DialPadKey} key - The key which was pressed
 */
/**
 * A button that will appear in the phone dialer.
 * @namespace DialPadButton
 * @memberof $ui
 * @property {string} caption - The main caption to display for the button.
 * @property {string} letters - The letter equivalents of the button.
 * @property {boolean} [center] - Flag indicating if the control should be centered.
 * @property {boolean} [dial] - Flag indicating if this is a dial button - it will appear differently.
 */
function $ui_DialPadButton(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom, 'button theme-text-color');
	object._private = {};

	object._private.playTouchSound = function() {
		switch (this.caption) {
			case '0':
				$system.audio.playSoundEffect($system.SoundEffect.TONE0);
				break;
			case '1':
				$system.audio.playSoundEffect($system.SoundEffect.TONE1);
				break;
			case '2':
				$system.audio.playSoundEffect($system.SoundEffect.TONE2);
				break;
			case '3':
				$system.audio.playSoundEffect($system.SoundEffect.TONE3);
				break;
			case '4':
				$system.audio.playSoundEffect($system.SoundEffect.TONE4);
				break;
			case '5':
				$system.audio.playSoundEffect($system.SoundEffect.TONE5);
				break;
			case '6':
				$system.audio.playSoundEffect($system.SoundEffect.TONE6);
				break;
			case '7':
				$system.audio.playSoundEffect($system.SoundEffect.TONE7);
				break;
			case '8':
				$system.audio.playSoundEffect($system.SoundEffect.TONE8);
				break;
			case '9':
				$system.audio.playSoundEffect($system.SoundEffect.TONE9);
				break;
			case '#':
				$system.audio.playSoundEffect($system.SoundEffect.TONE_POUND);
				break;
			case '*':
				$system.audio.playSoundEffect($system.SoundEffect.TONE_ASTERIK);
				break;
		}
	}.$bind(object);

	// Create the number
	if (!object.dial) {
		object.dom.captionDiv = document.createElement('div');
		$ui.addClass(object.dom.captionDiv, 'caption');
		object.dom.captionDiv.textContent = object.caption;
		object.dom.appendChild(object.dom.captionDiv);

		// See if we need to center the number
		if (object.center === true) {
			$ui.addClass(object.dom.captionDiv, 'centered');
		}

		// Create extra letters
		object.dom.letters = document.createElement('div');
		$ui.addClass(object.dom.letters, 'letters');
		object.dom.appendChild(object.dom.letters);
		if (object.letters) {
			object.dom.letters.textContent = object.letters;
		}
		object.dom.ontouchstart = function() {
			$ui.addClass(this,'theme-brand-background-color');
			$ui.addClass(this, 'theme-highlight-text-color');
			this._private.playTouchSound();
		}.$bind(object);
		object.dom.ontouchend = function() {
			$ui.removeClass(this,'theme-brand-background-color');
			$ui.removeClass(this, 'theme-highlight-text-color');
		}
	} else {
		// Create extra letters
		object.dom.letters = document.createElement('div');
		$ui.addClass(object.dom.letters, 'letters');
		object.dom.appendChild(object.dom.letters);
		object.dom.letters.textContent = object.letters;
		
		// This is a dial button.
		$ui.addClass(object.dom, 'dial theme-call-button');
		object.dom.ontouchstart = function() {
			this.style.opacity = 0.7;
		};
		object.dom.ontouchend = function() {
			this.style.opacity = 1;
		};
	}
	// Set our touch interaction
	object.dom.ontouchcancel = object.dom.ontouchend;
	if (!$ui.isMobileDevice()) {
		object.dom.onmousedown = object.dom.ontouchstart;
		object.dom.onmouseup = object.dom.ontouchend;
		object.dom.onmouseleave = object.dom.ontouchend;
	}

	// Handle the click event
	object.dom.onclick = function() {
		var key = {
			caption: this.model.caption,
			letters: this.model.letters,
			dial: this.model.dial
		};
		if ((this.model.parent != undefined) && (this.model.parent.onkeypadpress)) {
			this.model.parent.onkeypadpress(key);
		}
	}

	return object.dom;
}
/**
 * This class holds the number being dialled by the user. It can also create a pretty version of it.
 * @namespace DialPadNumber
 * @memberof $ui
 * @property {string} number - The number that has been entered into the pad.
 * @property {string} prettyNumber - A US+Canada friendly formatting of the number.
 * @property {$ui.DialPadNumber.DialPadNumberChangedEvent} onnumberchanged - Event triggered when the number is changed.
 */
/**
 * This callback is used to see when the user as changed their number.
 * @callback DialPadNumberChangedEvent
 * @memberof $ui.DialPadNumber
 * @property {string} number - The number that has been entered.
 * @property {string} prettyNumber - A pretty version of the same number.
 */
function $ui_DialPadNumber(object, screen) {
    $ui_CoreComponent.call(this, object, screen);
    $ui.addClass(object.dom, 'ui-dial-pad-number theme-dark-background-color');

    function pretty(number) {
        if (number.length > 13) {
            return "... " + number.substring(number.length - 13);
        }
        if (number.length == 11) {
            return number.substring(0, 1) + " " + pretty(number.substring(1));
        }
        if (number.length == 10) {
            return "(" + number.substring(0, 3) + ") " + pretty(number.substring(3));
        }
        if (number.length == 7) {
            return number.substring(0, 3) + "-" + number.substring(3);
        }
        return number;
    }

    var touchStart = function() {
        this.dom.del.style.opacity = "0.7";
    }.$bind(object);

    var touchEnd = function() {
        if (this.number.length > 0) {
            this.dom.del.style.opacity = "1";
        } else {
            this.dom.del.style.opacity = "0.7";
        }
    }.$bind(object);

    function setEvents(o) {
        o.ontouchstart = touchStart;
        o.ontouchend = touchEnd;
        o.ontouchcancel = touchEnd;
        if (!$ui.isMobileDevice()) {
            o.onmousedown = touchStart;
            o.onmouseup = touchEnd;
            o.onmouseleave = touchEnd;
        }
    }

    object._private = {};
    object._private.number = "";
    object._private.prettyNumber = "";

    object.dom.del = document.createElement("div");
    $ui.addClass(object.dom.del, 'delete');
    object.dom.appendChild(object.dom.del);

    object.dom.number = document.createElement("div");
    $ui.addClass(object.dom.number, 'number theme-highlight-text-color');
    object.dom.appendChild(object.dom.number);

    setEvents(object.dom.del);

    object.dom.del.onclick = function(event) {
        if (this.number.length != 0 && this.ondeleteclick) {
            this.ondeleteclick(event);
        }
    }.$bind(object);

    Object.defineProperty(object, "number", {
        get: function() {
            return this._private.number;
        }.$bind(object),
        set: function(number) {
            var length = number.length;
            if (length == 0) {
                this.dom.del.style.opacity = 0.7;
            } else {
                this.dom.del.style.opacity = 1;
            }
            this._private.prettyNumber = pretty(number);
            this.dom.number.textContent = this._private.prettyNumber;
            this._private.number = number;
            if (this._private.lastNumber != number) {
                this._private.lastNumber = number;
                if (this.onnumberchanged) {
                    this.onnumberchanged({ number: number, prettyNumber: this._private.prettyNumber });
                }
            }
        }.$bind(object)
    });

    Object.defineProperty(object, "prettyNumber", {
        get: function() {
            return this._private.prettyNumber;
        }
    });

    /**
     * Append a digit (or any string really) to the number.
     * @function appendToNumber
     * @memberof $ui.DialPadNumber#
     * @param {string} digit - The digit (or any string) to append.
     */
    object.appendToNumber = function(digit) {
        this.number = this._private.number + digit;
    }.$bind(object);

    /**
     * Delete the rightmost character from the number. Note that calling
     * delete from within 200ms of the last call will delete the whole number.
     * @function deleteFromNumber
     * @memberof $ui.DialPadNumber#
     */
    object.deleteFromNumber = function() {
        var now = new Date().getTime();
        if (this._private.lastDelete && now - this._private.lastDelete < 200) {
            this.number = "";
        } else {
            var current = this.number;
            if (current && current.length > 0) {
                this.number = current.substring(0, current.length - 1);
            }
        }
        this._private.lastDelete = now;
    }.$bind(object);

    return object.dom;
}
/**
 * The Map control represents the map window including both the chrome and the viewer.<br><br>
 * This object will create an iframe area while in demo mode. But when in PhoneGap it will create a child map view window that it will overlay on the screen<br><br>
 * <b>Sample Declaration</b><br>
 * <pre>
 * {
 *    component: $ui.Map,
 *    src: 'https://www.google.com/maps/embed?pb=!1m14!1m1'
 * }
 * @namespace Map
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {string} src - Populates the Google Maps URL for the control
 */
function $ui_Map(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom,'ui-map');
	
	// Check to see if we are in the emulator
	if ($system && (($system.config.isEmulator == true))) {
		object._protected.isIFrame = false;
	} else {
		object._protected.isIFrame = true;
	}
	
	// Create our map display area
	object.dom.mapDiv = document.createElement('div');
	$ui.addClass(object.dom.mapDiv,'mapDiv theme-screen-background-color');
	object.dom.appendChild(object.dom.mapDiv);
	
	// Create the contentWindow
	if (object._protected.isIFrame == true) {
		object.dom.contentWindow = document.createElement('iframe');
		$ui.addClass(object.dom.contentWindow, 'window');
	} else {
		object.dom.contentWindow = document.createElement('webview');
		$ui.addClass(object.dom.contentWindow, 'webview');
	}
	object.dom.mapDiv.appendChild(object.dom.contentWindow);
	
	// Handle loading on show
	object._onshow = function() {
		// Wait for show to load the URL
		if (this.src) {
			this.dom.contentWindow.src = this.src;
		}
		this.dom.contentWindow.style.display = 'block';
		// Hack for scaling webviews in a Chrome App.. Scaling issue
		if (this._protected.isIFrame == false) {
			this.dom.contentWindow.style.width = this.dom.mapDiv.offsetWidth + 'px';
			this.dom.contentWindow.style.height = (this.dom.mapDiv.offsetHeight + 7) + 'px'; // For some reason the calculation is off by 7
		}
	}.$bind(object);

	// Handle the sizing of the screen for the <webview>
	object._onresize = function() {
		// Hack for webviews in Chrome App... Scaling issue
		if (this._protected.isIFrame == false) {
			var webview = this.dom.contentWindow;
			webview.style.display = 'none';
			setTimeout(function() {webview.style.display = 'block';},500);
		}
	}.$bind(object);
	return object.dom;
}
/**
 * The Media Player control provides the user interface to the audio services of Brainiac. This control will fill the entire available space provided by its parent containing control.<br><br>
 * <b>Sample Declaration</b><br>
 * <pre>
 * {
 *    component: $ui.MediaPlayer,
 *    album: 'License To Ill',
 *    song: 'So What Cha Want',
 *    artist: 'Beastie Boys',
 *    coverArt: 'img/foo.png',
 *    duration: 217,
 *    onplay: function() {
 *       // Do something
 *    }
 * }
 * @namespace MediaPlayer
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {string} [album] - The name of the album of the current playing/paused song
 * @property {string} [song] - The name of the current playing/paused song
 * @property {string} [artist] - The name of the artist for the current playing/paused song
 * @property {string} [coverArt] - Path to the cover/album art for the current playing/paused song
 * @property {number} [duration] - The duration of the current playing/paused song in <b>seconds</b>
 * @property {boolean} [paused=false] - Optional property specifying if the player is paused or not
 * @property {GenericEvent} [onplay] - This event will fire when the user presses play
 * @property {GenericEvent} [onpause] - This event will fire when the user presses pause
 * @property {GenericEvent} [onmenuclick] - This event will fire when the user presses the menu
 * @property {GenericEvent} [onskipforward] - This event will fire when the user presses next
 * @property {GenericEvent} [onskipback] - This event will fire when the user presses previous
 */
function $ui_MediaPlayer(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom,'ui-media-player');
	
	if ($ui.theme.inHeadUnit == true) {
		$ui.addClass(object.dom,'in-head-unit');
	}
	
	// Set our initial play state
	if (object.paused == undefined) {
		object.paused = false;
	}
	
	// Create our cover art display area
	object.dom.coverArt = document.createElement('div');
	$ui.addClass(object.dom.coverArt,'cover-art');
	object.dom.appendChild(object.dom.coverArt);
	object.dom.coverArt.loader = new Image();
	object.dom.coverArt.loader.model = object;
	object.dom.coverArt.loader.onload = function() {
		this.model.dom.coverArt.style.backgroundImage = 'url("'+this.model.coverArt+'")';
		this.model.dom.coverArt.style.opacity = '0.3';
	}
	
	// Create our controls area
	object.dom.controls = document.createElement('div');
	$ui.addClass(object.dom.controls, 'controls theme-text-color');
	object.dom.appendChild(object.dom.controls);
	object.dom.artist = document.createElement('div');
	$ui.addClass(object.dom.artist,'artist');
	object.dom.controls.appendChild(object.dom.artist);
	object.dom.song = document.createElement('div');
	$ui.addClass(object.dom.song,'song');
	object.dom.controls.appendChild(object.dom.song);
	object.dom.album = document.createElement('div');
	$ui.addClass(object.dom.album,'album');
	object.dom.controls.appendChild(object.dom.album);
	
	// Create our player buttons
	object.dom.playbox = document.createElement('div');
	$ui.addClass(object.dom.playbox, 'playbox');
	object.dom.controls.appendChild(object.dom.playbox);
	object.dom.skipBack = document.createElement('div');
	object.dom.skipBack.model = object;
	$ui.addClass(object.dom.skipBack,'button');
	$ui.addClass(object.dom.skipBack,'skip-back');
	object.dom.playbox.appendChild(object.dom.skipBack);
	object.dom.skipForward = document.createElement('div');
	object.dom.skipForward.model = object;
	$ui.addClass(object.dom.skipForward,'button');
	$ui.addClass(object.dom.skipForward,'skip-forward');
	object.dom.playbox.appendChild(object.dom.skipForward);
	object.dom.play = document.createElement('div');
	object.dom.play.model = object;
	$ui.addClass(object.dom.play,'button');
	$ui.addClass(object.dom.play,'play');
	object.dom.playbox.appendChild(object.dom.play);
	object.dom.play.onclick = function() {
		$ui.playTouchSound();
		if (this.model.paused == true) {
			this.model.play();
		} else {
			this.model.pause();
		}
	}
	object.dom.play.ontouchstart = function() {
		this.style.opacity = '0.7';
	}
	object.dom.play.ontouchend = function() {
		this.style.opacity = '1.0';
	}
	object.dom.play.ontouchcancel = object.dom.ontouchend;

	object.dom.skipBack.ontouchstart = object.dom.play.ontouchstart;
	object.dom.skipBack.ontouchend = object.dom.play.ontouchend;
	object.dom.skipBack.ontouchcancel = object.dom.play.ontouchend;
	object.dom.skipBack.onclick = function() {
		$ui.playTouchSound();
		this.model.skipBack();
	}

	object.dom.skipForward.ontouchstart = object.dom.play.ontouchstart;
	object.dom.skipForward.ontouchend = object.dom.play.ontouchend;
	object.dom.skipForward.ontouchcancel = object.dom.play.ontouchend;
	object.dom.skipForward.onclick = function() {
		$ui.playTouchSound();
		this.model.skipForward();
	}
	
	if (!$ui.isMobileDevice()) {
		object.dom.play.onmousedown = object.dom.play.ontouchstart;
		object.dom.play.onmouseup = object.dom.play.ontouchend;
		object.dom.play.onmouseleave = object.dom.play.ontouchend;
	}
	
	// Create our menu
	object.dom.menu = document.createElement('div');
	object.dom.menu.model = object;
	$ui.addClass(object.dom.menu,'menu theme-border-color');
	object.dom.appendChild(object.dom.menu);
	object.dom.menu.onclick = function() {
		$ui.playTouchSound();
		if (this.model.onmenuclick) {
			this.model.onmenuclick();
		}
	}
	object.dom.menu.ontouchstart = function() {
		$ui.addClass(this, 'theme-brand-background-color');
	}
	object.dom.menu.ontouchend = function() {
		$ui.removeClass(this, 'theme-brand-background-color');
	}
	object.dom.menu.ontouchcancel = object.dom.ontouchend;
	if (!$ui.isMobileDevice()) {
		object.dom.menu.onmousedown = object.dom.menu.ontouchstart;
		object.dom.menu.onmouseup = object.dom.menu.ontouchend;
		object.dom.menu.onmouseleave = object.dom.menu.ontouchend;
	}
	
	// Create our text buttons
	object.dom.textButtonBox = document.createElement('div');
	$ui.addClass(object.dom.textButtonBox, 'textButtonBox');
	object.dom.appendChild(object.dom.textButtonBox);
	object.dom.buttonRepeat = document.createElement('div');
	object.dom.buttonRepeat.model = object;
	$ui.addClass(object.dom.buttonRepeat, 'text-button theme-text-color');
	$ui.addClass(object.dom.buttonRepeat, 'left');
	object.dom.buttonRepeat.textContent = 'Repeat Off';
	object.dom.textButtonBox.appendChild(object.dom.buttonRepeat);
	object.dom.buttonSource = document.createElement('div');
	$ui.addClass(object.dom.buttonSource, 'text-button theme-text-color');
	$ui.addClass(object.dom.buttonSource, 'center');
	object.dom.buttonSource.textContent = 'Source';
	object.dom.textButtonBox.appendChild(object.dom.buttonSource);
	object.dom.buttonShuffle = document.createElement('div');
	object.dom.buttonShuffle.model = object;
	$ui.addClass(object.dom.buttonShuffle, 'text-button theme-text-color');
	$ui.addClass(object.dom.buttonShuffle, 'right');
	object.dom.buttonShuffle.textContent = 'Shuffle Off';
	object.dom.textButtonBox.appendChild(object.dom.buttonShuffle);
	
	object.dom.buttonShuffle.ontouchstart = object.dom.play.ontouchstart;
	object.dom.buttonShuffle.ontouchend = object.dom.play.ontouchend;
	object.dom.buttonShuffle.ontouchcancel = object.dom.play.ontouchcancel;
	object.dom.buttonShuffle.onclick = function() {
		$ui.playTouchSound();
		this.model.toggleShuffle();
	};
	
	object.dom.buttonRepeat.ontouchstart = object.dom.play.ontouchstart;
	object.dom.buttonRepeat.ontouchend = object.dom.play.ontouchend;
	object.dom.buttonRepeat.ontouchcancel = object.dom.play.ontouchcancel;
	object.dom.buttonRepeat.onclick = function() {
		$ui.playTouchSound();
		this.model.toggleRepeat();
	};

	/**
	 * Sets the <b>repeat</b> property of the control.
	 */
	object.setRepeat = function(repeat) {
		if (repeat==0) {
			this.dom.buttonRepeat.textContent = 'Repeat Off';
		} else if (repeat == 1) {
			this.dom.buttonRepeat.textContent = 'Repeat One';
		} else if (repeat == 2) {
			this.dom.buttonRepeat.textContent = 'Repeat All';
		}
	}.$bind(object);
	
	/**
	 * Sets the shuffle property of the control.
	 */
	object.setShuffle = function(shuffle) {
		this.dom.buttonShuffle.textContent = shuffle ? "Shuffle On" : "Shuffle Off";
	}.$bind(object);
	
	/**
	* Sets the <b>album</b> property of the control
	* @function setAlbum
	* @memberof $ui.MediaPlayer
	* @param {string} value - The new property value
	*/
	object.setAlbum = function(value) {
		this.album = value;
		// Now load the new image
		if (value != undefined) {
			this.dom.album.textContent = value;
		} else {
			this.dom.album.textContent = '';
		}
	}.$bind(object);
	
	/**
	* Sets the <b>song</b> property of the control
	* @function setSong
	* @memberof $ui.MediaPlayer
	* @param {string} value - The new property value
	*/
	object.setSong = function(value) {
		this.song = value;
		// Now load the new image
		if (value != undefined) {
			this.dom.song.textContent = value;
		} else {
			this.dom.song.textContent = '';
		}
	}.$bind(object);
	
	/**
	* Sets the <b>artist</b> property of the control
	* @function setArtist
	* @memberof $ui.MediaPlayer
	* @param {string} value - The new property value
	*/
	object.setArtist = function(value) {
		this.artist = value;
		// Now load the new image
		if (value != undefined) {
			this.dom.artist.textContent = value;
		} else {
			this.dom.artist.textContent = '';
		}
	}.$bind(object);
	
	/**
	* Sets the <b>coverArt</b> property of the control
	* @function setCoverArt
	* @memberof $ui.MediaPlayer
	* @param {string} value - The new property value
	*/
	object.setCoverArt = function(value) {
		this.coverArt = value;
		this.dom.coverArt.style.opacity = '0';
		// Now load the new image
		if (value != undefined) {
			this.dom.coverArt.loader.src = value;
		}
	}.$bind(object);
	
	/**
	* Sets the <b>duration</b> property of the control
	* @function setDuration
	* @memberof $ui.MediaPlayer
	* @param {number} value - The new property value
	*/
	object.setDuration = function(value) {
		this.duration = value;
		// Now load the new image
		if (value != undefined) {
			// Do something
		}
	}.$bind(object);
	
	// Private function to render the play state of the control
	object._renderPlayState = function(value) {
		if (this.paused == true) {
			$ui.removeClass(this.dom.play,'pause');
		} else {
			$ui.addClass(this.dom.play,'pause');
		}
	}.$bind(object);
	
	/**
	* Play the current song
	* @function play
	* @memberof $ui.MediaPlayer
	*/
	object.play = function(value) {
		if (this.paused == false) return;
		this.paused = false;
		this._renderPlayState();
		if (this.onplay) {
			this.onplay();
		}
	}.$bind(object);

	/**
	 * Attempt to skip back.
	 */
	object.skipBack = function() {
		if (this.onskipback) {
			this.onskipback();
		}
	}.$bind(object);
	
	object.setPaused = function(val) {
		if (this.paused == val) {
			return;
		}
		this.paused = val;
		this._renderPlayState();
		
	}.$bind(object);

	/**
	 * User wants to skip forward.
	 */
	object.skipForward = function() {
		if (this.onskipforward) {
			this.onskipforward();
		}
	}.$bind(object);
	
	object.toggleRepeat = function() {
		if (this.ontogglerepeat) {
			this.ontogglerepeat();
		}
	}.$bind(object);
	
	object.toggleShuffle = function() {
		if (this.ontoggleshuffle) {
			this.ontoggleshuffle();
		}
	}.$bind(object);
	
	/**
	* Pause the current song
	* @function pause
	* @memberof $ui.MediaPlayer
	*/
	object.pause = function(value) {
		if (this.paused == true) return;
		this.paused = true;
		this._renderPlayState();
		if (this.onpause) {
			this.onpause();
		}
	}.$bind(object);
	
	// Private function to handle provider updates
	object._providerUpdate = function(value) {
		if (value == undefined) {
			value = {}
		} 
		this.setCoverArt(value.coverArt);
		this.setArtist(value.artist);
		this.setSong(value.song);
		this.setAlbum(value.album);
		this.paused = value.paused;
		this._renderPlayState();
	}.$bind(object);
	
	// Load our control if no provider is connected
	if (object.provider == undefined) {
		object._providerUpdate(object)
	}
	
	return object.dom;
}

/**
 * The MenuItem control represents a menu option in a menu for a {@link $ui.OnlineScreen}.  It can only be used in a menu and cannot be instantiated on its own.
 * @namespace
 * @name MenuItem
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {string} caption - The Caption to display on this menu item
 * @property {boolean} [selected=false] - Set to <b>true</b> to make this menu item the selected item in the menu.  Only one menu item can be selected at once.  When a menu renders it will select the first menu item that has selected set to true and ignore the rest.
 * @property {GenericEvent} [onclick] - Event that will fire when the user clicks the menu item
 */
function $ui_MenuItem(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	if (object.inMenu != true) {
		console.log('ERROR: A "MenuItem" can only be created as part of a menu in an "OnlineScreen"');
		return;
	}
	$ui.addClass(object.dom,'ui-menu-item');
	
	// Selected property
	if (object.selected == true) {
		$ui.addClass(object.dom,'selected');
	} else {
		object.selected = false;
	}
	object._protected.selected = object.selected;
	Object.defineProperty(object, 'selected', {
		get: function() {return this._protected.selected;},
		set: function(value) {
			if (value == this._protected.selected) return;
			this._protected.selected = value;
			if (value == true) {
				$ui.addClass(object.dom,'selected');
			} else {
				$ui.removeClass(object.dom,'selected');
			}
		},
		configurable: false}
	);
	
	// Caption Property
	if (object.caption) {
		object.dom.textContent = object.caption;
	}
	object._protected.caption = object.caption;
	Object.defineProperty(object, 'caption', {
		get: function() {return this._protected.caption;},
		set: function(value) {
			if (value == this._protected.caption) return;
			this._protected.caption = value;
			this.dom.textContent = value;
		},
		configurable: false}
	);
	
	// Handle the click
	object._doClick = function() {
		if (this.selected == true) return;
		this.selected = true;
		// Un-select the other items
		var i,
			item,
			menu = this.parent.menu;
		for (i = 0; i < menu.length; i++) {
			item = menu[i];
			if (item != this) {
				item.selected = false;
			}
		}
		// Fire our onclick
		if (this.onclick) {
			this.onclick();
		}
	}.$bind(object);
	
	if ($ui.isMobileDevice()) {
		object.dom.ontouchend = object._doClick;
	} else {
		object.dom.onclick = object._doClick;
	}

	
	// Add our mouse handling
	object.dom.onmouseenter = function() {
		this.style.color = '#D94646'; // Hardcoded for our website
	}
	object.dom.onmouseleave = function() {
		this.style.color = '';
	}
	
	return object.dom;
}
/**
 * The OnlineScreen represents a screen that will be hosted on the web site providing both desktop and mobile viewing
 * @namespace OnlineScreen
 * @memberof $ui
 * @extends $ui.CoreScreen
 * @property {$ui.MenuItem[]} [menu] - Optional list of menu items to appear in the screen
 * @property {$ui.CoreComponent[]} [content] - Content to display in the screen
 * @property {GenericEvent} [onlogoclick] - Event that fires when a user clicks the titlebar logo
 */
function $ui_OnlineScreen(object, data) {
	$ui_CoreScreen.call(this, object, data);
	if (object) {
		$ui.addClass(object.dom,'ui-online-screen');

		object._protected.expanded = false;

		// Create our title bar
		object.dom.titleBar = document.createElement('div');
		$ui.addClass(object.dom.titleBar, 'title-bar');
		object.dom.appendChild(object.dom.titleBar);
		
		// Create our menu 
		object.dom.menu = document.createElement('div');
		$ui.addClass(object.dom.menu, 'menu');
		object.dom.titleBar.appendChild(object.dom.menu);
		
		// create our logo click area
		object.dom.logoTarget = document.createElement('div');
		object.dom.logoTarget.model = object;
		$ui.addClass(object.dom.logoTarget, 'logo-target');
		object.dom.menu.appendChild(object.dom.logoTarget);
		object.dom.logoTarget.onclick = function() {
			if (this.model.onlogoclick) {
				this.model.onlogoclick();
			}
		};
		
		// Create our inner menu 
		object.dom.innerMenu = document.createElement('div');
		$ui.addClass(object.dom.innerMenu, 'inner');
		object.dom.menu.appendChild(object.dom.innerMenu);
		
		// Create the hamburger
		object.dom.hamburger = document.createElement('div');
		object.dom.hamburger.model = object;
		$ui.addClass(object.dom.hamburger, 'hamburger');
		object.dom.menu.appendChild(object.dom.hamburger);
		
		// Opens up the hamburger menu
		object._openHamburger = function(event) {
			if (this._protected.expanded == true) return;
			this._protected.expanded = true;
			this.dom.innerMenu.style.display = 'block';
			event.stopPropagation();
			if ($ui.isMobileDevice()) {
				document.addEventListener('touchend',this._cancelOpen);
			} else {
				document.addEventListener('click',this._cancelOpen);
			}
		}.$bind(object);
		
		if ($ui.isMobileDevice()) {
			object.dom.hamburger.ontouchend = object._openHamburger;
		} else {
			object.dom.hamburger.onclick = object._openHamburger;
		}
		
		// Create the login/logout button
		object.dom.login = document.createElement('div');
		$ui.addClass(object.dom.login, 'login');
		object.dom.menu.appendChild(object.dom.login);
		object.dom.login.textContent = 'Log in / Setup';
		object.dom.login.style.backgroundColor = $ui.theme.color;
		
		// Create our content div for the controls
		object.dom.contentDiv = document.createElement('div');
		$ui.addClass(object.dom.contentDiv, 'inner');
		object.dom.appendChild(object.dom.contentDiv);
		
		// Title Bar property
		object._protected.titleBar = object.titleBar;
		Object.defineProperty(object, 'titleBar', {
			get: function() {return this._protected.titleBar;},
			set: function() {
				console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','titleBar'));
			},
			configurable: false}
		);
		
		// Menu property
		if (object.menu == undefined) {
			object.menu = [];
		}
		object._protected.menu = object.menu;
		Object.defineProperty(object, 'menu', {
			get: function() {return this._protected.menu;},
			set: function() {
				console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','menu'));
			},
			configurable: false}
		);
		
		// Content property
		if (object.content == undefined) {
			object.content = [];
		}
		object._protected.content = object.content;
		Object.defineProperty(object, 'content', {
			get: function() {return this._protected.content;},
			set: function() {
				console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','content'));
			},
			configurable: false}
		);
		
		// Cycle through menu
		if (object.menu) {
			var i,
				control,
				controlDom,
				selectedFound = false;
			for (i = 0; i < object.menu.length; i++) {
				control = object.menu[i];
				if (control.component != $ui.MenuItem) continue;
				control.inMenu = true;
				control.parent = object;
				if (control.selected == true) {
					if (selectedFound == true) {
						control.selected = false;
					} else {
						selectedFound = true;
					}
				}
				controlDom = $ui.createControl(control, object);
				if (controlDom) {
					object.dom.innerMenu.appendChild(controlDom);
				}
			}
		}
		
		// Cycle through content
		if (object.content) {
			var i,
				control,
				controlDom;
			for (i = 0; i < object.content.length; i++) {
				control = object.content[i];
				controlDom = $ui.createControl(control, object);
				if (controlDom) {
					object.dom.contentDiv.appendChild(controlDom);
				}
			}
		}
		
		// This will cancel the open of the hamburger menu
		object._cancelOpen = function() {
			this.dom.innerMenu.style.display = 'none';
			this._protected.expanded = false;
			if ($ui.isMobileDevice()) {
				document.removeEventListener('touchend',this._cancelOpen);
			} else {
				document.removeEventListener('click',this._cancelOpen);
			}
		}.$bind(object);
		
		return object.dom;
	}
}
/**
 * The phone log list item type is used with the {@link $ui.List} component and represents a call log entry. 
 * <br><br><b>Sample Declaration</b>
 * <pre>
 * {
 *   title: 'Susan',
 *   caption: '(555) 897-9876',
 *   style: $ui.PhoneLogListItem.PhoneLogStyle.MISSED
 * }
 * </pre>
 * @namespace PhoneLogListItem
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {string} title - Represents the main title to display
 * @property {$ui.PhoneLogListItem.PhoneLogStyle} [style] - The type of call that is in the list
 * @property {string} [caption] - Represents the main text to show in the list item
 */
function $ui_PhoneLogListItem(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom, 'ui-phone-log-list-item theme-screen-background-color theme-text-color theme-dark-border-color');
	if ($ui.theme.inHeadUnit == true) {
		$ui.addClass(object.dom, 'in-head-unit');
	}
	// See if the style is defined
	if (object.style == undefined) {
		object.style = $ui.PhoneLogListItem.INCOMING;
	}
	$ui.addClass(object.dom, object.style);
	
	// Details section
	object.dom.details = document.createElement('div');
	$ui.addClass(object.dom.details,'details');
	object.dom.appendChild(object.dom.details);
	
	// Title
	object.dom.titleArea = document.createElement('div');
	$ui.addClass(object.dom.titleArea,'title');
	object.dom.titleArea.textContent = object.title;
	object.dom.details.appendChild(object.dom.titleArea);
	if (object.style === $ui.PhoneLogListItem.MISSED) {
		$ui.addClass(object.dom.titleArea, 'theme-brand-text-color');
	}

	// Caption
	object.dom.captionDiv = document.createElement('div');
	$ui.addClass(object.dom.captionDiv,'caption theme-brand-text-color');
	object.dom.details.appendChild(object.dom.captionDiv);
	if (object.caption) {
		object.dom.captionDiv.textContent = object.caption;
	} else {
		$ui.addClass(object.dom, 'no-caption');
	}
	
	// Handle our touch events
	object.dom.ontouchstart = function() {
		$ui.removeClass(this, 'theme-screen-background-color');
		$ui.addClass(this, 'theme-brand-background-color');
	}
	object.dom.ontouchend = function() {
		$ui.removeClass(this, 'theme-brand-background-color');
		$ui.addClass(this, 'theme-screen-background-color');
	}
	object.dom.ontouchcancel = object.dom.ontouchend;
	if (!$ui.isMobileDevice()) {
		object.dom.onmousedown = object.dom.ontouchstart;
		object.dom.onmouseup = object.dom.ontouchend;
		object.dom.onmouseleave = object.dom.ontouchend;
	}

	// Pass the onclick back to the list
	object.dom.addEventListener('click', function() {
		if (this.model.parent.onaction == undefined) return;
		var event = new $ui_ListEvent(this.model, $ui.PhoneLogListItem.PhoneLogListEvent.ONCLICK);
		this.model.parent._onaction(this.model, event);
	},false);

	return object.dom;
}
/**
 * The PostListItem is used with {@link $ui.List} component and represents a post on a timeline.
 * <br><br><b>Sample Declaration</b>
 * <pre>
 * {
 *   user: 'brcewane',
 *   avatar: '../img/avatar.png',
 *   img: '../img/postImage.png',
 *   caption: 'This is a cool post',
 *   title: 'My Post',
 *   numLikes: 112,
 *   numComments: 12,
 *   liked: false,
 *   time: 'Thur Jan 17 2013 08:36:53 GMT-0500'
 * }
 * </pre>
 * @namespace PostListItem
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {string} user - The username who made the post
 * @property {string} [avatar] - The avatar to show for the user
 * @property {string} img - The image to view in the post
 * @property {string} [caption] - Represents the main text for the post
 * @property {string} [title] - The optional title for the post
 * @property {number} [numLikes=0] - The number of likes this post has recieved
 * @property {number} [numComments=0] - The number of comments this post has received
 * @property {boolean} [like=false] - Whether or not you have liked this post
 * @property {Date} [time] - The time that this post was made.  Must be a valid string representing a Date Time
 */
function $ui_PostListItem(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom, 'ui-post-list-item theme-post-control');
	
	// User details
	object.dom.user = document.createElement('div');
	$ui.addClass(object.dom.user, 'user-details');
	object.dom.appendChild(object.dom.user);
	
	// User name
	object.dom.userName = document.createElement('div');
	$ui.addClass(object.dom.userName, 'caption');
	object.dom.user.appendChild(object.dom.userName);
	
	// Avatar image
	object.dom.avatar = document.createElement('div');
	$ui.addClass(object.dom.avatar, 'avatar');
	object.dom.user.appendChild(object.dom.avatar);
	
	// Post Time
	object.dom.postTime = document.createElement('div');
	$ui.addClass(object.dom.postTime, 'time');
	object.dom.user.appendChild(object.dom.postTime);
	
	// Picture area
	object.dom.picture = document.createElement('img');
	$ui.addClass(object.dom.picture, 'picture');
	object.dom.appendChild(object.dom.picture);
	object.dom.picture.onload = function() {
		this.style.opacity = 1;
	}
	
	// Title area
	object.dom.titleDiv = document.createElement('div');
	$ui.addClass(object.dom.titleDiv, 'title');
	object.dom.appendChild(object.dom.titleDiv);
	
	// Main content area
	object.dom.contentDiv = document.createElement('div');
	$ui.addClass(object.dom.titleDiv, 'content');
	object.dom.appendChild(object.dom.contentDiv);
	
	// Add our separator
	object.dom.line = document.createElement('div');
	$ui.addClass(object.dom.line, 'line theme-brand-background-color');
	object.dom.appendChild(object.dom.line);
	
	// Add our buttons
	object.dom.buttons = document.createElement('div');
	$ui.addClass(object.dom.buttons, 'buttons');
	object.dom.appendChild(object.dom.buttons);
	
	// Like button
	object.dom.like = document.createElement('div');
	$ui.addClass(object.dom.like, 'button like');
	object.dom.buttons.appendChild(object.dom.like);

	// Comment button
	object.dom.comment = document.createElement('div');
	$ui.addClass(object.dom.comment, 'button comment');
	object.dom.buttons.appendChild(object.dom.comment);


	// img Property
	if (object.img != undefined) {
		object.dom.picture.src = object.img;
	}
	object._protected.img = object.img;
	Object.defineProperty(object, 'img', {
		get: function() {return this._protected.img;},
		set: function(value) {
			if (value == this._protected.img) return;
			this.dom.picture.style.opacity = 0;
			if (value != undefined) {
				this.dom.picture.src = value;
			} 
			this._protected.img = value;
		},
		configurable: false}
	);
	
	// avatar Property
	if (object.avatar != undefined) {
		object.dom.avatar.style.backgroundImage = 'url("'+ object.avatar + '")';
	}
	object._protected.avatar = object.avatar;
	Object.defineProperty(object, 'avatar', {
		get: function() {return this._protected.avatar;},
		set: function(value) {
			if (value == this._protected.avatar) return;
			if (value == undefined) {
				this.dom.avatar.style.backgroundImage = '';
			} else {
				this.dom.avatar.style.backgroundImage = 'url("'+ value + '")';
			}
			this._protected.avatar = value;
		},
		configurable: false}
	);
	
	// time Property
	if (object.time != undefined) {
		object.dom.postTime.textContent = $ui.calculateTimeInPast(new Date(), object.time);
	}
	object._protected.time = object.time;
	Object.defineProperty(object, 'time', {
		get: function() {return this._protected.time;},
		set: function(value) {
			if (value == this._protected.time) return;
			if (value == undefined) {
				this.dom.postTime.textContent = '?';
			} else {
				this.dom.postTime.textContent = $ui.calculateTimeInPast(new Date(), value);
			}
			this._protected.user = value;
		},
		configurable: false}
	);
	
	// user Property
	if (object.user != undefined) {
		object.dom.userName.textContent = object.user;
	}
	object._protected.user = object.user;
	Object.defineProperty(object, 'user', {
		get: function() {return this._protected.user;},
		set: function(value) {
			if (value == this._protected.user) return;
			if (value == undefined) {
				this.dom.userName.textContent = '';
			} else {
				this.dom.userName.textContent = value;
			}
			this._protected.user = value;
		},
		configurable: false}
	);
	
	// numLikes Property
	if (object.numLikes != undefined) {
		object.dom.like.textContent = object.numLikes;
	}
	object._protected.numLikes = object.numLikes;
	Object.defineProperty(object, 'numLikes', {
		get: function() {return this._protected.numLikes;},
		set: function(value) {
			if (value == this._protected.numLikes) return;
			if (value == undefined) {
				this.dom.like.textContent = '';
			} else {
				this.dom.like.textContent = value;
			}
			this._protected.numLikes = value;
		},
		configurable: false}
	);
	
	// numComments Property
	if (object.numLikes != undefined) {
		object.dom.comment.textContent = object.numComments;
	}
	object._protected.numComments = object.numComments;
	Object.defineProperty(object, 'numComments', {
		get: function() {return this._protected.numComments;},
		set: function(value) {
			if (value == this._protected.numComments) return;
			if (value == undefined) {
				this.dom.comment.textContent = '';
			} else {
				this.dom.comment.textContent = value;
			}
			this._protected.numComments = value;
		},
		configurable: false}
	);

	// title Property
	if (object.title != undefined) {
		object.dom.titleDiv.style.display = 'block';
		object.dom.titleDiv.textContent = object.title;
	}
	object._protected.title = object.title;
	Object.defineProperty(object, 'title', {
		get: function() {return this._protected.title;},
		set: function(value) {
			if (value == this._protected.title) return;
			this._protected.title = value;
			if (value == undefined || value == '') {
				this.dom.titleDiv.style.display = 'none';
			} else {
				this.dom.titleDiv.style.display = 'block';
				this.dom.titleDiv.textContent = value;
			}
		},
		configurable: false}
	);

	// caption Property
	if (object.caption != undefined) {
		object.dom.contentDiv.textContent = object.caption;
	}
	object._protected.caption = object.caption;
	Object.defineProperty(object, 'caption', {
		get: function() {return this._protected.caption;},
		set: function(value) {
			if (value == this._protected.caption) return;
			this._protected.caption = value;
			if (value == undefined || value == '') {
				this.dom.contentDiv.textContent = '';
			} else {
				this.dom.contentDiv.textContent = value;
			}
		},
		configurable: false}
	);
	return object.dom;
}
/**
 * The RawContent object represents an area where you can load in HTML from a source to be displayed <br><br>
 * <b>Sample Declaration</b><br>
 * <pre>
 * {
 *   component: $ui.RawContent,
 *    src: 'my/path/file.html'
 *}
 * @namespace RawContent
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {string} [src] - The path to the raw content you wish to load
*/
function $ui_RawContent(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom,'ui-raw-content');
	
	// Create our XHR
	object._protected.xhr = new XMLHttpRequest();
	object._protected.xhr.model = object;
	
	// Handle our state changes
	object._protected.xhr.onreadystatechange = function () {
		/* On readyState is 4, Determine if the request was successful or not. */
		if(this.readyState == 4) {
			if (this.status == 200) {
				this.model.dom.innerHTML = this.responseText;
			} else if(this.status != 0) {
				console.log('ERROR: XHR returned status code: ' + this.status);
			}
		}
	}
	// Src Property
	if (object.src) {
		object._protected.xhr.open('GET', object.src, true);
		object._protected.xhr.send();
	}
	object._protected.src = object.src;
	Object.defineProperty(object, 'src', {
		get: function() {return this._protected.src;},
		set: function(value) {
			if (value == this._protected.src) return;
			this._protected.src = value;
			this._protected.xhr.open('GET', value, true);
			this._protected.xhr.send();
		},
		configurable: false}
	);
	
	return object.dom;
}
/**
 * The ResponsiveLayout object represents a grouping of multiple different controls in a section that will size itself based on the screen in which it is displayed. <br><br>
 * <b>Sample Declaration</b><br>
 * <pre>
 * {
 *   component: $ui.ResponsiveLayout,
 *    id: 'myGrouping',
 *    content: [
 *       {
 *           component: $ui.Header,
 *           caption: 'My Header',
 *       },
 *       {
 *           component: $ui.List,
 *           style: $ui.GenericListItem
 *       }
 *    ]
 *}
 * @namespace ResponsiveLayout
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {$ui.CoreComponent[]} [content] - The content property is an array of control definitions to be displayed in the control
*/
function $ui_ResponsiveLayout(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom,'ui-responsive-layout');
	
	// Create our inner area that holds the content of the layout
	object.dom.inner = document.createElement('div');
	$ui.addClass(object.dom.inner,'inner');
	object.dom.appendChild(object.dom.inner);
	
	// Content property
	if (object.content == undefined) {
		object.content = [];
	}
	object._protected.content = object.content;
	Object.defineProperty(object, 'content', {
		get: function() {return this._protected.content;},
		set: function() {
			console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','content'));			
		},
		configurable: false}
	);
	if (object.content) {
		var i,
			item,
			itemDom;
		for (i = 0; i < object.content.length; i++) {
			item = object.content[i];
			itemDom = $ui.createControl(item, object.screen);
			if (itemDom) {
				object.dom.inner.appendChild(itemDom);
			}
		}
	}	
	
	return object.dom;
}
/**
 * The Suspension control represents an interface for adjusting the air suspension of the vehicle.
 * <br><br><b>Sample Declaration</b>
 * <pre>
 * {
 *    component: $ui.Suspension,
 *    leftFront: 20,
 *    rightFront: 21,
 *    leftRear: 30,
 *    rightRear: 30,
 *    tank: 112
 * }
 * </pre>
 * @namespace Suspension
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {number} [leftFront=0] - Current Pressure of the left front air spring
 * @property {number} [rightFront=0] - Current Pressure of the right front air spring
 * @property {number} [leftRear=0] - Current Pressure of the left rear air spring
 * @property {number} [rightRear=0] - Current Pressure of the right rear air spring
 * @property {number} [tank=0] - Current Pressure of the air suspension tank
 * @property {string} [img] - Image of vehicle to display
 * @property {GenericEvent} [onrightfrontclick] - User clicked the right front pressure setting
 * @property {GenericEvent} [onleftfrontclick] - User clicked the left front pressure setting
 * @property {GenericEvent} [onleftrearclick] - User clicked the left rear pressure setting
 * @property {GenericEvent} [onrightrearclick] - User clicked the right rear pressure setting
 */
function $ui_Suspension(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom,'ui-suspension theme-border-color');
	
	if ($ui.theme.inHeadUnit == true) {
		$ui.addClass(object.dom, 'in-head-unit');
	}

	// Tank area
	object.dom.tank = document.createElement('div');
	$ui.addClass(object.dom.tank,'tank theme-text-color');
	object.dom.appendChild(object.dom.tank);
	object.dom.tank.label = document.createElement('div');
	$ui.addClass(object.dom.tank.label, 'label');
	object.dom.tank.label.textContent = 'TANK';
	object.dom.tank.appendChild(object.dom.tank.label);
	object.dom.tank.pressure = document.createElement('div');
	$ui.addClass(object.dom.tank.pressure, 'pressure');
	object.dom.tank.appendChild(object.dom.tank.pressure);
	object.dom.tank.psiLabel = document.createElement('div');
	$ui.addClass(object.dom.tank.psiLabel, 'psi');
	object.dom.tank.psiLabel.textContent = 'PSI';
	object.dom.tank.appendChild(object.dom.tank.psiLabel);
	
	// Create our pinch grid top row
	object.dom.topLeftGrid = document.createElement('div');
	$ui.addClass(object.dom.topLeftGrid,'grid-cell theme-brand-border-color');
	object.dom.appendChild(object.dom.topLeftGrid);
	object.dom.topLeftGrid.style.left = '0px';
	object.dom.topLeftGrid.style.top = '0px';
	object.dom.topLeftGrid.style.borderRightStyle = 'dashed';
	object.dom.topLeftGrid.style.borderBottomStyle = 'dashed';
	
	// Left Front button
	object._protected.leftFrontButton = {
		parent: object,
		pressure: object.leftFront,
		onclick: function() {
			if (this.parent.onleftfrontclick) {
				this.parent.onleftfrontclick();
			}
		}
	};
	new $ui_PressureButton(object._protected.leftFrontButton, screen);
	object.dom.leftFront = object._protected.leftFrontButton.dom;
	$ui.addClass(object.dom.leftFront, 'top-left');
	object.dom.topLeftGrid.appendChild(object.dom.leftFront);
	
	object.dom.topMiddleGrid = document.createElement('div');
	$ui.addClass(object.dom.topMiddleGrid,'grid-cell theme-brand-border-color');
	object.dom.appendChild(object.dom.topMiddleGrid);
	object.dom.topMiddleGrid.style.left = '33.3%';
	object.dom.topMiddleGrid.style.top = '0px';
	object.dom.topMiddleGrid.style.borderBottomStyle = 'dashed';
	
	object.dom.topRightGrid = document.createElement('div');
	$ui.addClass(object.dom.topRightGrid,'grid-cell theme-brand-border-color');
	object.dom.appendChild(object.dom.topRightGrid);
	object.dom.topRightGrid.style.right = '0px';
	object.dom.topRightGrid.style.top = '0px';
	object.dom.topRightGrid.style.borderBottomStyle = 'dashed';
	object.dom.topRightGrid.style.borderLeftStyle = 'dashed';
	
	// Right Front button
	object._protected.rightFrontButton = {
		pressure: object.rightFront,
		parent: object,
		onclick: function() {
			if (this.parent.onrightfrontclick) {
				this.parent.onrightfrontclick();
			}
		}
	};
	new $ui_PressureButton(object._protected.rightFrontButton, screen);
	object.dom.rightFront = object._protected.rightFrontButton.dom;
	$ui.addClass(object.dom.rightFront, 'top-right');
	object.dom.topRightGrid.appendChild(object.dom.rightFront);
	
	// Create our pinch grid middle row
	object.dom.middleLeftGrid = document.createElement('div');
	$ui.addClass(object.dom.middleLeftGrid,'grid-cell theme-brand-border-color');
	object.dom.appendChild(object.dom.middleLeftGrid);
	object.dom.middleLeftGrid.style.left = '0px';
	object.dom.middleLeftGrid.style.top = '33.3%';
	object.dom.middleLeftGrid.style.borderRightStyle = 'dashed';
	object.dom.middleLeftGrid.style.borderBottomStyle = 'dashed';
	
	object.dom.middleMiddleGrid = document.createElement('div');
	$ui.addClass(object.dom.middleMiddleGrid,'grid-cell theme-brand-border-color');
	object.dom.appendChild(object.dom.middleMiddleGrid);
	object.dom.middleMiddleGrid.style.left = '33.3%';
	object.dom.middleMiddleGrid.style.top = '33.3%';
	object.dom.middleMiddleGrid.style.borderBottomStyle = 'dashed';
	
	object.dom.middleRightGrid = document.createElement('div');
	$ui.addClass(object.dom.middleRightGrid,'grid-cell theme-brand-border-color');
	object.dom.appendChild(object.dom.middleRightGrid);
	object.dom.middleRightGrid.style.right = '0px';
	object.dom.middleRightGrid.style.top = '33.3%';
	object.dom.middleRightGrid.style.borderBottomStyle = 'dashed';
	object.dom.middleRightGrid.style.borderLeftStyle = 'dashed';
	
	// Create our pinch grid bottom row
	object.dom.bottomLeftGrid = document.createElement('div');
	$ui.addClass(object.dom.bottomLeftGrid,'grid-cell theme-brand-border-color');
	object.dom.appendChild(object.dom.bottomLeftGrid);
	object.dom.bottomLeftGrid.style.left = '0px';
	object.dom.bottomLeftGrid.style.bottom = '0px';
	object.dom.bottomLeftGrid.style.borderRightStyle = 'dashed';
	
	// Left Rear button
	object._protected.leftRearButton = {
		pressure: object.leftRear,
		parent: object,
		onclick: function() {
			if (this.parent.onleftrearclick) {
				this.parent.onleftrearclick();
			}
		}
	};
	new $ui_PressureButton(object._protected.leftRearButton, screen);
	object.dom.leftRear = object._protected.leftRearButton.dom;
	$ui.addClass(object.dom.leftRear, 'bottom-left');
	object.dom.bottomLeftGrid.appendChild(object.dom.leftRear);
	
	object.dom.bottomMiddleGrid = document.createElement('div');
	$ui.addClass(object.dom.bottomMiddleGrid,'grid-cell theme-brand-border-color');
	object.dom.appendChild(object.dom.bottomMiddleGrid);
	object.dom.bottomMiddleGrid.style.left = '33.3%';
	object.dom.bottomMiddleGrid.style.bottom = '0px';
	
	object.dom.bottomRightGrid = document.createElement('div');
	$ui.addClass(object.dom.bottomRightGrid,'grid-cell theme-brand-border-color');
	object.dom.appendChild(object.dom.bottomRightGrid);
	object.dom.bottomRightGrid.style.right = '0px';
	object.dom.bottomRightGrid.style.bottom = '0px';
	object.dom.bottomRightGrid.style.borderLeftStyle = 'dashed';
	
	// Right Rear button
	object._protected.rightRearButton = {
		pressure: object.rightRear,
		parent: object,
		onclick: function() {
			if (this.parent.onrightrearclick) {
				this.parent.onrightrearclick();
			}
		}
	};
	new $ui_PressureButton(object._protected.rightRearButton, screen);
	object.dom.rightRear = object._protected.rightRearButton.dom;
	$ui.addClass(object.dom.rightRear, 'bottom-right');
	object.dom.bottomRightGrid.appendChild(object.dom.rightRear);
	
	// leftFront Property
	if (object.leftFront == undefined) {
		object.leftFront = 0;
	}
	object._protected.leftFront = object.leftFront;
	Object.defineProperty(object, 'leftFront', {
		get: function() {return this._protected.leftFront;},
		set: function(value) {
			if (value == undefined) value = 0;
			if (value == this._protected.leftFront) return;
			this._protected.leftFront = value;
			this._protected.leftFrontButton.pressure = value;
		},
		configurable: false}
	);
	
	// rightFront Property
	if (object.rightFront == undefined) {
		object.rightFront = 0;
	}
	object._protected.rightFront = object.rightFront;
	Object.defineProperty(object, 'rightFront', {
		get: function() {return this._protected.rightFront;},
		set: function(value) {
			if (value == undefined) value = 0;
			if (value == this._protected.rightFront) return;
			this._protected.rightFront = value;
			this._protected.rightFrontButton.pressure = value;
		},
		configurable: false}
	);
	
	// rightRear Property
	if (object.rightRear == undefined) {
		object.rightRear = 0;
	}
	object._protected.rightRear = object.rightRear;
	Object.defineProperty(object, 'rightRear', {
		get: function() {return this._protected.rightRear;},
		set: function(value) {
			if (value == undefined) value = 0;
			if (value == this._protected.rightRear) return;
			this._protected.rightRear = value;
			this._protected.rightRearButton.pressure = value;
		},
		configurable: false}
	);
	
	// leftRear Property
	if (object.leftRear == undefined) {
		object.leftRear = 0;
	}
	object._protected.leftRear = object.leftRear;
	Object.defineProperty(object, 'leftRear', {
		get: function() {return this._protected.leftRear;},
		set: function(value) {
			if (value == undefined) value = 0;
			if (value == this._protected.leftRear) return;
			this._protected.leftRear = value;
			this._protected.leftRearButton.pressure = value;
		},
		configurable: false}
	);
	
	// img Property
	if (object.img != undefined) {
		object.dom.style.backgroundImage = 'url("'+object.img+'")';
	}
	object._protected.img = object.img;
	Object.defineProperty(object, 'img', {
		get: function() {return this._protected.img;},
		set: function(value) {
			if (value == this._protected.img) return;
			this._protected.leftFront = value;
			if (value == undefined) {
				this.dom.style.backgroundImage = '';
			} else {
				this.dom.style.backgroundImage = 'url("'+value+'")';
			}
		},
		configurable: false}
	);
	
	// tank Property
	if (object.tank == undefined) {
		object.tank = 0;
	}
	object.dom.tank.pressure.textContent = object.tank;
	object._protected.tank = object.tank;
	Object.defineProperty(object, 'tank', {
		get: function() {return this._protected.tank;},
		set: function(value) {
			if (value == undefined) value = 0;
			if (value == this._protected.tank) return;
			this._protected.tank = value;
			this.dom.tank.pressure.textContent = value;
		},
		configurable: false}
	);
	

	return object.dom;
}

function $ui_PressureButton(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom,'ui-pressure-button theme-brand-text-color');
	object.dom.onclick = function() {
		$ui.playTouchSound();
		if (this.model.onclick) {
			this.model.onclick();
		}
	};	
	object.dom.ontouchstart = function() {
		$ui.removeClass(this,'theme-brand-text-color');
		$ui.addClass(this,'theme-text-color');
	};
	object.dom.ontouchend = function() {
		$ui.removeClass(this,'theme-text-color');
		$ui.addClass(this,'theme-brand-text-color');
	};
	object.dom.ontouchcancel = object.dom.ontouchend;
	if (!$ui.isMobileDevice()) {
		object.dom.onmousedown = object.dom.ontouchstart;
		object.dom.onmouseup = object.dom.ontouchend;
		object.dom.onmouseleave = object.dom.ontouchend;
	}
	
	// Create our displayDiv
	object.dom.displayDiv = document.createElement('div');
	$ui.addClass(object.dom.displayDiv, 'pressure');
	object.dom.appendChild(object.dom.displayDiv);
	
	// Create our PSI Label
	object.dom.psiLabel = document.createElement('div');
	$ui.addClass(object.dom.psiLabel, 'psi');
	object.dom.appendChild(object.dom.psiLabel);
	object.dom.psiLabel.textContent = 'PSI';
	
	// pressure Property
	if (object.pressure == undefined) {
		object.pressure = 0;
	} 
	object.dom.displayDiv.textContent = object.pressure;
	object._protected.pressure = object.pressure;
	Object.defineProperty(object, 'pressure', {
		get: function() {return this._protected.pressure;},
		set: function(value) {
			if (value == undefined) value = 0;
			if (value == this._protected.pressure) return;
			this._protected.pressure = value;
			this.dom.displayDiv.textContent = value;
		},
		configurable: false}
	);

	return object.dom;
}

/**
 * The suspension list item type is used with the {@link $ui.List} component and represents a suspension pre-set entry. 
 * <br><br><b>Sample Declaration</b>
 * <pre>
 * {
 *   caption: '(555) 897-9876',
 *   accent: 'LF:21 RF:25 LR:30 RR:30'
 * }
 * </pre>
 * @namespace SuspensionListItem
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {string} caption - Represents the main text to show in the list item
 * @property {string} [style=fixed] - Represents the style of preset. The available values are "fixed" which is a height based on no conditions, "speed" which is a height based on a speed condition or "location" which is a height based on GPS location 
 */
function $ui_SuspensionListItem(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom, 'ui-suspension-list-item theme-screen-background-color theme-text-color theme-dark-border-color');
	if ($ui.theme.inHeadUnit == true) {
		$ui.addClass(object.dom, 'in-head-unit');
	}

	// Caption
	object.dom.captionDiv = document.createElement('div');
	$ui.addClass(object.dom.captionDiv,'caption theme-text-color');
	object.dom.appendChild(object.dom.captionDiv);
	
	// style property
	if (object.style == undefined) {
		object.style = 'fixed';
	}
	$ui.addClass(object.dom, object.style);
	object._protected.style = object.style;
	Object.defineProperty(object, 'style', {
		get: function() {return this._protected.style;},
		set: function(value) {
			if (value == undefined) value = 'fixed';
			if (value == this._protected.style) return;
			$ui.removeClass(this.dom, this._protected.style);
			$ui.addClass(this.dom, value);
			this._protected.style = value;
		},
		configurable: false}
	);
	
	// caption property
	if (object.caption == undefined) {
		object.caption = '';
	}
	object.dom.captionDiv.textContent = object.caption;
	object._protected.caption = object.caption;
	Object.defineProperty(object, 'caption', {
		get: function() {return this._protected.caption;},
		set: function(value) {
			if (value == undefined) value = '';
			if (value == this._protected.caption) return;
			this._protected.caption = value;
			this.dom.captionDiv.textContent = value;
		},
		configurable: false}
	);
	
	
	// Handle our touch events
	object.dom.ontouchstart = function() {
		$ui.removeClass(this, 'theme-screen-background-color');
		$ui.addClass(this, 'theme-brand-background-color');
	}
	object.dom.ontouchend = function() {
		$ui.removeClass(this, 'theme-brand-background-color');
		$ui.addClass(this, 'theme-screen-background-color');
	}
	object.dom.ontouchcancel = object.dom.ontouchend;
	if (!$ui.isMobileDevice()) {
		object.dom.onmousedown = object.dom.ontouchstart;
		object.dom.onmouseup = object.dom.ontouchend;
		object.dom.onmouseleave = object.dom.ontouchend;
	}

	// Pass the onclick back to the list
	object.dom.onclick = function() {
		if (this.model.parent.onaction == undefined) return;
		var event = new ListEvent(this.model, $ui.GenericListItem.GenericListEvent.ONCLICK);
		this.model.parent._onaction(this.model, event);
		$ui.playTouchSound();
	};

	return object.dom;
}
/**
 * The TileAcceleration represents the tile that shows Acceleration in G-forces..
 * <br><br><b>Sample Declaration</b>
 * <pre>
 * {
 *    component: $ui.TileAcceleration,
 *    min: 0,
 *    max: 1.5,
 *    value: 1
 * }
 * </pre>
 * @namespace TileAcceleration
 * @memberof $ui
 * @extends $ui.CoreTileGauge
 */
function $ui_TileAcceleration(object, screen) {
	$ui_CoreTileGauge.call(this, object, screen);
	$ui.addClass(object.dom,'ui-tile-acceleration');
	
	object._setTitle('Acceleration');
	object._setAccent('Average G-Forces');
	
	// Private function to handle provider updates
	object._providerUpdate = function(value) {
		if (value != undefined) {
			this.min = value.min;
			this.max = value.max;
			this.value = value.value;
			this._populateData();
		} else {
			this.min =0;
			this.max = 1;
			this.value = 0;
		}
		this.showContent(true);
	}.$bind(object);	
	
	// Handle theme changes
	object._onthemechange = function() {
		// Repaint the control
		this._providerUpdate(this);
	}.$bind(object);
	
	// Load our control if no provider is connected
	if (object.provider == undefined) {
		object._providerUpdate({min: object.min, max: object.max, value: object.value })
	}
	
	return object.dom;
}
/**
 * The Badge tile displays the different badges that the user has been awarded. 
 * <br><br><b>Sample Declaration</b>
 * <pre>
 * {
 *    component: $ui.TileBadge
 *    img: 'img/badge.png',
 *    caption: 'This is <large>my</large> caption',
 *    accent:  'Smaller text'
 * }
 * </pre>
 * @namespace TileBadge
 * @memberof $ui
 * @extends $ui.CoreTile
 * @property {string} [img] - Represents the path to the image representing the badge
 * @property {string} [accent] - Represents the accent text to go along with the caption
 * @property {string} [caption] - This is the text to appear on the badge. The caption value can also have opening and closing <b>&lt;large&gt;</b> elements to signify which parts of the text should be large-sized.
 */
function $ui_TileBadge(object, screen) {
	// This tile is 1 x 1
	object._size = undefined;
	$ui_CoreTile.call(this, object, screen);
	$ui.addClass(object.dom,'ui-tile-badge');
	
	// Create the caption area
	object.dom.caption = document.createElement('div');
	$ui.addClass(object.dom.caption,'caption');
	object.dom.contentDiv.appendChild(object.dom.caption);
	
	// Create our Next Button
	object.dom.next = document.createElement('div');
	$ui.addClass(object.dom.next, 'button');
	$ui.addClass(object.dom.next, 'next');
	object.dom.contentDiv.appendChild(object.dom.next);
	
	// Create our Previous Button
	object.dom.prev = document.createElement('div');
	$ui.addClass(object.dom.prev, 'button');
	$ui.addClass(object.dom.prev, 'prev');
	object.dom.contentDiv.appendChild(object.dom.prev);

	// Create our accent area
	object.dom.accent = document.createElement('div');
	$ui.addClass(object.dom.accent, 'accent');
	object.dom.contentDiv.appendChild(object.dom.accent);
	
	// Private function to handle provider updates
	object._providerUpdate = function(value) {
		if (value != undefined) {
			this.img = value.img;
			this.caption = value.caption;
			this.accent = value.accent;
		} else {
			this.img = undefined;
			this.caption = undefined;
			this.accent = undefined;
		}
		// Set our image
		this.dom.contentDiv.style.backgroundImage = 'url("'+ this.img + '")';
		// Set our caption
		if (this.caption) {
			var str = this.caption.replace(new RegExp('<large>', 'g'), '<span class="tall">');
			str = str.replace(new RegExp('</large>', 'g'),'</span>');
			this.dom.caption.innerHTML = str;
		}
		// Set our accent
		if (this.accent) {
			this.dom.accent.textContent = this.accent;
		}
		this.showContent(true);
	}.$bind(object);	
	
	// Load our control if no provider is connected
	if (object.provider == undefined) {
		object._providerUpdate({img: object.img, caption: object.caption, accent: object.accent })
	}
	
	return object.dom;
}
/**
 * The Braking Tile represents the tile which shows Braking in G-forces.
 * <br><br><b>Sample Declaration</b>
 * <pre>
 * {
 *    component: $ui.TileBraking,
 *    min: 0,
 *    max: 1.5,
 *    value: 1
 * }
 * </pre>
 * @namespace TileBraking
 * @memberof $ui
 * @extends $ui.CoreTileGauge
 */
function $ui_TileBraking(object, screen) {
	$ui_CoreTileGauge.call(this, object, screen);
	$ui.addClass(object.dom,'ui-tile-braking');
	
	object._setTitle('Braking');
	object._setAccent('Average G-Forces');
	
	// Private function to handle provider updates
	object._providerUpdate = function(value) {
		if (value != undefined) {
			this.min = value.min;
			this.max = value.max;
			this.value = value.value;
			this._populateData();
		} else {
			this.min =0;
			this.max = 1;
			this.value = 0;
		}
		this.showContent(true);
	}.$bind(object);	
	
	// Handle theme changes
	object._onthemechange = function() {
		// Repaint the control
		this._providerUpdate(this);
	}.$bind(object);
	
	// Load our control if no provider is connected
	if (object.provider == undefined) {
		object._providerUpdate({min: object.min, max: object.max, value: object.value })
	}
	
	return object.dom;
}
/**
 * The Distance tile displays the distance travelled over the last few recorded periods. 
 * <br><br><b>Sample Declaration</b>
 * <pre>
 * {
 *    component: $ui.TileDistance
 *    data: [5,25,8.2],
 *    units:  'miles'
 * }
 * </pre>
 * @namespace TileDistance
 * @memberof $ui
 * @extends $ui.CoreTile
 * @property {number[]} [data] - This array of numbers represents the last few points of distance units recorded. The values in the array are ordered from oldest to newest.
 * @property {string} units - This string value represents the units of measure. Typically miles or km.
 */
function $ui_TileDistance(object, screen) {
	// This tile is 1 x 1
	object._size = undefined;
	$ui_CoreTile.call(this, object, screen);
	$ui.addClass(object.dom,'ui-tile-distance');
	
	// Create our chart area
	object.dom.canvas = document.createElement('canvas');
	$ui.addClass(object.dom.canvas, 'chart');
	object.dom.canvas.height = 180;
	object.dom.contentDiv.appendChild(object.dom.canvas);
	
	// Create the caption area
	object.dom.caption = document.createElement('div');
	$ui.addClass(object.dom.caption,'caption');
	object.dom.contentDiv.appendChild(object.dom.caption);
	
	// Private function to handle provider updates
	object._providerUpdate = function(value) {
		if (this.dom.offsetWidth) {
			this.dom.canvas.width = this.dom.offsetWidth - 24;
			this.dom.ctx = this.dom.canvas.getContext('2d');
			this.dom.chart = new Chart(this.dom.ctx);
		}
		if (this.dom.chart == undefined) return;
		var i,
			_labels = [],
			_transparentData = [],
			_noData = false;
		// Assign our values
		if (value != undefined) {
			this.data = value.data;
			this.units = value.units;
		} else {
			this.data = undefined;
			this.units = 'miles';
		}
		// Make any corrections
		if ((this.data == undefined) || (this.data && this.data.length == 0)) {
			this.data = [0];
			_noData = true;
		} else if (this.data.length == 1) {
			this.data = [0,this.data[0]];
		}
		// Set our latest value
		this._value = this.data[this.data.length -1];
		// Populate our extra chart data
		for (i = 0; i < this.data.length; i++) {
			if (i == this.data.length - 1) {
				// Last item so set our values
				_labels.push('Today');
			} else {
				_labels.push('');
			}
			_transparentData.push(0);
		}
		// Set our caption
		this.dom.caption.innerHTML = '<span class="tall distance">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="tall">'+this._value+'</span> '+this.units;
		// Get our root color
		var RGB = $ui.hexToRgb($ui.theme.chart.color_GREAT);
		// Load our data
		var data = {
			labels: _labels,
			datasets: [
				{
					fillColor: 'rgba('+RGB.R+','+RGB.G+','+RGB.B+',0.2)',
					strokeColor: 'rgba('+RGB.R+','+RGB.G+','+RGB.B+',1)',
					pointColor: 'rgba('+RGB.R+','+RGB.G+','+RGB.B+',1)',
					pointStrokeColor: '#fff',
					pointHighlightFill: '#fff',
					pointHighlightStroke: 'rgba('+RGB.R+','+RGB.G+','+RGB.B+',1)',
					data: this.data
				},
				{
					fillColor: 'transparent',
					strokeColor: 'transparent',
					pointColor: 'transparent',
					pointStrokeColor: 'transparent',
					pointHighlightFill: 'transparent',
					pointHighlightStroke: 'transparent',
					data: _transparentData
				}
			]
		}
		this.dom.chart.Line(data,{scaleShowGridLines: false,showTooltips: false,scaleFontColor: window.getComputedStyle(this.dom).color});
		this.showContent(true);
	}.$bind(object);	
	
	// Handle theme changes
	object._onthemechange = function() {
		// Repaint the control
		this._providerUpdate(this);
	}.$bind(object);
	
	// Load our control if no provider is connected
	object._onshow = function() {
		if (this.provider == undefined) {
			this._providerUpdate({data: this.data, units: this.units})
		}
	}.$bind(object);
	
	return object.dom;
}
/**
 * The Drift Angle tile represents a tile displaying the current angle of the vehicle.
 * <br><br><b>Sample Declaration</b>
 * <pre>
 * {
 *    component: $ui.TileDriftAngle,
 *    angle: 20
 * }
 * </pre>
 * @namespace TileDriftAngle
 * @memberof $ui
 * @extends $ui.CoreTile
 * @property {number} [angle] - This number represents the current angle of the vehicle based on its current heading
 * @property {string} img - Path to the image to display in the tile
 */
function $ui_TileDriftAngle(object, screen) {
	// This tile is 1 x 1
	object._size = $ui.TileSize.SQUARE;
	$ui_CoreTile.call(this, object, screen);
	$ui.addClass(object.dom,'ui-tile-drift-angle');
	
	// Create the dial area
	object.dom.dial = document.createElement('div');
	$ui.addClass(object.dom.dial,'dial');
	object.dom.contentDiv.appendChild(object.dom.dial);
	object.dom.dial.img = new Image();
	object.dom.dial.img.parent = object.dom.dial;
	object.dom.dial.img.onload = function() {
		this.parent.style.opacity = 1;
		this.parent.style.backgroundImage = 'url("'+this.src+'")';
	};
	
	// img Property
	if (object.img != undefined) {
		object.dom.dial.img.src = object.img;
	}
	object._protected.img = object.img;
	Object.defineProperty(object, 'img', {
		get: function() {return this._protected.img;},
		set: function(value) {
			if (value == this._protected.img) return;
			if (value == undefined) value = '';
			this._protected.img = value;
			this.dom.dial.style.opacity = 0;
			this.dom.dial.img.src = value;
		},
		configurable: false}
	);
	
	// angle Property
	if (object.angle != undefined) {
		object.dom.dial.style['-webkit-transform'] = 'rotate('+ object.angle +'deg)';
	}
	object._protected.angle = object.angle;
	Object.defineProperty(object, 'angle', {
		get: function() {return this._protected.angle;},
		set: function(value) {
			if (value == this._protected.angle) return;
			if (value == undefined) value = 0;
			this._protected.angle = value;
			this.dom.dial.style['-webkit-transform'] = 'rotate('+ value +'deg)';
		},
		configurable: false}
	);
	
	// Display the content because we are not waiting for a provider
	object.showContent(true);

	return object.dom;
}

/**
 * The Dyno Chart tile represents horsepower and torque graphing
 * <br><br><b>Sample Declaration</b>
 * <pre>
 * {
 *    component: $ui.TileDynoChart,
 *    caption: 'Max 567HP and 489 TQ',
 *    horsepower: [400, 489, 505],
 *    torque: [360, 402,482]
 * }
 * </pre>
 * @namespace TileDynoChart
 * @memberof $ui
 * @extends $ui.CoreTile
 * @property {number[]} [horsepower] - This array of numbers represents the horsepower rating at 100 RPM intervals
 * @property {number[]} [torque] - This array of numbers represents the torque rating at 100 RPM intervals
 * @property {string} [caption] - This optional string value represents the text caption you wish to include
 */
function $ui_TileDynoChart(object, screen) {
	// This tile is 1 x 2
	object._size = $ui.TileSize.WIDE;
	$ui_CoreTile.call(this, object, screen);
	$ui.addClass(object.dom,'ui-tile-dyno-chart');
	
	// Create the caption area
	object.dom.caption = document.createElement('div');
	$ui.addClass(object.dom.caption,'caption');
	object.dom.contentDiv.appendChild(object.dom.caption);
	
	// RPM Counter
	object.dom.rpm = document.createElement('div');
	$ui.addClass(object.dom.rpm, 'rpm');
	object.dom.contentDiv.appendChild(object.dom.rpm);
	
	// How To display
	object.dom.howTo = document.createElement('div');
	$ui.addClass(object.dom.howTo, 'how-to');
	object.dom.contentDiv.appendChild(object.dom.howTo);
	object.dom.howTo.textContent = 'Start driving below 3000 RPM in 3rd gear, then press START and accelerate to 7000 RPM';
	
	// Create our chart area
	object.dom.canvas = document.createElement('canvas');
	$ui.addClass(object.dom.canvas, 'chart');
	object.dom.canvas.height = 190;
	object.dom.canvas.width = 490;
	object.dom.contentDiv.appendChild(object.dom.canvas);
	object.dom.ctx = object.dom.canvas.getContext('2d');
	object.dom.chart = new Chart(object.dom.ctx);
	
	// horsepower Property
	if (object.horsepower == undefined) {
		object.horsepower = [];
	}
	object._protected.horsepower = object.horsepower;
	Object.defineProperty(object, 'horsepower', {
		get: function() {return this._protected.horsepower;},
		set: function(value) {
			if (value == this._protected.horsepower) return;
			if (value == undefined) value = [];
			this._protected.horsepower = value;
			this._providerUpdate(this);
		},
		configurable: false}
	);
	
	// caption Property
	if (object.caption == undefined) {
		object.caption = '';
	} else {
		object.dom.caption.textContent = object.caption;
	}
	object._protected.caption = object.caption;
	Object.defineProperty(object, 'caption', {
		get: function() {return this._protected.caption;},
		set: function(value) {
			if (value == this._protected.caption) return;
			if (value == undefined) value = '';
			this._protected.caption = value;
			this.dom.caption.textContent = value;
		},
		configurable: false}
	);
		
	// torque Property
	if (object.torque == undefined) {
		object.torque = [];
	}
	object._protected.torque = object.torque;
	Object.defineProperty(object, 'torque', {
		get: function() {return this._protected.torque;},
		set: function(value) {
			if (value == this._protected.torque) return;
			if (value == undefined) value = [];
			this._protected.torque = value;
			this._providerUpdate(this);
		},
		configurable: false}
	);
	
	/** When you set the RPM of the Dyno Chart it will move the control to a new state where just the RPMs are visible
	 * @function setRPM
	 * @memberof $ui.TileDynoChart
	 * @param {number} value - The RPM value to set
	 */
	object.setRPM = function(value) {
		this.dom.rpm.style.display = 'block';
		this.dom.canvas.style.display = 'none';
		this.dom.caption.style.display = 'none';
		this.dom.howTo.style.display = 'none';
		this.dom.rpm.innerHTML = '<span>'+value + '</span><span style="font-size: 50px;"> RPM</span>';
	}.$bind(object);
	
	/** This will reset the dyno chart back to its initial state
	 * @function reset
	 * @memberof $ui.TileDynoChart
	 */
	object.reset = function() {
		this.dom.rpm.style.display = 'none';
		this.dom.howTo.style.display = 'block';
		this.dom.canvas.style.display = 'none';
		this.dom.caption.style.display = 'none';
	}.$bind(object);
	
	// Private function to handle provider updates
	object._providerUpdate = function(value) {
		var i,
			_labels = ['3','','','','','3.5','','','','','4','','','','','4.5','','','','','5','','','','','5.5','','','','','6','','','','','6.5','','','','','7'];
		// Assign our values
		if (value != undefined) {
			this._protected.horsepower = (value.horsepower == undefined) ? [] : value.horsepower;
			this._protected.torque = (value.torque == undefined) ? [] : value.torque;
			this.caption = value.caption;
		} else {
			this.data = undefined;
			this.labels = undefined;
		}
		// Reset our visibility
		this.dom.rpm.style.display = 'none';
		this.dom.canvas.style.display = 'block';
		this.dom.caption.style.display = 'block';
		this.dom.howTo.style.display = 'none';
		// Get our root color
		var RGB = $ui.hexToRgb($ui.theme.chart.color_GREAT),
			RGB2 = $ui.hexToRgb($ui.theme.chart.color);
		// Load our data
		var data = {
			labels: _labels,
			datasets: [
				{
					fillColor: 'rgba('+RGB2.R+','+RGB2.G+','+RGB2.B+',0.5)',
					strokeColor: 'rgba('+RGB2.R+','+RGB2.G+','+RGB2.B+',1)',
					data: this.torque
				},
				{
					fillColor: 'rgba('+RGB.R+','+RGB.G+','+RGB.B+',0.5)',
					strokeColor: 'rgba('+RGB.R+','+RGB.G+','+RGB.B+',1)',
					data: this.horsepower
				}
			]
		}
		this.dom.chart.Line(data,{scaleShowGridLines: true,showTooltips: false,scaleFontColor: '#FFFFFF',pointDot: false});
	}.$bind(object);	
	
	// Handle theme changes
	object._onthemechange = function() {
		// Repaint the control
		this._providerUpdate(this);
	}.$bind(object);
	
	// Load our control if no provider is connected
	if (object.provider == undefined) {
		object._providerUpdate(object);
	}
	object.showContent(true);
	
	return object.dom;
}
/**
 * The Fuel tile displays the fuel used over the last few recorded periods. 
 * <br><br><b>Sample Declaration</b>
 * <pre>
 * {
 *    component: $ui.TileFuel
 *    data: [5,25,8.2],
 *    value: 8.25
 * }
 * </pre>
 * @namespace TileFuel
 * @memberof $ui
 * @extends $ui.CoreTile
 * @property {number[]} [data] - This array of numbers represents the last few points of fuel level values recorded. The values in the array are ordered from oldest to newest.
 * @property {number} value - This number value represents the dollar amount of fuel used for the day
 */
function $ui_TileFuel(object, screen) {
	// This tile is 1 x 1
	object._size = undefined;
	$ui_CoreTile.call(this, object, screen);
	$ui.addClass(object.dom,'ui-tile-fuel');

	// Create our chart area
	object.dom.canvas = document.createElement('canvas');
	$ui.addClass(object.dom.canvas, 'chart');
	object.dom.canvas.height = 180;
	object.dom.contentDiv.appendChild(object.dom.canvas);
	
	// Create our left hand labels
	object.dom.leftLabels = document.createElement('div');
	$ui.addClass(object.dom.leftLabels, 'left-labels theme-screen-background-color');
	object.dom.contentDiv.appendChild(object.dom.leftLabels);
	// Top Label
	object.dom.topLabel = document.createElement('div');
	$ui.addClass(object.dom.topLabel, 'label');
	$ui.addClass(object.dom.topLabel, 'top');
	object.dom.topLabel.textContent = 'F';
	object.dom.leftLabels.appendChild(object.dom.topLabel);
	// Middle Label
	object.dom.middleLabel = document.createElement('div');
	$ui.addClass(object.dom.middleLabel, 'label');
	$ui.addClass(object.dom.middleLabel, 'middle');
	object.dom.middleLabel.innerHTML = '&#189;';
	object.dom.leftLabels.appendChild(object.dom.middleLabel);
	// Bottom Label
	object.dom.bottomLabel = document.createElement('div');
	$ui.addClass(object.dom.bottomLabel, 'label');
	$ui.addClass(object.dom.bottomLabel, 'bottom');
	object.dom.bottomLabel.textContent = 'E';
	object.dom.leftLabels.appendChild(object.dom.bottomLabel);
	
	// Create the caption area
	object.dom.caption = document.createElement('div');
	$ui.addClass(object.dom.caption,'caption');
	object.dom.contentDiv.appendChild(object.dom.caption);

	// Private function to handle provider updates
	object._providerUpdate = function(value) {
		if (this.dom.offsetWidth) {
			this.dom.canvas.width = this.dom.offsetWidth - 20;
			this.dom.ctx = this.dom.canvas.getContext('2d');
			this.dom.chart = new Chart(this.dom.ctx);
		}
		if (this.dom.chart == undefined) return;
		var i,
			_labels = [],
			_transparentData = [],
			_noData = false;
		// Assign our values
		if (value != undefined) {
			this.data = value.data;
			this.value = value.value;
		} else {
			this.data = undefined;
			this.value = 0;
		}
		// Make any corrections
		if (this.value == undefined) this.value = 0;
		if ((this.data == undefined) || (this.data && this.data.length == 0)) {
			this.data = [0];
			_noData = true;
		} else if (this.data.length == 1) {
			this.data = [0,this.data[0]];
		}
		// Populate our extra chart data
		for (i = 0; i < this.data.length; i++) {
			if (i == this.data.length - 1) {
				// Last item so set our values
				_labels.push('Now');
				_transparentData.push(0);
			} else {
				_labels.push('');
				_transparentData.push(100);
			}
		}
		// Set our caption
		this.dom.caption.innerHTML = '<span class="tall">$'+this.value+'</span> of <span class="tall fuel">&nbsp;&nbsp;&nbsp;&nbsp;</span>Today';
		// Get our root color
		var RGB = $ui.hexToRgb($ui.theme.chart.color_RANDOM1);
		
		// Load our data
		var data = {
			labels: _labels,
			datasets: [
				{
					fillColor: 'rgba('+RGB.R+','+RGB.G+','+RGB.B+',0.2)',
					strokeColor: 'rgba('+RGB.R+','+RGB.G+','+RGB.B+',1)',
					pointColor: 'rgba('+RGB.R+','+RGB.G+','+RGB.B+',1)',
					pointStrokeColor: '#fff',
					pointHighlightFill: '#fff',
					pointHighlightStroke: 'rgba('+RGB.R+','+RGB.G+','+RGB.B+',1)',
					data: this.data
				},
				{
					fillColor: 'transparent',
					strokeColor: 'transparent',
					pointColor: 'transparent',
					pointStrokeColor: 'transparent',
					pointHighlightFill: 'transparent',
					pointHighlightStroke: 'transparent',
					data: _transparentData
				}
			]
		}
		this.dom.chart.Line(data,{scaleShowGridLines: false,showTooltips: false, scaleFontColor: window.getComputedStyle(this.dom).color});	
		this.showContent(true);
	}.$bind(object);	
	
	// Handle theme changes
	object._onthemechange = function() {
		// Repaint the control
		this._providerUpdate(this);
	}.$bind(object);
	
	// Load our control if no provider is connected
	object._onshow = function() {
		if (this.provider == undefined) {
			this._providerUpdate({data: this.data, value: this.value})
		}
	}.$bind(object);
	
	return object.dom;
}
/**
 * The Idle tile represents the amount of time the driver spends moving and not sitting in one place.
 * <br><br><b>Sample Declaration</b>
 * <pre>
 * {
 *    component: $ui.TileIdle
 *    value: 70
 * }
 * </pre>
 * @namespace TileIdle
 * @memberof $ui
 * @extends $ui.CoreTile
 * @property {number} value - This number value represents the percentage of time the driver spent moving.
 */
function $ui_TileIdle(object, screen) {
	object._size = undefined;
	$ui_CoreTileDonutChart.call(this, object, screen);
	$ui.addClass(object.dom,'ui-tile-idle-chart');
	
	// Figure out the data array for this chart
	object._calculateData = function() {
		var data;
		if (this.value != undefined) {
			var colorValue;
			// Correct any errors in data
			if (this.value < 0) this.value = 0;
			if (this.value > 100) this.value = 100;
			// Determine color
			switch (true) {
				case (this.value >= 70):
					colorValue = $ui.theme.chart.color_GREAT;
					break;
				case (this.value >= 50):
					colorValue = $ui.theme.chart.color_GOOD;
					break;
				default:
					colorValue = $ui.theme.chart.color_OK;
					break;
			}		
			// Create our chart data object
			data = [
				{
					value: this.value,
					color: colorValue,
				},
				{
					value: (100 - this.value),
					color: $ui.theme.chart.color
				}				
			];	
		} 
		return data;
	}.$bind(object);
	
	// Private function to handle provider updates
	object._providerUpdate = function(value) {
		if (value != undefined) {
			this.value = value.value;
		} else {
			this.value = 0;
		}
		// Populate our chart with data
		var data = this._calculateData();
		if (data != undefined) {
			this._setData(data);
			this._setCaption('<span class="tall">'+this.value + '%</span> spent moving');
		}
		this.showContent(true);
	}.$bind(object);	
	
	// Handle theme changes
	object._onthemechange = function() {
		// Repaint the control
		this._providerUpdate(this);
	}.$bind(object);
	
	// Load our control if no provider is connected
	if (object.provider == undefined) {
		object._providerUpdate({value: object.value });
	}
	
	return object.dom;
}
/**
 * The Idle Details tile represents how much time was spent being stuck in traffic over the last 7 days.
 * <br><br><b>Sample Declaration</b>
 * <pre>
 * {
 *    component: $ui.TileIdleDetails,
 *    labels: ['Sun','Mon','Tue','Wed','Thur','Fri','Today'],
 *    data: [0,35,17,65,0,10,15]
 * }
 * </pre>
 * @namespace TileIdleDetails
 * @memberof $ui
 * @extends $ui.CoreTile
 * @property {number[]} [data] - This array of numbers represents the amount of minutes spent idle over the last 7 days
 * @property {string[]} [labels] - This array of strings represents the labels for the last 7 days
 */
function $ui_TileIdleDetails(object, screen) {
	// This tile is 1 x 1
	object._size = $ui.TileSize.WIDE;
	if (object.animated == undefined) {
		object.animated = true;
	}
	$ui_CoreTile.call(this, object, screen);
	$ui.addClass(object.dom,'ui-tile-idle-details');
	
	// Create the caption area
	object.dom.caption = document.createElement('div');
	$ui.addClass(object.dom.caption,'caption');
	object.dom.contentDiv.appendChild(object.dom.caption);
	object.dom.caption.textContent = 'Time Stuck In Traffic (mins)';
	
	// Create our chart area
	object.dom.canvas = document.createElement('canvas');
	$ui.addClass(object.dom.canvas, 'chart');
	object.dom.canvas.height = 190;
	object.dom.contentDiv.appendChild(object.dom.canvas);
	
	// Private function to handle provider updates
	object._providerUpdate = function(value) {
		if (this.dom.offsetWidth) {
			this.dom.canvas.width = this.dom.offsetWidth - 10;
			this.dom.ctx = this.dom.canvas.getContext('2d');
			this.dom.chart = new Chart(this.dom.ctx);
		}
		if (this.dom.chart == undefined) return;
		if (value != undefined) {
			this.data = value.data;
			this.labels = value.labels;
		} else {
			this.data = undefined;
			this.labels = undefined;
		}
		// Get our root color
		var RGB = $ui.hexToRgb($ui.theme.chart.color_OK);
		// Load our data
		var data = {
			labels: this.labels,
			datasets: [
				{
					fillColor: 'rgba('+RGB.R+','+RGB.G+','+RGB.B+',0.5)',
					strokeColor: 'rgba('+RGB.R+','+RGB.G+','+RGB.B+',1)',
					data: this.data
				}
			]
		}
		this.dom.chart.Bar(data,{scaleShowGridLines: true,showTooltips: false, animation: this.animated, scaleFontColor: window.getComputedStyle(this.dom).color});
		this.showContent(true);
	}.$bind(object);	
	
	// Handle theme changes
	object._onthemechange = function() {
		// Repaint the control
		this._providerUpdate(this);
	}.$bind(object);
	
	// Load our control if no provider is connected
	object._onshow = function() {
		if (this.provider == undefined) {
			this._providerUpdate({data: this.data, labels: this.labels})
		}
	}.$bind(object);
	
	return object.dom;
}
/**
 * The Lateral Gs tile represents information for skid pad testing.
 * <br><br><b>Sample Declaration</b>
 * <pre>
 * {
 *    component: $ui.TileLateralGs,
 *    rotation: 20
 * }
 * </pre>
 * @namespace TileLateralGs
 * @memberof $ui
 * @extends $ui.CoreTile
 * @property {number} [rotation] - This number represents the percentage in rotation around the skidpad. 50 would represent 1/2 a rotation
 * @property {string} img - Path to the image to display in the tile
 */
function $ui_TileLateralGs(object, screen) {
	// This tile is 1 x 1
	object._size = $ui.TileSize.SQUARE;
	$ui_CoreTile.call(this, object, screen);
	$ui.addClass(object.dom,'ui-tile-lateral-g');
	
	// Create the dial area
	object.dom.dial = document.createElement('div');
	$ui.addClass(object.dom.dial,'dial');
	object.dom.contentDiv.appendChild(object.dom.dial);
	
	// Create our vehicle
	object.dom.vehicle = document.createElement('img');
	$ui.addClass(object.dom.vehicle, 'vehicle');
	object.dom.dial.appendChild(object.dom.vehicle);
	object.dom.vehicle.onload = function() {
		this.style.opacity = 1;
	}
	
	// Create our circle
	object.dom.circle = document.createElement('div');
	$ui.addClass(object.dom.circle, 'circle theme-border-color');
	object.dom.dial.appendChild(object.dom.circle);
	
	// Create our line
	object.dom.line = document.createElement('div');
	$ui.addClass(object.dom.line, 'line theme-brand-text-color theme-brand-border-color');
	object.dom.contentDiv.appendChild(object.dom.line);
	object.dom.line.textContent = '150 ft radius';
	
	// img Property
	if (object.img != undefined) {
		object.dom.vehicle.src = object.img;
	}
	object._protected.img = object.img;
	Object.defineProperty(object, 'img', {
		get: function() {return this._protected.img;},
		set: function(value) {
			if (value == this._protected.img) return;
			if (value == undefined) value = '';
			this._protected.img = value;
			this.dom.vehicle.style.opacity = 0;
			this.dom.vehicle.src = value;
		},
		configurable: false}
	);
	
	// rotation Property
	if (object.rotation != undefined) {
		object.dom.dial.style['-webkit-transform'] = 'rotate('+ object.rotation +'deg)';
	}
	object._protected.rotation = object.rotation;
	Object.defineProperty(object, 'rotation', {
		get: function() {return this._protected.rotation;},
		set: function(value) {
			if (value == this._protected.rotation) return;
			if (value == undefined) value = 0;
			this._protected.rotation = value;
			this.dom.dial.style['-webkit-transform'] = 'rotate('+ value +'deg)';
		},
		configurable: false}
	);
	
	// Display the content because we are not waiting for a provider
	object.showContent(true);
	
	return object.dom;
}

/**
 * The MPG tile represents how close to the target miles per gallon target they achieved
 * <br><br><b>Sample Declaration</b>
 * <pre>
 * {
 *    component: $ui.TileMPG,
 *    value: 25,
 *    max: 34,
 *    abbreviation: 'MPG'
 * }
 * </pre>
 * @namespace TileMPG
 * @memberof $ui
 * @extends $ui.CoreTileDonutChart
 * @property {number} [value] - This number value represents the actual MPG value achived
 * @property {number} [max] - This number value represents the target value the driver is hoping to achieve
 * @property {string} [abbreviation] - This string value represents the Miles per gallon or KM per liter abbreviation
 */
function $ui_TileMPG(object, screen) {
	object._size = undefined;
	$ui_CoreTileDonutChart.call(this, object, screen);
	$ui.addClass(object.dom,'ui-tile-mpg-chart');
	
	// Figure out the data array for this chart
	object._calculateData = function() {
		var data;
		if (this.max != undefined && this.value != undefined) {
			var colorValue,
				percent;
			// Check for errors in data
			if (this.value < 0) this.value = 0;
			if (this.value > this.max) {
				percent = 100;	
			} else {
				percent = Math.ceil((this.value / this.max)*100);
			}
			// Determine Color
			switch (true) {
				case (percent > 90):
					colorValue = $ui.theme.chart.color_GREAT;
					break;
				case (percent > 50):
					colorValue = $ui.theme.chart.color_GOOD;
					break;
				default:
					colorValue = $ui.theme.chart.color_OK;
					break;
			}
			// Create our chart data object
			data = [
				{
					value: percent,
					color: colorValue,
				},
				{
					value: (100-percent),
					color: $ui.theme.chart.color
				}
			];	
		} 
		return data;
	}.$bind(object);
	

	// Private function to handle provider updates
	object._providerUpdate = function(value) {
		if (value != undefined) {
			this.value = value.value;
			this.max = value.max;
			this.abbreviation = value.abbreviation;
		} else {
			this.value = 0;
			this.max = 0;
			this.abbreviation = 'MPG';
		}
		// Populate our chart with data
		var data = this._calculateData();
		if (data != undefined) {
			this._setData(data);
			this._setCaption('<span class="tall">'+this.value + '</span> ' + this.abbreviation);
		}
		this.showContent(true);
	}.$bind(object);	
	
	// Handle theme changes
	object._onthemechange = function() {
		// Repaint the control
		this._providerUpdate(this);
	}.$bind(object);
	
	// Load our control if no provider is connected
	if (object.provider == undefined) {
		object._providerUpdate({value: object.value, max: object.max, abbreviation: object.abbreviation })
	}
	
	return object.dom;
}
/**
 * The Profile tile displays the user's profile and participation statistics.
 * <br><br><b>Sample Declaration</b>
 * <pre>
 * {
 *    component: $ui.TileProfile
 *    backgroundImg: 'img/car.png',
 *    avatar: 'img/useravatar.png',
 *    userName:  'brcewane',
 *    stats: {
 *        friends: 12,
 *        groups: 6,
 *        score: 4056,
 *        rank: 2,
 *    }
 * }
 * </pre>
 * @namespace TileProfile
 * @memberof $ui
 * @extends $ui.CoreTile
 * @property {string} [backgroundImg] - This is the path to the background image the user has chosen for their profile.
 * @property {string} [userName] - This is the user's profile name
 * @property {string} [avatar] - This string value represents the path to the user's avatar picture
 * @property {$ui.TileProfile.ProfileStats} [stats] - This object represents the participation statistics for the user
 */
function $ui_TileProfile(object, screen) {
	// This is a tall tile
	object._size = $ui.TileSize.TALL;
	$ui_CoreTile.call(this, object, screen);
	$ui.addClass(object.dom,'ui-tile-profile');
	
	// Create our Color wedge
	object.dom.wedge = document.createElement('div');
	$ui.addClass(object.dom.wedge, 'wedge theme-profile-wedge-background-color');
	object.dom.contentDiv.appendChild(object.dom.wedge);
	
	// Create the space for our vehicle
	object.dom.vehicle = document.createElement('div');
	$ui.addClass(object.dom.vehicle, 'vehicle theme-profile-vehicle-background-color');
	object.dom.contentDiv.appendChild(object.dom.vehicle);
	object.dom.vehicle.image = document.createElement('div');
	$ui.addClass(object.dom.vehicle.image, 'vehicle-image');
	object.dom.vehicle.appendChild(object.dom.vehicle.image);
	object.dom.vehicle.overlay = document.createElement('div');
	$ui.addClass(object.dom.vehicle.overlay, 'vehicle-overlay');
	object.dom.vehicle.image.appendChild(object.dom.vehicle.overlay);
	
	// Create our user name
	object.dom.userName = document.createElement('div');
	$ui.addClass(object.dom.userName,'name');
	object.dom.vehicle.appendChild(object.dom.userName);
	
	// format a number for the stats box
	object._formatNumber = function(value) {
		if (value == undefined) return 0;
		var formattedValue,
			dividedValue;
		switch (true) {
			case (value >= 1000000):
				dividedValue = (value/1000000).toFixed(1);
				if ((dividedValue % 1) == 0) {
					dividedValue = Math.floor(dividedValue);	
				}
				formattedValue = dividedValue + 'M';
				break;
			case (value >= 10000):
				dividedValue = (value/1000).toFixed(1);
				if ((dividedValue % 1) == 0) {
					dividedValue = Math.floor(dividedValue);	
				}
				formattedValue = dividedValue + 'K';
				break;
			case (value >= 1000):
				formattedValue = value.toString();
				formattedValue = formattedValue.slice(0,1) + ',' + formattedValue.slice(1,formattedValue.length);
				break;
			case (value < 1000):
				formattedValue = value;
				break;
			default:
				formattedValue = value;
				break;
		}
			
		return formattedValue;
	}.$bind(object);
	
	// Add our stats box
	object.dom.stats = document.createElement('div');
	$ui.addClass(object.dom.stats, 'stats theme-profile-stats');
	object.dom.contentDiv.appendChild(object.dom.stats);
	
	// Add score box
	object.dom.score = document.createElement('div');
	$ui.addClass(object.dom.score, 'box');
	object.dom.stats.appendChild(object.dom.score);
	object.dom.score.label = document.createElement('div');
	$ui.addClass(object.dom.score.label, 'label theme-profile-label-text-color');
	object.dom.score.appendChild(object.dom.score.label);
	object.dom.score.label.textContent = 'SCORE';
	object.dom.score.number = document.createElement('div');
	$ui.addClass(object.dom.score.number, 'number theme-profile-number-color');
	object.dom.score.appendChild(object.dom.score.number);
	
	// Add friends box
	object.dom.friends = document.createElement('div');
	$ui.addClass(object.dom.friends, 'box');
	$ui.addClass(object.dom.friends, 'right');
	object.dom.stats.appendChild(object.dom.friends);
	object.dom.friends.label = document.createElement('div');
	$ui.addClass(object.dom.friends.label, 'label theme-profile-label-text-color');
	object.dom.friends.appendChild(object.dom.friends.label);
	object.dom.friends.label.textContent = 'FRIENDS';
	object.dom.friends.number = document.createElement('div');
	$ui.addClass(object.dom.friends.number, 'number theme-profile-number-color');
	object.dom.friends.appendChild(object.dom.friends.number);
	
	// Add clubs box
	object.dom.clubs = document.createElement('div');
	$ui.addClass(object.dom.clubs, 'box');
	$ui.addClass(object.dom.clubs, 'right');
	object.dom.stats.appendChild(object.dom.clubs);
	object.dom.clubs.label = document.createElement('div');
	$ui.addClass(object.dom.clubs.label, 'label theme-profile-label-text-color');
	object.dom.clubs.appendChild(object.dom.clubs.label);
	object.dom.clubs.label.textContent = 'CLUBS';
	object.dom.clubs.number = document.createElement('div');
	$ui.addClass(object.dom.clubs.number, 'number theme-profile-number-color');
	object.dom.clubs.appendChild(object.dom.clubs.number);
	
	// Create our avatar space
	object.dom.avatar = document.createElement('div');
	$ui.addClass(object.dom.avatar, 'avatar theme-profile-avatar');
	object.dom.contentDiv.appendChild(object.dom.avatar);
	
	// Add our rank text
	object.dom.rankText = document.createElement('div');
	$ui.addClass(object.dom.rankText, 'rank-text theme-profile-rank-text-color');
	object.dom.contentDiv.appendChild(object.dom.rankText);
	object.dom.rankText.textContent = 'Ranked';
	
	// Add our rank notification
	object.dom.rank = document.createElement('div');
	$ui.addClass(object.dom.rank, 'rank theme-profile-rank');
	object.dom.contentDiv.appendChild(object.dom.rank);
	
	// Add our find Friends button
	object.dom.findFriend = document.createElement('div');
	$ui.addClass(object.dom.findFriend, 'button');
	$ui.addClass(object.dom.findFriend, 'search');
	object.dom.findFriend.textContent = 'Find a Friend';
	object.dom.contentDiv.appendChild(object.dom.findFriend);
	
	// Add our find clubs button
	object.dom.findClub = document.createElement('div');
	$ui.addClass(object.dom.findClub, 'button');
	$ui.addClass(object.dom.findClub, 'plus');
	object.dom.findClub.textContent = 'Join a Club';
	object.dom.contentDiv.appendChild(object.dom.findClub);
	
	// Private function to handle provider updates
	object._providerUpdate = function(value) {
		// Assign our values
		if (value != undefined) {
			this.backgroundImg = value.backgroundImg;
			this.avatar = value.avatar;
			this.userName = value.userName;
			this.stats = value.stats;
		} else {
			this.backgroundImg = undefined;
			this.avatar = undefined;
			this.userName = undefined;
			this.stats = undefined;
		}
		// Load the vehicle
		if (this.backgroundImg) {
			this.loader = new Image();
			this.loader.model = this;
			// Change the opacity on load
			this.loader.onload = function() {
				this.model.dom.vehicle.image.style.opacity = '1.0';
				this.model.dom.vehicle.image.style.backgroundImage = 'url("'+ this.model.backgroundImg + '")';
				this.model.loader = null;
			}
			this.loader.src = this.backgroundImg;
		} else {
			this.dom.vehicle.image.style.backgroundImage = '';
		}
		// Set Username
		if (this.userName) {
			this.dom.userName.textContent = this.userName;
		} else {
			this.dom.userName.textContent = '';
		}
		// Set Stats
		if (this.stats) {
			this.dom.score.number.textContent = this._formatNumber(this.stats.score);
			this.dom.friends.number.textContent = this._formatNumber(this.stats.friends);
			this.dom.clubs.number.textContent = this._formatNumber(this.stats.clubs);
			this.dom.rank.textContent = this.stats.rank;
			this.dom.rank.style.opacity = '1.0';
		} else {
			this.dom.score.number.textContent = '0';
			this.dom.friends.number.textContent = '0';
			this.dom.clubs.number.textContent = '0';
			this.dom.rank.textContent = '1';
			this.dom.rank.style.opacity = '1.0';
		}
		// Set our avatar
		if (this.avatar) {
			this.dom.avatar.style.backgroundImage = 'url("'+ this.avatar + '")';
		}
		this.showContent(true);
	}.$bind(object);	
	
	// Load our control if no provider is connected
	if (object.provider == undefined) {
		object._providerUpdate({backgroundImg: object.backgroundImg, avatar: object.avatar, userName: object.userName, stats: object.stats})
	}
	
	return object.dom;
}
/**
 * Statistics for the user profile tile {@link $ui.TileProfile}
 * @namespace ProfileStats
 * @memberof $ui.TileProfile
 * @property {number} [friends] - The number of friends
 * @property {number} [clubs] - The number of clubs
 * @property {number} [score] - The overall point total for the user
 * @property {number} [rank] - The overall rank of the user among their friends and groups
 */
/**
 * The Record tile provides a button to start recording with optional countdown capability.
 * <br><br><b>Sample Declaration</b>
 * <pre>
 * {
 *    component: $ui.TileRecord,
 *    caption: 'Record 0-60 Time',
 *    countdown: true
 * }
 * </pre>
 * @namespace TileRecord
 * @memberof $ui
 * @extends $ui.CoreTile
 * @property {string} [caption] - This is the caption to show at the bottom of the tile
 * @property {boolean} [countdown=false] - This optional boolean property specifies if you wish to have a count down come after the user presses the start button. If set to true it will do a countdown from 3 before the <b>onrecord</b> event is triggered.
 * @property {GenericEvent} [onstartclick] - Fires when the user presses Start
 * @property {GenericEvent} [onrecord] - Fires when the recording begins
 * @property {GenericEvent} [onstopclick] - Fires when the user presses stop
 */
function $ui_TileRecord(object, screen) {
	// This tile is 1 x 1
	object._size = undefined;
	$ui_CoreTile.call(this, object, screen);
	$ui.addClass(object.dom,'ui-tile-record');
	
	// Create our stage 1 area
	object.dom.stage1 = document.createElement('div');
	$ui.addClass(object.dom.stage1,'stage-1');
	object.dom.contentDiv.appendChild(object.dom.stage1);
	
	// Create our record button
	object.dom.recordButton = document.createElement('div');
	object.dom.recordButton.model = object;
	$ui.addClass(object.dom.recordButton,'record-button theme-brand-background-color theme-brand-border-color');
	object.dom.stage1.appendChild(object.dom.recordButton);
	object.dom.recordButton.textContent = 'Start';
	object.dom.recordButton.onclick = function() {
		var model = this.model;
		if (model._protected.recording == true) {
			model.reset();
			if (model.onstopclick) {
				model.onstopclick();
			}
			return;
		} 
		$ui.playTouchSound();
		// Fire the start click
		if (model.onstartclick) {
			model.onstartclick();
		}
		// See if there is a countdown
		if (model.countdown === true) {
			model.dom.stage1.style.display = 'none';
			model.dom.stage2.style.display = 'inline';
			model._countDownNum = 3;
			model._interval = window.setInterval(model._countDownInterval, 1000);
			if (model.oncountdown) {
				model.oncountdown();
			}
			return;
		} 
		// Change button into recording mode
		this.textContent = 'Stop';
		this.style.backgroundColor = '';
		$ui.removeClass(this,'theme-brand-background-color');
		$ui.addClass(this,'theme-screen-background-color');
		model._protected.borderVisible = true;
		model._interval = window.setInterval(model._pulseInterval, 200);
		model._protected.recording = true;
		// Fire the recording if no countdown
		if (model.onrecord) {
			model.onrecord();
		}
	};
	object.dom.recordButton.ontouchstart = function() {
		this.style.opacity = '0.7';
	};
	object.dom.recordButton.ontouchend = function() {
		this.style.opacity = '1.0';
	};
	object.dom.recordButton.ontouchcancel = object.dom.recordButton.ontouchend;
	if (!$ui.isMobileDevice()) {
		object.dom.recordButton.onmousedown = object.dom.recordButton.ontouchstart;
		object.dom.recordButton.onmouseup = object.dom.recordButton.ontouchend;
		object.dom.recordButton.onmouseleave = object.dom.recordButton.ontouchend;
	}
	
	// Create our caption
	object.dom.captionDiv = document.createElement('div');
	$ui.addClass(object.dom.captionDiv,'caption');
	object.dom.stage1.appendChild(object.dom.captionDiv);
	if (object.caption) {
		object.dom.captionDiv.textContent = object.caption;
	}
	
	// Create our Stage 2 area
	object.dom.stage2 = document.createElement('div');
	$ui.addClass(object.dom.stage2,'stage-2');
	object.dom.contentDiv.appendChild(object.dom.stage2);
	
	// Add our stage 2 number
	object.dom.number = document.createElement('div');
	$ui.addClass(object.dom.number,'number');
	object.dom.stage2.appendChild(object.dom.number);
	object.dom.number.textContent = '3';
	
	// Private function to handle count down
	object._countDownInterval = function(value) {
		this._countDownNum--;
		if (this._countDownNum === 0) {
			window.clearInterval(this._interval);
			this._interval = undefined;
			this.dom.number.textContent = 'GO!';
			$ui.addClass(this.dom.number, 'theme-brand-background-color');
			$ui.addClass(this.dom.number,'animation');
			this._protected.recording = true;
			// Fire the onrecord event
			if (this.onrecord) {
				this.onrecord();
			}
			return;
		}
		this.dom.number.textContent = this._countDownNum;
		if (this.oncountdown) {
			this.oncountdown();
		}
	}.$bind(object);
	
	// Private function to handle stop pulse
	object._pulseInterval = function(value) {
		if (this._protected.borderVisible == true) {
			$ui.removeClass(this.dom.recordButton, 'theme-brand-border-color');
		} else {
			$ui.addClass(this.dom.recordButton, 'theme-brand-border-color');
		}
		this._protected.borderVisible = !this._protected.borderVisible;
	}.$bind(object);
	
	// Private function to handle clean-up
	object._providerUpdate = function(value) {
		if (this._interval != undefined) {
			window.clearInterval(this._interval);
			this._interval = undefined;
		}
	}.$bind(object);
	
	/**
	* Reset the tile to its original state
	* @function reset
	* @memberof $ui.TileRecord
	*/
	object.reset = function() {
		this._protected.recording = false;
		if (this._interval != undefined) {
			window.clearInterval(this._interval);
			this._interval = undefined;
		}
		this.dom.number.style.backgroundColor = '';
		this.dom.number.textContent = '3';
		$ui.removeClass(this.dom.number,'animation');
		this.dom.stage2.style.display = 'none';
		this.dom.stage1.style.display = '';
		this.dom.recordButton.textContent = 'Start';
		$ui.removeClass(this.dom.recordButton, 'theme-screen-background-color');
		$ui.addClass(this.dom.recordButton, 'theme-brand-background-color');
		$ui.addClass(this.dom.recordButton, 'theme-brand-border-color');
		
	}.$bind(object);
	
	return object.dom;
}

/**
 * The Time donut tile represents how close you reach a target number goal
 * <br><br><b>Sample Declaration</b>
 * <pre>
 * {
 *    component: $ui.TileTimeDonut,
 *    value: 3.8,
 *    target: 4.2,
 *    accent: 'Your Best Time'
 * }
 * </pre>
 * @namespace TileTimeDonut
 * @memberof $ui
 * @extends $ui.CoreTileDonutChart
 * @property {number} [value] - This number value represents the actual time achieved
 * @property {number} [target] - This number value represents the target time the driver is hoping to achieve.
 * @property {string} [caption] - This optional string value represents the text to appear to the left of the displayed value
 * @property {string} [accent] - This optional string value represents any extra accent text to display on the tile
 * @property {boolean} [targetHigh=false] - By default the time tile will compare the value to the target where the target is expected to be lower than the value.  By setting <b>targetHigh</b> to true, it will consider the target as higher than value.
 */
function $ui_TileTimeDonut(object, screen) {
	object._size = undefined;
	$ui_CoreTileDonutChart.call(this, object, screen);
	$ui.addClass(object.dom,'ui-tile-time-donut');
	
	// targetHigh Property
	if (object.targetHigh != true) {
		object.targetHigh = false;
	}
	object._protected.targetHigh = object.targetHigh;
	Object.defineProperty(object, 'targetHigh', {
		get: function() {return this._protected.targetHigh;},
		set: function() {
			console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','targetHigh'));
		},
		configurable: false}
	);
	
	// Figure out the data array for this chart
	object._calculateData = function() {
		var data;
		if (this.target != undefined && this.value != undefined) {
			var colorValue,
				percent;
			// Check for errors in data
			if (this.value < 0) this.value = 0;
			if (this.targetHigh == true) {
				if (this.value > this.target) {
					percent = 100;	
				} else {
					percent = Math.ceil((this.value / this.target)*100);
				}
			} else {
				if (this.value < this.target) {
					percent = 100;	
				} else {
					percent = Math.ceil((this.target / this.value)*100);
				}
			}			
			// Determine Color
			switch (true) {
				case (percent > 90):
					colorValue = $ui.theme.chart.color_GREAT;
					break;
				case (percent > 50):
					colorValue = $ui.theme.chart.color_GOOD;
					break;
				default:
					colorValue = $ui.theme.chart.color_OK;
					break;
			}
			// Create our chart data object
			data = [
				{
					value: percent,
					color: colorValue,
				},
				{
					value: (100-percent),
					color: $ui.theme.chart.color
				}
			];	
		} 
		return data;
	}
	object._calculateData = object._calculateData.$bind(object);
	

	// Private function to handle provider updates
	object._providerUpdate = function(value) {
		if (value != undefined) {
			this.value = value.value;
			this.target = value.target;
			this.accent = value.accent;
			this.caption = (value.caption == undefined) ? '' : value.caption;
		} else {
			this.value = 0;
			this.target = 0;
			this.accent = undefined;
			this.caption = '';
		}
		// Populate our chart with data
		var data = this._calculateData();
		if (data != undefined) {
			this._setData(data);
			this._setCaption('<span class="tall">'+this.value + '</span>&nbsp;'+ this.caption);
			this._setAccent(this.accent);
		}
		this.showContent(true);
	}.$bind(object);	
	
	// Handle theme changes
	object._onthemechange = function() {
		// Repaint the control
		this._providerUpdate(this);
	}.$bind(object);
	
	// Load our control if no provider is connected
	if (object.provider == undefined) {
		object._providerUpdate(object);
	}
	
	return object.dom;
}
/**
 * The Time History tile represents past recorded times.
 * <br><br><b>Sample Declaration</b>
 * <pre>
 * {
 *    component: $ui.TileTimeHistory,
 *    labels: ['Apr 10/14','May 12/14','Jul 18/14','Aug 22/14'],
 *    data: [5.2,6.3,4.2,4.5],
 *    caption: 'Recorded 0-60 times (sec)'
 * }
 * </pre>
 * @namespace TileTimeHistory
 * @memberof $ui
 * @extends $ui.CoreTile
 * @property {number[]} [data] - This array of numbers represents the time values
 * @property {string[]} [labels] - This array of strings represents the labels for the times. These labels are typically logging dates.
 * @property {string} [caption] - This optional string value represents the text caption you wish to include
 */
function $ui_TileTimeHistory(object, screen) {
	// Set our default animation
	if (object.animated == undefined) {
		object.animated = true;
	}
	// This tile is 2 x 1
	object._size = $ui.TileSize.WIDE;
	$ui_CoreTile.call(this, object, screen);
	$ui.addClass(object.dom,'ui-tile-time-history');
	
	// Create the caption area
	object.dom.caption = document.createElement('div');
	$ui.addClass(object.dom.caption,'caption');
	object.dom.contentDiv.appendChild(object.dom.caption);
	
	// Create our chart area
	object.dom.canvas = document.createElement('canvas');
	$ui.addClass(object.dom.canvas, 'chart');
	object.dom.canvas.height = 190;
	//object.dom.canvas.width = 490;
	object.dom.contentDiv.appendChild(object.dom.canvas);
	
	// Private function to handle provider updates
	object._providerUpdate = function(value) {
		if (this.dom.offsetWidth) {
			this.dom.canvas.width = this.dom.offsetWidth - 10;
			this.dom.ctx = this.dom.canvas.getContext('2d');
			this.dom.chart = new Chart(this.dom.ctx);
		}
		if (this.dom.chart == undefined) return;
		// Assign our values
		if (value != undefined) {
			this.data = value.data;
			this.labels = value.labels
			this.caption = (value.caption == undefined) ? '' : value.caption;
		} else {
			this.data = undefined;
			this.labels = undefined;
		}
		this.dom.caption.textContent = this.caption;
		// Get our root color
		var RGB = $ui.hexToRgb($ui.theme.chart.color_OK);
		// Load our data
		var data = {
			labels: this.labels,
			datasets: [
				{
					fillColor: 'rgba('+RGB.R+','+RGB.G+','+RGB.B+',0.5)',
					strokeColor: 'rgba('+RGB.R+','+RGB.G+','+RGB.B+',1)',
					data: this.data
				}
			]
		}
		this.dom.chart.Line(data,{scaleShowGridLines: true,showTooltips: false, animation: this.animated, scaleFontColor: window.getComputedStyle(this.dom).color});
		this.showContent(true);
	}.$bind(object);	
	
	// Handle theme changes
	object._onthemechange = function() {
		// Repaint the control
		this._providerUpdate(this);
	}.$bind(object);
	
	// Load our control if no provider is connected
	object._onshow = function() {
		if (this.provider == undefined) {
			this._providerUpdate(this);
		}
	}
	
	return object.dom;
}
/**
 * The Timer tile provides a stop watch timer. <b>NOTE: Currently there is a 60 minute limit for the timer</b>
 * <br><br><b>Sample Declaration</b>
 * <pre>
 * {
 *    component: $ui.TileTimer
 * }
 * </pre>
 * @namespace TileTimer
 * @memberof $ui
 * @extends $ui.CoreTile
 * @property {GenericEvent} [onstart] - This event fires when the timer starts
 * @property {GenericEvent} [onstop] - This event fires when the timer stops
 * @property {GenericEvent} [onreset] - This event fires when the timer has been reset
 */
function $ui_TileTimer(object, screen) {
	// This tile is 1 x 2
	object._size = $ui.TileSize.WIDE;
	$ui_CoreTile.call(this, object, screen);
	$ui.addClass(object.dom,'ui-tile-timer');
	
	// Add our numbers area
	object.dom.numbers = document.createElement('div');
	$ui.addClass(object.dom.numbers,'numbers');
	object.dom.contentDiv.appendChild(object.dom.numbers);
	object.dom.numbers.textContent = '00:00:00';
	
	// Private function to handle the interval
	object._doInterval = function() {
		var now = new Date();
		this._milliseconds = now - this._startTime;
		var minutes = Math.floor(this._milliseconds/60000),
			seconds = Math.floor(this._milliseconds/1000) % 60,
			tenths;
		// Calculate our tenths
		tenths = (this._milliseconds/1000).toFixed(2) - Math.floor(this._milliseconds/1000);
		tenths = Math.floor(tenths * 100);	
		tenths = (tenths >= 100) ? 0 : tenths;
		// Format leading zeros
		minutes = (minutes >= 10) ? minutes : '0'+ minutes;
		seconds = (seconds >= 10) ? seconds : '0'+ seconds;
		tenths = (tenths >= 10) ? tenths : '0'+ tenths;
		// Set our text
		object.dom.numbers.textContent = minutes + ':'+seconds+':'+tenths;	
	}.$bind(object);
	
	/**
	* This function will reset the timer and trigger the <b>onreset</b> event
	* @function reset
	* @memberof $ui.TileTimer
	*/
	object.reset = function() {
		if (this._interval != undefined) {
			window.clearInterval(this._interval);
			this._milliseconds = 0;
			this._interval = undefined;
		}
		this.dom.numbers.textContent = '00:00:00';
		if (this.onreset) {
			this.onreset();
		}
	}.$bind(object);
	
	/**
	* This function will start the timer and trigger the <b>onstart</b> event
	* @function start
	* @memberof $ui.TileTimer
	*/
	object.start = function() {
		if (this._interval != undefined) return; // Already running
		this._startTime = new Date();
		this._milliseconds = 0;
		this._interval = window.setInterval(this._doInterval,10);
		if (this.onstart) {
			this.onstart();
		}
	}.$bind(object);
	
	/**
	* This function will stop the timer and trigger the <b>onstop</b> event
	* @function stop
	* @memberof $ui.TileTimer
	*/
	object.stop = function() {
		if (this._interval != undefined) {
			window.clearInterval(this._interval);
			this._doInterval();
			this._interval = undefined;
			if (this.onstop) {
				this.onstop();
			}
		}
	}.$bind(object);
	
	/**
	* Retrieve the timer's value in Milliseconds
	* @function getMilliseconds
	* @memberof $ui.TileTimer
	*/
	object.getMilliseconds = function() {
		return this._milliseconds;
	}.$bind(object);
	
	/**
	* Retrieve the timer's value in Seconds
	* @function getSeconds
	* @memberof $ui.TileTimer
	*/
	object.getSeconds = function() {
		return (this._milliseconds/1000).toFixed(2);
	}.$bind(object);
	
	/**
	* Retrieve the timer's value in Minutes
	* @function getMinutes
	* @memberof $ui.TileTimer
	*/
	object.getMinutes = function() {
		return (this._milliseconds/60000).toFixed(2);
	}.$bind(object);
	
	// Private function to clean up
	object._destroy = function() {
		if (this._interval != undefined) {
			window.clearInterval(this._interval);
			this._interval = undefined;
		}
	}.$bind(object);
	
	// Stop the timer if the screen is about to pop
	object._onbeforepop = function() {
		this.stop();
	}.$bind(object);
	
	return object.dom;
}

/**
 * This function will provide a temporary pop up message to display to the user 
 * @function toast
 * @memberof $ui
 * @param {string} message - The message to display to the user
 * @param {number} [duration=2500] - Optional parameter to specify the duration of the toast
 */
$ui.toast = function(message, duration){
	var element = document.createElement('div');
	$ui.addClass(element,'ui-toast theme-brand-border-color');
	element.textContent = message;
	document.body.appendChild(element);
	// Set our default
	if (duration == undefined) {
		duration = 2500;
	}
	
	// Handle the end of the toast and do our clean-up
	element._ondisappear = function() {
		this.removeEventListener('webkitAnimationEnd', this._ondisappear);
		this.parentNode.removeChild(this);
	}.$bind(element);
	
	// Handle the showing of the toast
	element._onappear = function() {
		this.removeEventListener('webkitAnimationEnd', this._onappear);
		this.addEventListener('webkitAnimationEnd', this._ondisappear);
		var target = this;
		window.setTimeout(function() {
			target.style['-webkit-animation-name'] = 'ui-toast-disappear';
		},duration);
	}.$bind(element);
	
	element.addEventListener('webkitAnimationEnd', element._onappear);
}
var $emulator = {
	_panThreshold: 30,
	
	// Initialize the emulator
	_extend: function() {
		// Register our custom controls/screens
		
		var def = {
			/**
			 * Settings for Fans for a {@link $ui.FansButton}  
			 * @namespace Fans
			 * @readonly
			 * @memberof $ui.HeadUnitChrome
			 */
			Fans: {
				/** Automatic fans
				* @memberof $ui.HeadUnitChrome.Fans
				*/
				AUTO: 0
			}
		}
		$ui.addExtension(new UIExtension('HeadUnitChrome',emulator_HeadUnitChrome, $ui.UIExtensionType.SCREEN, def));
		
		def = {
			/**
			 * Direction of a {@link $ui.WedgeNumber} Screen 
			 * @namespace Direction
			 * @readonly
			 * @memberof $ui.WedgeNumber
			 */
			Direction: {
				/** Appear from the left 
				* @memberof $ui.WedgeNumber.Direction
				*/
				LEFT: 'left',
				/** Appear from the right  
				* @memberof $ui.WedgeNumber.Direction
				*/
				RIGHT: 'right'
			}
		}
		$ui.addExtension(new UIExtension('WedgeNumber',emulator_WedgeNumber, $ui.UIExtensionType.SCREEN,def));
		
		$ui.addExtension(new UIExtension('AppContainer', emulator_AppContainer, $ui.UIExtensionType.SCREEN));
		$ui.addExtension(new UIExtension('PopupHvac',emulator_PopupHvac, $ui.UIExtensionType.SCREEN));
		$ui.addExtension(new UIExtension('FanSpeedControl', emulator_FanSpeedControl));
		$ui.addExtension(new UIExtension('FanDirectionControl', emulator_FanDirectionControl));
		$ui.addExtension(new UIExtension('ChromeApp', emulator_ChromeApp, $ui.UIExtensionType.SCREEN));
		$ui.addExtension(new UIExtension('ActiveCallScreen', emulator_ActiveCallScreen, $ui.UIExtensionType.SCREEN));	
	}
}

$ui.extend($emulator._extend);

/**
 * DataEvent class allows you to create an event that can be passed over the global event handler.
 * @class DataEvent
 * @memberof $ui
 * @param {number} id - Identifier for the event being raised
 * @param {object} data - The data to be passed with the event
 */
$ui.DataEvent = function(id, data) {
	/**
	* Numeric identifier for the event 
	* @name id
	* @type {number}
	* @memberof $ui.DataEvent
	*/
	if (id == undefined || id == null) throw 'DataEvent - The identifier "id" must be supplied';
	this.id = id;
	/**
	* Data payload for the event 
	* @name data
	* @type {object}
	* @memberof $ui.DataEvent
	*/
	this.data = data;
}

/**
 * The callback signature for the <i>addEventListner</i> function from {@link $ui}
 * @callback TriggeredEvent
 * @param {$ui.DataEvent} event - The event which was just received
 */
/**
 * @preserve FastClick: polyfill to remove click delays on browsers with touch UIs.
 *
 * @version 1.0.0
 * @codingstandard ftlabs-jsv2
 * @copyright The Financial Times Limited [All Rights Reserved]
 * @license MIT License (see LICENSE.txt)
 */

/*jslint browser:true, node:true*/
/*global define, Event, Node*/


/**
 * Instantiate fast-clicking listeners on the specificed layer.
 *
 * @constructor
 * @param {Element} layer The layer to listen on
 * @param {Object} options The options to override the defaults
 */
function FastClick(layer, options) {
	'use strict';
	var oldOnClick;

	options = options || {};

	/**
	 * Whether a click is currently being tracked.
	 *
	 * @type boolean
	 */
	this.trackingClick = false;


	/**
	 * Timestamp for when click tracking started.
	 *
	 * @type number
	 */
	this.trackingClickStart = 0;


	/**
	 * The element being tracked for a click.
	 *
	 * @type EventTarget
	 */
	this.targetElement = null;


	/**
	 * X-coordinate of touch start event.
	 *
	 * @type number
	 */
	this.touchStartX = 0;


	/**
	 * Y-coordinate of touch start event.
	 *
	 * @type number
	 */
	this.touchStartY = 0;


	/**
	 * ID of the last touch, retrieved from Touch.identifier.
	 *
	 * @type number
	 */
	this.lastTouchIdentifier = 0;


	/**
	 * Touchmove boundary, beyond which a click will be cancelled.
	 *
	 * @type number
	 */
	this.touchBoundary = options.touchBoundary || 10;


	/**
	 * The FastClick layer.
	 *
	 * @type Element
	 */
	this.layer = layer;
	
	/**
	 * The minimum time between tap(touchstart and touchend) events
	 * 
	 * @type number
	 */
	this.tapDelay = options.tapDelay || 200;

	if (FastClick.notNeeded(layer)) {
		return;
	}

	// Some old versions of Android don't have Function.prototype.bind
	function bind(method, context) {
		return function() { return method.apply(context, arguments); };
	}

	// Set up event handlers as required
	if (deviceIsAndroid) {
		layer.addEventListener('mouseover', bind(this.onMouse, this), true);
		layer.addEventListener('mousedown', bind(this.onMouse, this), true);
		layer.addEventListener('mouseup', bind(this.onMouse, this), true);
	}

	layer.addEventListener('click', bind(this.onClick, this), true);
	layer.addEventListener('touchstart', bind(this.onTouchStart, this), false);
	layer.addEventListener('touchmove', bind(this.onTouchMove, this), false);
	layer.addEventListener('touchend', bind(this.onTouchEnd, this), false);
	layer.addEventListener('touchcancel', bind(this.onTouchCancel, this), false);

	// Hack is required for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
	// which is how FastClick normally stops click events bubbling to callbacks registered on the FastClick
	// layer when they are cancelled.
	if (!Event.prototype.stopImmediatePropagation) {
		layer.removeEventListener = function(type, callback, capture) {
			var rmv = Node.prototype.removeEventListener;
			if (type === 'click') {
				rmv.call(layer, type, callback.hijacked || callback, capture);
			} else {
				rmv.call(layer, type, callback, capture);
			}
		};

		layer.addEventListener = function(type, callback, capture) {
			var adv = Node.prototype.addEventListener;
			if (type === 'click') {
				adv.call(layer, type, callback.hijacked || (callback.hijacked = function(event) {
					if (!event.propagationStopped) {
						callback(event);
					}
				}), capture);
			} else {
				adv.call(layer, type, callback, capture);
			}
		};
	}

	// If a handler is already declared in the element's onclick attribute, it will be fired before
	// FastClick's onClick handler. Fix this by pulling out the user-defined handler function and
	// adding it as listener.
	if (typeof layer.onclick === 'function') {

		// Android browser on at least 3.2 requires a new reference to the function in layer.onclick
		// - the old one won't work if passed to addEventListener directly.
		oldOnClick = layer.onclick;
		layer.addEventListener('click', function(event) {
			oldOnClick(event);
		}, false);
		layer.onclick = null;
	}
}


/**
 * Android requires exceptions.
 *
 * @type boolean
 */
var deviceIsAndroid = navigator.userAgent.indexOf('Android') > 0;


/**
 * iOS requires exceptions.
 *
 * @type boolean
 */
var deviceIsIOS = /iP(ad|hone|od)/.test(navigator.userAgent);


/**
 * iOS 4 requires an exception for select elements.
 *
 * @type boolean
 */
var deviceIsIOS4 = deviceIsIOS && (/OS 4_\d(_\d)?/).test(navigator.userAgent);


/**
 * iOS 6.0(+?) requires the target element to be manually derived
 *
 * @type boolean
 */
var deviceIsIOSWithBadTarget = deviceIsIOS && (/OS ([6-9]|\d{2})_\d/).test(navigator.userAgent);


/**
 * Determine whether a given element requires a native click.
 *
 * @param {EventTarget|Element} target Target DOM element
 * @returns {boolean} Returns true if the element needs a native click
 */
FastClick.prototype.needsClick = function(target) {
	'use strict';
	switch (target.nodeName.toLowerCase()) {

	// Don't send a synthetic click to disabled inputs (issue #62)
	case 'button':
	case 'select':
	case 'textarea':
		if (target.disabled) {
			return true;
		}

		break;
	case 'input':

		// File inputs need real clicks on iOS 6 due to a browser bug (issue #68)
		if ((deviceIsIOS && target.type === 'file') || target.disabled) {
			return true;
		}

		break;
	case 'label':
	case 'video':
		return true;
	}

	return (/\bneedsclick\b/).test(target.className);
};


/**
 * Determine whether a given element requires a call to focus to simulate click into element.
 *
 * @param {EventTarget|Element} target Target DOM element
 * @returns {boolean} Returns true if the element requires a call to focus to simulate native click.
 */
FastClick.prototype.needsFocus = function(target) {
	'use strict';
	switch (target.nodeName.toLowerCase()) {
	case 'textarea':
		return true;
	case 'select':
		return !deviceIsAndroid;
	case 'input':
		switch (target.type) {
		case 'button':
		case 'checkbox':
		case 'file':
		case 'image':
		case 'radio':
		case 'submit':
			return false;
		}

		// No point in attempting to focus disabled inputs
		return !target.disabled && !target.readOnly;
	default:
		return (/\bneedsfocus\b/).test(target.className);
	}
};


/**
 * Send a click event to the specified element.
 *
 * @param {EventTarget|Element} targetElement
 * @param {Event} event
 */
FastClick.prototype.sendClick = function(targetElement, event) {
	'use strict';
	var clickEvent, touch;

	// On some Android devices activeElement needs to be blurred otherwise the synthetic click will have no effect (#24)
	if (document.activeElement && document.activeElement !== targetElement) {
		document.activeElement.blur();
	}

	touch = event.changedTouches[0];

	// Synthesise a click event, with an extra attribute so it can be tracked
	clickEvent = document.createEvent('MouseEvents');
	clickEvent.initMouseEvent(this.determineEventType(targetElement), true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null);
	clickEvent.forwardedTouchEvent = true;
	targetElement.dispatchEvent(clickEvent);
};

FastClick.prototype.determineEventType = function(targetElement) {
	'use strict';

	//Issue #159: Android Chrome Select Box does not open with a synthetic click event
	if (deviceIsAndroid && targetElement.tagName.toLowerCase() === 'select') {
		return 'mousedown';
	}

	return 'click';
};


/**
 * @param {EventTarget|Element} targetElement
 */
FastClick.prototype.focus = function(targetElement) {
	'use strict';
	var length;

	// Issue #160: on iOS 7, some input elements (e.g. date datetime) throw a vague TypeError on setSelectionRange. These elements don't have an integer value for the selectionStart and selectionEnd properties, but unfortunately that can't be used for detection because accessing the properties also throws a TypeError. Just check the type instead. Filed as Apple bug #15122724.
	if (deviceIsIOS && targetElement.setSelectionRange && targetElement.type.indexOf('date') !== 0 && targetElement.type !== 'time') {
		length = targetElement.value.length;
		targetElement.setSelectionRange(length, length);
	} else {
		targetElement.focus();
	}
};


/**
 * Check whether the given target element is a child of a scrollable layer and if so, set a flag on it.
 *
 * @param {EventTarget|Element} targetElement
 */
FastClick.prototype.updateScrollParent = function(targetElement) {
	'use strict';
	var scrollParent, parentElement;

	scrollParent = targetElement.fastClickScrollParent;

	// Attempt to discover whether the target element is contained within a scrollable layer. Re-check if the
	// target element was moved to another parent.
	if (!scrollParent || !scrollParent.contains(targetElement)) {
		parentElement = targetElement;
		do {
			if (parentElement.scrollHeight > parentElement.offsetHeight) {
				scrollParent = parentElement;
				targetElement.fastClickScrollParent = parentElement;
				break;
			}

			parentElement = parentElement.parentElement;
		} while (parentElement);
	}

	// Always update the scroll top tracker if possible.
	if (scrollParent) {
		scrollParent.fastClickLastScrollTop = scrollParent.scrollTop;
	}
};


/**
 * @param {EventTarget} targetElement
 * @returns {Element|EventTarget}
 */
FastClick.prototype.getTargetElementFromEventTarget = function(eventTarget) {
	'use strict';

	// On some older browsers (notably Safari on iOS 4.1 - see issue #56) the event target may be a text node.
	if (eventTarget.nodeType === Node.TEXT_NODE) {
		return eventTarget.parentNode;
	}

	return eventTarget;
};


/**
 * On touch start, record the position and scroll offset.
 *
 * @param {Event} event
 * @returns {boolean}
 */
FastClick.prototype.onTouchStart = function(event) {
	'use strict';
	var targetElement, touch, selection;
	
	// Ignore multiple touches, otherwise pinch-to-zoom is prevented if both fingers are on the FastClick element (issue #111).
	if (event.targetTouches.length > 1) {
		return true;
	}

	targetElement = this.getTargetElementFromEventTarget(event.target);
	touch = event.targetTouches[0];

	
	
	if (deviceIsIOS) {

		// Only trusted events will deselect text on iOS (issue #49)
		selection = window.getSelection();
		if (selection.rangeCount && !selection.isCollapsed) {
			return true;
		}

		if (!deviceIsIOS4 && soloUI.isPhoneGap === true) {

			// Weird things happen on iOS when an alert or confirm dialog is opened from a click event callback (issue #23):
			// when the user next taps anywhere else on the page, new touchstart and touchend events are dispatched
			// with the same identifier as the touch event that previously triggered the click that triggered the alert.
			// Sadly, there is an issue on iOS 4 that causes some normal touch events to have the same identifier as an
			// immediately preceeding touch event (issue #52), so this fix is unavailable on that platform.
			if (touch.identifier === this.lastTouchIdentifier) {
				event.preventDefault();
				return false;
			}

			this.lastTouchIdentifier = touch.identifier;

			// If the target element is a child of a scrollable layer (using -webkit-overflow-scrolling: touch) and:
			// 1) the user does a fling scroll on the scrollable layer
			// 2) the user stops the fling scroll with another tap
			// then the event.target of the last 'touchend' event will be the element that was under the user's finger
			// when the fling scroll was started, causing FastClick to send a click event to that layer - unless a check
			// is made to ensure that a parent layer was not scrolled before sending a synthetic click (issue #42).
			this.updateScrollParent(targetElement);
		}
	}

	this.trackingClick = true;
	this.trackingClickStart = event.timeStamp;
	this.targetElement = targetElement;

	this.touchStartX = touch.pageX;
	this.touchStartY = touch.pageY;

	// Prevent phantom clicks on fast double-tap (issue #36)
	if ((event.timeStamp - this.lastClickTime) < this.tapDelay) {
		event.preventDefault();
	}
	
	return true;
};


/**
 * Based on a touchmove event object, check whether the touch has moved past a boundary since it started.
 *
 * @param {Event} event
 * @returns {boolean}
 */
FastClick.prototype.touchHasMoved = function(event) {
	'use strict';
	var touch = event.changedTouches[0], boundary = this.touchBoundary;

	if (Math.abs(touch.pageX - this.touchStartX) > boundary || Math.abs(touch.pageY - this.touchStartY) > boundary) {
		return true;
	}

	return false;
};


/**
 * Update the last position.
 *
 * @param {Event} event
 * @returns {boolean}
 */
FastClick.prototype.onTouchMove = function(event) {
	'use strict';
	
	if (!this.trackingClick) {
		return true;
	}

	// If the touch has moved, cancel the click tracking
	if (this.targetElement !== this.getTargetElementFromEventTarget(event.target) || this.touchHasMoved(event)) {
		this.trackingClick = false;
		this.targetElement = null;
	}
	
	
	
	return true;
};


/**
 * Attempt to find the labelled control for the given label element.
 *
 * @param {EventTarget|HTMLLabelElement} labelElement
 * @returns {Element|null}
 */
FastClick.prototype.findControl = function(labelElement) {
	'use strict';

	// Fast path for newer browsers supporting the HTML5 control attribute
	if (labelElement.control !== undefined) {
		return labelElement.control;
	}

	// All browsers under test that support touch events also support the HTML5 htmlFor attribute
	if (labelElement.htmlFor) {
		return document.getElementById(labelElement.htmlFor);
	}

	// If no for attribute exists, attempt to retrieve the first labellable descendant element
	// the list of which is defined here: http://www.w3.org/TR/html5/forms.html#category-label
	return labelElement.querySelector('button, input:not([type=hidden]), keygen, meter, output, progress, select, textarea');
};


/**
 * On touch end, determine whether to send a click event at once.
 *
 * @param {Event} event
 * @returns {boolean}
 */
FastClick.prototype.onTouchEnd = function(event) {
	'use strict';
	var forElement, trackingClickStart, targetTagName, scrollParent, touch, targetElement = this.targetElement;

	if (!this.trackingClick) {
		return true;
	}

	// Prevent phantom clicks on fast double-tap (issue #36)
	if ((event.timeStamp - this.lastClickTime) < this.tapDelay) {
		this.cancelNextClick = true;
		return true;
	}

	// Reset to prevent wrong click cancel on input (issue #156).
	this.cancelNextClick = false;

	this.lastClickTime = event.timeStamp;

	trackingClickStart = this.trackingClickStart;
	this.trackingClick = false;
	this.trackingClickStart = 0;

	
	// On some iOS devices, the targetElement supplied with the event is invalid if the layer
	// is performing a transition or scroll, and has to be re-detected manually. Note that
	// for this to function correctly, it must be called *after* the event target is checked!
	// See issue #57; also filed as rdar://13048589 .
	if (deviceIsIOSWithBadTarget) {
		touch = event.changedTouches[0];
		// In certain cases arguments of elementFromPoint can be negative, so prevent setting targetElement to null
		targetElement = document.elementFromPoint(touch.pageX - window.pageXOffset, touch.pageY - window.pageYOffset) || targetElement;
		targetElement.fastClickScrollParent = this.targetElement.fastClickScrollParent;
	}

	targetTagName = targetElement.tagName.toLowerCase();
	if (targetTagName === 'label') {
		forElement = this.findControl(targetElement);
		if (forElement) {
			this.focus(targetElement);
			if (deviceIsAndroid) {
				return false;
			}

			targetElement = forElement;
		}
	} else if (this.needsFocus(targetElement)) {

		// Case 1: If the touch started a while ago (best guess is 100ms based on tests for issue #36) then focus will be triggered anyway. Return early and unset the target element reference so that the subsequent click will be allowed through.
		// Case 2: Without this exception for input elements tapped when the document is contained in an iframe, then any inputted text won't be visible even though the value attribute is updated as the user types (issue #37).
		if ((event.timeStamp - trackingClickStart) > 100 || (deviceIsIOS && window.top !== window && targetTagName === 'input')) {
			this.targetElement = null;
			return false;
		}

		this.focus(targetElement);
		this.sendClick(targetElement, event);

		// Select elements need the event to go through on iOS 4, otherwise the selector menu won't open.
		if (!deviceIsIOS4 || targetTagName !== 'select') {
			this.targetElement = null;
			event.preventDefault();
		}

		return false;
	}

	if (deviceIsIOS && !deviceIsIOS4) {

		// Don't send a synthetic click event if the target element is contained within a parent layer that was scrolled
		// and this tap is being used to stop the scrolling (usually initiated by a fling - issue #42).
		scrollParent = targetElement.fastClickScrollParent;
		if (scrollParent && scrollParent.fastClickLastScrollTop !== scrollParent.scrollTop) {
			return true;
		}
	}
	

	// Prevent the actual click from going though - unless the target node is marked as requiring
	// real clicks or if it is in the whitelist in which case only non-programmatic clicks are permitted.
	if (!this.needsClick(targetElement)) {
		event.preventDefault();
		this.sendClick(targetElement, event);
	}

	return false;
};


/**
 * On touch cancel, stop tracking the click.
 *
 * @returns {void}
 */
FastClick.prototype.onTouchCancel = function() {
	'use strict';
	
	this.trackingClick = false;
	this.targetElement = null;
};


/**
 * Determine mouse events which should be permitted.
 *
 * @param {Event} event
 * @returns {boolean}
 */
FastClick.prototype.onMouse = function(event) {
	'use strict';

	// If a target element was never set (because a touch event was never fired) allow the event
	if (!this.targetElement) {
		return true;
	}

	if (event.forwardedTouchEvent) {
		return true;
	}

	// Programmatically generated events targeting a specific element should be permitted
	if (!event.cancelable) {
		return true;
	}

	// Derive and check the target element to see whether the mouse event needs to be permitted;
	// unless explicitly enabled, prevent non-touch click events from triggering actions,
	// to prevent ghost/doubleclicks.
	if (!this.needsClick(this.targetElement) || this.cancelNextClick) {

		// Prevent any user-added listeners declared on FastClick element from being fired.
		if (event.stopImmediatePropagation) {
			event.stopImmediatePropagation();
		} else {

			// Part of the hack for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
			event.propagationStopped = true;
		}

		// Cancel the event
		event.stopPropagation();
		event.preventDefault();

		return false;
	}

	// If the mouse event is permitted, return true for the action to go through.
	return true;
};


/**
 * On actual clicks, determine whether this is a touch-generated click, a click action occurring
 * naturally after a delay after a touch (which needs to be cancelled to avoid duplication), or
 * an actual click which should be permitted.
 *
 * @param {Event} event
 * @returns {boolean}
 */
FastClick.prototype.onClick = function(event) {
	'use strict';
	var permitted;

	// It's possible for another FastClick-like library delivered with third-party code to fire a click event before FastClick does (issue #44). In that case, set the click-tracking flag back to false and return early. This will cause onTouchEnd to return early.
	if (this.trackingClick) {
		this.targetElement = null;
		this.trackingClick = false;
		return true;
	}

	// Very odd behaviour on iOS (issue #18): if a submit element is present inside a form and the user hits enter in the iOS simulator or clicks the Go button on the pop-up OS keyboard the a kind of 'fake' click event will be triggered with the submit-type input element as the target.
	if (event.target.type === 'submit' && event.detail === 0) {
		return true;
	}

	permitted = this.onMouse(event);

	// Only unset targetElement if the click is not permitted. This will ensure that the check for !targetElement in onMouse fails and the browser's click doesn't go through.
	if (!permitted) {
		this.targetElement = null;
	}

	// If clicks are permitted, return true for the action to go through.
	return permitted;
};


/**
 * Remove all FastClick's event listeners.
 *
 * @returns {void}
 */
FastClick.prototype.destroy = function() {
	'use strict';
	var layer = this.layer;

	if (deviceIsAndroid) {
		layer.removeEventListener('mouseover', this.onMouse, true);
		layer.removeEventListener('mousedown', this.onMouse, true);
		layer.removeEventListener('mouseup', this.onMouse, true);
	}

	layer.removeEventListener('click', this.onClick, true);
	layer.removeEventListener('touchstart', this.onTouchStart, false);
	layer.removeEventListener('touchmove', this.onTouchMove, false);
	layer.removeEventListener('touchend', this.onTouchEnd, false);
	layer.removeEventListener('touchcancel', this.onTouchCancel, false);
};


/**
 * Check whether FastClick is needed.
 *
 * @param {Element} layer The layer to listen on
 */
FastClick.notNeeded = function(layer) {
	'use strict';
	var metaViewport;
	var chromeVersion;

	// Devices that don't support touch don't need FastClick
	if (typeof window.ontouchstart === 'undefined') {
		return true;
	}

	// Chrome version - zero for other browsers
	chromeVersion = +(/Chrome\/([0-9]+)/.exec(navigator.userAgent) || [,0])[1];

	if (chromeVersion) {

		if (deviceIsAndroid) {
			metaViewport = document.querySelector('meta[name=viewport]');

			if (metaViewport) {
				// Chrome on Android with user-scalable="no" doesn't need FastClick (issue #89)
				if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
					return true;
				}
				// Chrome 32 and above with width=device-width or less don't need FastClick
				if (chromeVersion > 31 && window.innerWidth <= window.screen.width) {
					return true;
				}
			}

		// Chrome desktop doesn't need FastClick (issue #15)
		} else {
			return true;
		}
	}

	// IE10 with -ms-touch-action: none, which disables double-tap-to-zoom (issue #97)
	if (layer.style.msTouchAction === 'none') {
		return true;
	}

	return false;
};


/**
 * Factory method for creating a FastClick object
 *
 * @param {Element} layer The layer to listen on
 * @param {Object} options The options to override the defaults
 */
FastClick.attach = function(layer, options) {
	'use strict';
	return new FastClick(layer, options);
};


if (typeof define !== 'undefined' && define.amd) {

	// AMD. Register as an anonymous module.
	define(function() {
		'use strict';
		return FastClick;
	});
} else if (typeof module !== 'undefined' && module.exports) {
	module.exports = FastClick.attach;
	module.exports.FastClick = FastClick;
} else {
	window.FastClick = FastClick;
}
/**
 * Every component in the UI follows the same general patterns. This is to keep consistency and make coding easier.
 * <br><br><b>NOTE: The core component is an abstract base class and cannot be created as an instance on its own</b>
 * @namespace
 * @name CoreComponent
 * @memberof $ui
 * @property {namespace} component - The <b>mandatory</b> component property defines what type of component is being defined. This property always starts with a <b>$ui.</b> defining the component to be used for generating the UI.
 * @property {string} [id] - The id property is used to uniquely define the control in the screen for which it belongs. <br><br>Providing an id for your control is very convenient because you can easily access your control through your javascript coding. Each id is added as a direct handle on the screen object for access.
 * @property {boolean} [animated=false] - Set this value to <b>true</b> for the control to have animation.  NOTE: Each derivative control is responsible for their animation styling. Setting this property to true will add the ".animated" CSS class to the root element of the control.  Feel free to define your own CSS for the ".animated" property
 * @property {boolean} [visible=true] - The visible property specifies the visibility of the control. 
 * @property {boolean} [enabled=true] - The enabled property specifies the initial enabled state of the control.  <i>NOTE: Not all controls will render a disabled state. If you wish to render a disabled state simply override the ".disabled" CSS for the root of your control</i>
 * @property {$ui.CoreScreen} screen - This <b>readonly</b> property allows for you to reference the screen from the control. This will be the screen in which the control is embedded
 * @property {$ui.DataProviderLink} [provider] - This property allows you to bind the control to a [data provider]{@link $ui.DataProvider} in the application. 
 * @property {object[]} attachedObjects - This property specifies an array of objects that can be attached to the control. These could be objects such as data providers and usually entail a component that does not provide a user interface.
 * @property {boolean} [marginTop=false] - A boolean property which when set to true will place a standard margin on the top of the control. 
 * @property {boolean} [marginBottom=false] - A boolean property which when set to true will place a standard margin on the bottom of the control.
 * @property {boolean} [marginLeft=false] - A boolean property which when set to true will place a standard margin on the left of the control
 * @property {boolean} [marginRight=false] - A boolean property which when set to true will place a standard margin on the right of the control.
 */
function $ui_CoreComponent(object, screen) {
	try {
	if (object) {
		this.object = object;
		// The protected object is where we store our dynamic object variables
		object._protected = {
			model: object
		};
		
		// Create our base container for the control 
		object.dom = document.createElement('div');
		object.dom.model = object;
		$ui.addClass(object.dom, 'ui-core-component');
		
		// Assign our control name for automation & analytics
		if (object.id) {
			object.dom.setAttribute('data-id',object.id);
		}
		
		// Component Property
		object._protected.component = object.component;
		Object.defineProperty(object, 'component', {
			get: function() {return this._protected.component;},
			set: function() {
				console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','component'));
			},
			configurable: false} 
		);
		
		// Screen Property
		if (screen != undefined) {
			object.screen = screen;
			screen.children.push(object);
			if (object.id) {
        if (screen[object.id] != undefined) {
          var text = 'WARNING: You have used a non-unique id: "'+ object.id+'"';
          if (screen.id != undefined) {
            text = text + ' on screen "'+screen.id+'"';
          }
          console.log(text);
        }
				screen[object.id] = object;
			}
		}
		object._protected.screen = object.screen;
		Object.defineProperty(object, 'screen', {
			get: function() {return this._protected.screen;},
			set: function() {
				console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','screen'));
			},
			configurable: false}
		);
		
		// id property
		object._protected.id = object.id;
		Object.defineProperty(object, 'id', {
			get: function() {return this._protected.id;},
			set: function() {
				console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','id'));
			},
			configurable: false}
		);
		
		// Enabled Property
		if (object.enabled != false) {
			object.enabled = true;
		} else {
			$ui.addClass(object.dom, 'disabled');
		}
		object._protected.enabled = object.enabled;
		Object.defineProperty(object, 'enabled', {
			get: function() {return this._protected.enabled;},
			set: function(value) {
				if (value == this._protected.enabled) return;
				if (this._protected.enabled && (value == false)) {
					this._protected.enabled = false;
					$ui.addClass(this.dom, 'disabled');
				} else if ((this._protected.enabled == false) && (value == true)) {
					this._protected.enabled = true;
					$ui.removeClass(this.dom, 'disabled');
				}
				// Call a child class' protected function if they need
				// to do special handling for enabling
				if (this._setEnabled) {
					this._setEnabled(value);
				}
			},
			configurable: false}
		);		

		
		// Animated property
		if (object.animated == true) {
			$ui.addClass(object.dom, 'animated');
		} else {
			object.animated = false;
		}
		object._protected.animated = object.animated;
		Object.defineProperty(object, 'animated', {
			get: function() {return this._protected.animated;},
			set: function() {
				console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','animated'));
			},
			configurable: false}
		);
		
		// Set our initial visibility
		if ((object.visible != undefined) && (object.visible == false)) {
			object.dom.style.display = 'none';
		} else {
			object.visible = true;
		}
		object._protected.visible = object.visible;
		// Set our modification rules for 'visible'
		Object.defineProperty(object, 'visible', {
			get: function() {return this._protected.visible;},
			set: function(value) {
				if (value != this._protected.visible) {
					if (value == true) {
						this._protected.visible = true;
						if (this.dom != undefined) {
							this.dom.style.display = '';
						}
					} else {
						this._protected.visible = false;
						if (this.dom != undefined) {
							this.dom.style.display = 'none';
						}
					}
					// Allow of the top level control to also react to the visibility change
					if (this._setVisible) {
						this._setVisible(value);
					}
				} 
			},
			configurable: false}
		);
		
		// Attached Objects Property
		if (object.attachedObjects) {
			var i,
        j,
				control,
        extension,
				controlDom,
				targetScreen = (object.screen != undefined) ? object.screen : object; // The only control without a screen is a screen
			for (i = 0; i < object.attachedObjects.length; i++) {
				control = object.attachedObjects[i];
        if (control == undefined) {
    			throw 'CoreComponent.attachedObject: "control" is not defined';
    		} 
    		if (targetScreen == undefined) {
    			throw 'CoreComponent.attachedObject: "screen" is not defined';
    		}
    		// Find and create the attached object extension
    		for (j = 0; j < $ui._protected.definitions.length; j++) {
    			extension = $ui._protected.definitions[j];
    			if (extension.type != $ui.UIExtensionType.ATTACHED_OBJECT) continue;
    			if (extension.component == control.component) {
    				controlDom = new extension.constructor(control, object, targetScreen);
    				break;
    			}
    		}
				// If this control needs to be in the DOM add it
				if (controlDom instanceof HTMLElement) {
					object.dom.appendChild(controlDom);
				}
			}
		} else {
			object.attachedObjects = [];
		}
		object._protected.attachedObjects = object.attachedObjects;
		Object.defineProperty(object, 'attachedObjects', {
			get: function() {return this._protected.attachedObjects;},
			set: function(value) {
				console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','attachedObjects'));
			},
			configurable: false}
		);
		
		/** 
		 * This protected function will raise an interaction event for the <b>oninteraction</b> callback assigned to the {@link $ui} object.
		 * @memberof $ui.CoreComponent
		 * @protected 
		 * @function _raiseInteractionEvent
		 * @param {string} interaction - Desired interaction to raise
		 */
		object._raiseInteractionEvent = function(interaction) {
			var event = new InteractionEvent(this.screen.id, this.id, interaction, this.component);
			$ui._raiseInteractionEvent(event);
		}.$bind(object);
		
		
		// Private function to animate scrolling the control into view 
		object._scrollIntoView = function() {
			var step = 20,
				rect = this.dom.getBoundingClientRect(),
				scrollArea = this.dom.parentNode;
				
			this._scrollIterationCounter = this._scrollIterationCounter + 1;
			// See if it has reached the top of the screen
			if (rect.top == scrollArea.offsetTop) { 
				return;
			}
			
			// If the bottom and top of the control is visible
			if ((rect.bottom < (scrollArea.offsetTop + scrollArea.offsetHeight)) && (rect.top > scrollArea.offsetTop)) {
				return;
			}
				
			if (rect.top > scrollArea.offsetTop) { // Need to scroll down
				if (rect.top - scrollArea.offsetTop < step) {
					step = 1;
				}
				scrollArea.scrollTop = scrollArea.scrollTop + step;
			} else { // Need to scroll up
				if (scrollArea.offsetTop - rect.top < step) {
					step = 1;
				}
				scrollArea.scrollTop = scrollArea.scrollTop - step;
			}
			
			if (this._scrollIterationCounter > 100) { // Equivalent to moving something 2000 pixels
				console.log('fail safe scroll counter exceeded');
				return;
			}
			requestAnimationFrame(this._scrollIntoView);
		}.$bind(object);
		
		/** 
		 * This function will scroll the control into view for the user.
		 * @memberof $ui.CoreComponent
		 * @function scrollIntoView
		 */
		object.scrollIntoView = function() {
			if (this.dom) {
				this._scrollIterationCounter = 0;
				requestAnimationFrame(this._scrollIntoView);
			}
		}.$bind(object);
		
		// Public base destructor for the component
		object.destroy = function() {	
			// Call private destructor of control if it is there
			if (object._destroy) {
				object._destroy();
			}
			// Remove the provider listener
			if (this.provider != undefined) {
				if (this.provider.id != undefined) {
					window.removeEventListener(this.screen.guid+'-'+this.provider.id+'-updated', this._providerRefresh, false);
				}
			}	
      // Remove screen reference
      if (this.id != undefined && this.id.length > 0) {
				this.screen[this.id] = undefined;
			}
			// Clean-up any attached objects
			var i,
				attachedObject;
			if (this.attachedObjects && this.attachedObjects.length > 0) {
				for (i = 0; i < this.attachedObjects.length; i++) {
					attachedObject = this.attachedObjects[i];
					if (attachedObject._destroy) {
						attachedObject._destroy();
					}
				}
			}
			this.dom = undefined;
		}.$bind(object);
		
		// Handle a provider update
		object._providerRefresh = function() {
			// Find the data provider
			var dataProvider = this.screen[this.provider.id];
			if (dataProvider != undefined) {
				// Make sure it has some data assigned to it
				if (dataProvider.data != undefined) {
					var properties = this.provider.property.split('.'),
						i,
						data = dataProvider.data,
						found = true;
					// traverse it's hierarchy for our data value	
					for (i = 0; i < properties.length; i++) {
						data = data[properties[i]];
						if (data == undefined) {
							found = false;
							break;
						}
					}
					if (found) {
						if (this._providerUpdate) {
							this._providerUpdate(data);
						}
						return;
					} else {
						if (this._providerUpdate) {
							this._providerUpdate(undefined);
						}
					}
				} else {
					// If there was data we would not reach this point other wise it is undefined
					// so we have to check to see if it is an initial load so that we don't trigger 
					// the control's update unnecessarily 
					if (this._providerUpdate) {
						this._providerUpdate(undefined);
					}
				}
			} 
		}.$bind(object);
		
		
    // This function will remove the control from the screen
    object._remove = function() {
      if (this._onremove) {
        this._onremove();
      }
      // Remove node
      if (this.dom && this.dom.parentNode) {
        this.dom.parentNode.removeChild(this.dom);
      }
      if (this.screen) {
        var index = this.screen.children.indexOf(this);
        if (index >= 0) {
          this.screen.children.splice(index, 1);
        }
      }
      this.destroy();
    }.$bind(object);
    
		// This function will update the provider data source with new data from the control
		object._updateData = function(value) {
			// Find the data provider
			var dataProvider = (this.provider == undefined) ? undefined : this.screen[this.provider.id];
			if (dataProvider != undefined) {
				// Mark the property as updated
				dataProvider._propertyUpdated(this.provider.property, value);
				// Make sure it has some data assigned to it
				if (dataProvider.data != undefined) {
					var properties = this.provider.property.split('.'),
						i,
						data = dataProvider.data,
						currentValue;
					// traverse it's hierarchy for our data value	
					for (i = 0; i < properties.length; i++) {
						currentValue = data[properties[i]];
						if ((currentValue == undefined) && (i < (properties.length -1))) {
							break;
						} else if (i == (properties.length -1)) {
							data[properties[i]] = value;
							break;
						}
						data = currentValue;
					}
				}
			}
		}.$bind(object);
		
		// Data Provider Property
		if (object.provider != undefined) {
			if (object.provider.id != undefined) {
				// unique event listener for this provider on this screen
				window.addEventListener(object.screen.guid+'-'+object.provider.id+'-updated', object._providerRefresh, false);
				// Evaluate our bindings 
				object._providerRefresh();
			}
		}
		object._protected.provider = object.provider;
		Object.defineProperty(object, 'provider', {
			get: function() {return this._protected.provider;},
			set: function(value) {
				console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','provider'));
			},
			configurable: false}
		);
	}
	} catch (error) {
		console.log("RPW error in core component: " + error);
	}
}

/** 
 * The function assigned to this member will fire when the component has been asked to be removed from its parent. This is an <b>internal protected</b> member to be used by derivative controls and should not be bound to by application code
 * @name _onremove
 * @memberof $ui.CoreComponent
 * @protected
 * @type {function} 
 */

/** 
 * The function assigned to this member will fire when the screen the component belongs to receives an onshow event. This is an <b>internal protected</b> member to be used by derivative controls and should not be bound to by application code
 * @name _onshow
 * @memberof $ui.CoreComponent
 * @protected
 * @type {function} 
 */
 
 /** 
 * The function assigned to this member will fire when the toolkit has updated its theme. This is an <b>internal protected</b> member to be used by derivative controls and should not be bound to by application code
 * @name _onthemechange
 * @memberof $ui.CoreComponent
 * @protected
 * @type {function} 
 */

 
/** 
 * The function assigned to this member will fire when the screen that the component belongs to has it's viewport size changed. This is an <b>internal protected</b> member to be used by derivative controls and should not be bound to by application code
 * @name _onresize
 * @memberof $ui.CoreComponent
 * @protected
 * @type {function} 
 */

/** 
 * The function assigned to this member will fire when the screen that the component belongs to is just about to be popped. This will only fire if the screen is the top most screen in the stack. It allows for any clean-up that might need to be done before animating. This is an <b>internal protected</b> member to be used by derivative controls and should not be bound to by application code
 * @name _onbeforepop
 * @memberof $ui.CoreComponent
 * @protected
 * @type {function} 
 */

/**
 * This is the abstract base class that represents a component instance which contains other components. It derives from {@link $ui.CoreComponent}. 
 * <br><br><b>NOTE: This is an abstract class </b>
 * @namespace
 * @name CoreContainerComponent
 * @memberof $ui
 * @extends $ui.CoreComponent 
 * @property {boolean} [modified] - This property will cascade the <b>modified</b> value to all child controls contained in the control group <b>IF</b> the value is false.  Otherwise it will simply mark itself as modified.
 */
function $ui_CoreContainerComponent(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	if (object) {
		
		/**
		* Protected internal function for derivative controls to implement to return the control list array
		* @function _getControlListProperty
		* @memberof $ui.CoreContainerComponent
		* @returns {$ui.CoreComponent[]}
		* @protected
		*/
		
		/**
		* Protected internal function for derivative controls to implement to return the DOM element that contains the controls
		* @function _getControlListDom
		* @memberof $ui.CoreContainerComponent
		* @returns {HTMLElement}
		* @protected
		*/
		
		/**
		* Protected internal function for derivative controls to implement to react if there is a cascading of visibility
		* @function _oncascadevisibility
		* @memberof $ui.CoreContainerComponent
		* @protected
		*/
    
    /**
		* Protected internal function for derivative controls to implement to react to the results of the validation of the control
		* @function _onvalidate
    * @param {boolean} result
		* @memberof $ui.CoreContainerComponent
		* @protected
		*/
    
    /**
		* Protected internal function for derivative controls to implement to react to the change of the modified flag
		* @function _onmodified
		* @memberof $ui.CoreContainerComponent
		* @protected
		*/
		
		// modified property
		if (object.modified == undefined) {
			object.modified = false;
		} 
		object._protected.modified = object.modified;
		Object.defineProperty(object, 'modified', {
			get: function() {return this._protected.modified;},
			set: function(value) {
				if (value == undefined) value = false;
				this._protected.modified = value;
				if (this._getControlListProperty == undefined) {
					console.log('ERROR: _getControlListProperty not defined for CoreContainerComponent');
					return;
				}
        if (value == false) {
          var i,
  					control,
  					controlList = this._getControlListProperty();
  				for (i = 0; i < controlList.length; i++) {
  					control = controlList[i];
  					control.modified = value;
  				}
        }
        if (this._onmodified) {
          this._onmodified();
        }
			},
			configurable: false}
		);
		
		/** 
		 * Validate all the controls contained in this column (including nested controls) and return the boolean result
		 * @function validate
		 * @memberof $ui.CoreContainerComponent
		 * @returns {boolean}
		 */
		object.validate = function() {
			if (this._getControlListProperty == undefined) {
				console.log('ERROR: _getControlListProperty not defined for CoreContainerComponent');
				return false;
			}
			var i,
				control,
				controlList = this._getControlListProperty(),
				result = true;
			for (i = 0; i < controlList.length; i++) {
				control = controlList[i];
				if (control.validate)  {
					if (control.validate() == false) {
						result = false;
					}
				}
			}
      if (this._onvalidate) {
        this._onvalidate(result);
      }
			return result;
		}.$bind(object);
		
		// This function is called to cascade down a visibility change to child controls
		object._cascadeVisibility = function() {
			if (this._getControlListProperty == undefined) {
				console.log('ERROR: _getControlListProperty not defined for CoreContainerComponent');
				return;
			}
			var i,
				controlList = this._getControlListProperty(),
				control;			
			for (i = 0; i < controlList.length; i++) {
				control = controlList[i];
				if (control._cascadeVisibility) {
					control._cascadeVisibility();
				} else {
					if (control._onshow) {
						control._onshow();
					}
				}
			}
			if (this._oncascadevisibility) {
				this._oncascadevisibility();
			}
		}.$bind(object);
		
		
		// Internal function to create the component
		object._addComponent = function(control) {
			if (control == undefined) return;
			if (this._getControlListDom == undefined) {
				console.log('ERROR: _getControlListDom not defined for CoreContainerComponent');
				return;
			}
			var dom = this._getControlListDom();
			if (dom == undefined) {
				console.log('ERROR: _getControlListDom did not return a valid DOM element');
				return;
			}
			if (this.modified != undefined) {
				control.modified = this.modified;
			}
			$ui.createControl(control, this.screen);
			if (control.dom) {
				dom.appendChild(control.dom);
			}
		}.$bind(object);
		
		/** 
		 * Add a new control to the end of this container control
		 * @function addComponent
		 * @memberof $ui.CoreContainerComponent
		 * @param {$ui.CoreComponent} control - The control that you wish to add to the container control
		 */
		object.addComponent = function(control) {
			if (control == undefined) return;
			this._addComponent(control);
			if (this._getControlListProperty == undefined) {
				console.log('ERROR: _getControlListProperty not defined for CoreContainerComponent');
				return;
			}
			var list = this._getControlListProperty();
			if (list == undefined) {
				console.log('ERROR: _getControlListProperty did not return a valid object');
				return;
			}
			list.push(control);
			if (control._onshow) {
				control._onshow();
			}
			if (control.provider != undefined) {
				control._providerRefresh();
			}
		}.$bind(object);
		
		/** 
		 * Insert a new control into this container control before the targetControl
		 * @function insertComponentBefore
		 * @memberof $ui.CoreContainerComponent
		 * @param {$ui.CoreComponent} control - The control that you wish to insert to the container control
		 * @param {$ui.CoreComponent} targetControl - The target control that you wish to insert before 
		 */
		object.insertComponentBefore = function(control, targetControl) {
			if (control == undefined) return;
			if (targetControl == undefined) return;
			if (this._getControlListProperty == undefined) {
				console.log('ERROR: _getControlListProperty not defined for CoreContainerComponent');
				return;
			}
			var list = this._getControlListProperty();
			if (list == undefined) {
				console.log('ERROR: _getControlListProperty did not return a valid object');
				return;
			}
			if (this._getControlListDom == undefined) {
				console.log('ERROR: _getControlListDom not defined for CoreContainerComponent');
				return;
			}
			var dom = this._getControlListDom();
			if (dom == undefined) {
				console.log('ERROR: _getControlListDom did not return a valid DOM element');
				return;
			}
			// See if we can find the target control
			var i,
				item;
			for (i = 0; i < list.length; i++) {
				item = list[i];
				if (item == targetControl && item.dom && item.dom.parentNode) {
					if (this.modified != undefined) {
						control.modified = this.modified;
					}
					$ui.createControl(control, this.screen);
					if (control.dom) {
						item.dom.parentNode.insertBefore(control.dom, item.dom);
						list.splice(i, 0, control);
						if (control._onshow) {
							control._onshow();
						}
						if (control.provider != undefined) {
							control._providerRefresh();
						}
					}
					break;
				}
			}
			
			
		}.$bind(object);
		
		/** 
		 * Remove an existing control from this container control
		 * @function removeComponent
		 * @memberof $ui.CoreContainerComponent
		 * @param {$ui.CoreComponent} control - The control that you wish to remove from the screen
		 */
		object.removeComponent = function(control) {
			if (control == undefined) return;
			if (this._getControlListDom == undefined) {
				console.log('ERROR: _getControlListDom not defined for CoreContainerComponent');
				return;
			}
			if (this._getControlListProperty == undefined) {
				console.log('ERROR: _getControlListProperty not defined for CoreContainerComponent');
				return;
			}
			var dom = this._getControlListDom();
			if (dom == undefined) {
				console.log('ERROR: _getControlListDom did not return a valid DOM element');
				return;
			}
			var list = this._getControlListProperty();
			if (list == undefined) {
				console.log('ERROR: _getControlListProperty did not return a valid object');
				return;
			}
			var i,
				item;
			for (i = 0; i < list.length; i ++) {
				item = list[i];
				if (item == control) {
					list.splice(i,1);
          if (item.clearComponents) {
            item.clearComponents();
          }
          item._remove();
					break;
				}
			}
		}.$bind(object);
		
		/** 
		 * Remove all the child controls from this container control
		 * @function clearComponents
		 * @memberof $ui.CoreContainerComponent
		 */
		object.clearComponents = function() {
			if (this._getControlListProperty == undefined) {
				console.log('ERROR: _getControlListProperty not defined for CoreContainerComponent');
				return;
			}
			var list = this._getControlListProperty();
			if (list == undefined) {
				console.log('ERROR: _getControlListProperty did not return a valid object');
				return;
			}
			for (var i = list.length - 1; i >= 0; i--) {
				this.removeComponent(list[i]);
			}
				
		}.$bind(object);
		
		return object.dom;
	}
}
/**
 * This is the abstract base class that represents a screen instance. It derives from {@link $ui.CoreComponent}. 
 * A screen is declared as a JavaScript function and has various different properties. When a screen is pushed onto the stack a new instance of the screen will be created and rendered.<br><br>
 * If a derivative screen is using the <b>animated</b> property to animate a screen transition to show the screen, it must also provide a reverse animation effect within its <b>_onbeforepop</b> event.
 * <br><br><b>NOTE: This is an abstract class </b>
 * @namespace
 * @name CoreScreen
 * @memberof $ui
 * @extends $ui.CoreContainerComponent 
 * @property {GenericEvent} [onresize] - This event will fire when the viewport of the screen changes size
 * @property {boolean} [floatOnTop=false] - When set to <b>true</b> the screens below this screen will remain visible and have this screen float on top.
 * @property {DataEvent} [onshow] - This event will fire when the screen has been displayed
 * @property {DataEvent} [oncreate] - This event will when the screen has been initialized but has not yet been processed.  This allows you to make any changes to the screens properties before any of the controls are created.
 * @property {GenericEvent} [ondestroy] - This event will fire when the screen is about to be destroyed. Allowing for any memory clean-up routines
 * @property {GenericEvent} [onthemechange] - This event will fire when the theme for the toolkit has been updated
 * @property {CheckReadyStateEvent} [oncheckreadystate] - This event will fire when the screen is asked about its dirty state.  It allows the screen to manage its own state and can call the <b>readyCallback<b> function passed as a parameter when the screen is ready.  Being ready means that whomever asked about your state can be assured that everything is ok with the screen's state.
 */
function $ui_CoreScreen(object, data) {
	$ui_CoreContainerComponent.call(this, object);
	if (object) {
		object.data = data;
		object._protected.screen = object;
		// Guid Property
		object.guid = $ui.guid();
		object._protected.guid = object.guid;
		Object.defineProperty(object, 'guid', {
			get: function() {return this._protected.guid;},
			set: function() {
				console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','guid'));
			},
			configurable: false}
		);
		
		// floatOnTop Property
		if (object.floatOnTop != true) {
			object.floatOnTop = false;
		}
		object._protected.floatOnTop = object.floatOnTop;
		Object.defineProperty(object, 'floatOnTop', {
			get: function() {return this._protected.floatOnTop;},
			set: function() {
				console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','floatOnTop'));
			},
			configurable: false}
		);
		
		object.children = []; // Contains all child controls in the screen
		$ui.addClass(object.dom,'ui-core-screen');
		
		/**
		* Protected internal function for derivative screens to implement if they have specific functionality they wish to
		* do when the screen initializes.  This function will fire just before the <b>onshow</b> event is triggered for the screen.
		* @function _intitialize
		* @memberof $ui.CoreScreen
		* @protected
		*/
     
    /**
		* This function allows for querying the ready state of the screen which in turn will fire the <b>oncheckreadystate</b> event.  This can be useful when someone wishes to navigate away from the screen but a 
    * user has not yet saved their changes. It allows the screen to determine if it is safe to leave the screen or if some action needs to be handled.
		* @function checkReadyState
		* @memberof $ui.CoreScreen
		* @param {GenericEvent} readyCallback - Callback function to be fired when the screen is ready
    * @param {GenericEvent} [cancelCallback] - Callback function to be fired when the screen says that it is not ready
		*/
    object.checkReadyState = function(readyCallback, cancelCallback) {
      if (readyCallback == undefined) {
        console.log('ERROR: Cannot pass an undefined readyCallback to CoreScreen.checkReadyState()');
        return;
      }
      if (this.oncheckreadystate) {
        this.oncheckreadystate(readyCallback, cancelCallback);
      } else {
        readyCallback();
      }
    }.$bind(object);
		
		// Initialize the screen
		object.initialize = function() {
      this.dom.style['z-index'] = $ui.screens.length+1;
			$ui._protected.inScreenTransition = false;
			$ui._blockAllTapEvent(false);
			// See if there is an internal implementation of _initialize
			if (this._initialize) {
				this._initialize();
			}
			// Raise our onshow event
			if (this.onshow) {
				this.onshow(this.data);
			}
			// Fire the _onshow for all the controls
			var i,
				control;
			for (i = 0; i < this.children.length;i++) {
				control = this.children[i];
				if (control._onshow) {
					control._onshow();
				}
			}
      this._raiseInteractionEvent('data-interaction-screen-initialized');
		}.$bind(object);
		
		// Handle our internal update for theme changes
		object._onthemechange = function() {
			// Raise our onthemechange event
			if (this.onthemechange) {
				this.onthemechange();
			}
			// Fire the _onthemechange for all the controls
			var i,
				control;
			for (i = 0; i < this.children.length;i++) {
				control = this.children[i];
				if (control._onthemechange) {
					control._onthemechange();
				}
			}
		}.$bind(object);
		
		// Internal Resize event
		object._onresize = function() {
			// Fire the _onresize for all the controls
			var i,
				control;
			for (i = 0; i < this.children.length;i++) {
				control = this.children[i];
				if (control._onresize) {
					control._onresize();
				}
			}
		}.$bind(object);
		
		// Internal before pop event
		object.onbeforepop = function() {
			if (this._onbeforepop) {
				this._onbeforepop();
			}
			// Fire the _onbeforepop for all the controls
			var i,
				control;
			for (i = 0; i < this.children.length;i++) {
				control = this.children[i];
				if (control._onbeforepop) {
					control._onbeforepop();
				}
			}
		}.$bind(object);
		
		// Destroy screen
		object._destroy = function() {
			if (this.ondestroy) {
				this.ondestroy();
			}
			// Loop through all the children and call their destroy
			var i;
			for (i = 0; i < this.children.length; i++) {
				this.children[i].destroy();
			}
		}.$bind(object);
		
		return object.dom;
	}
}
/**
 * The DataEvent is used in a few places where an event needs to be fired an an optional data object passed to that event
 * @callback DataEvent
 * @param {object} [data] - The data that is being passed to this event
 */
 
 /**
 * The {@link $ui.CoreScreen} <b>oncheckreadystate</b> fires when the screen is asked about its ready state.  The screen has an opportunity to process its own state and then
 * fire the <b>readyCallback</b> function passed in as a paramenter when the screen is actually ready.  It may never fire the <b>readyCallback</b> if it is not ready.
 * @callback CheckReadyStateEvent
 * @param {GenericEvent} readyCallback - Callback function to be fired when the screen's state is ready
 * @param {GenericEvent} [cancelCallback] - Callback function to be fired when the screen says that it is <b>not</b> ready
 */
/**
 * The DataProvider component provides a data source that can be bound to controls on a screen. This provides the ability to both populate controls with data, as well as automatically save the data based on user interaction with the controls.<br><br>
 * <b>NOTE: The DataProvider should be attached to a screen or control using its [attachedObjects]{@link $ui.CoreComponent} property.</b><br><br>
 * <b>Sample Declaration</b>
 * <pre>
 * {
 *   component: $ui.DataProvider,
 *   id: 'myProvider',
 *   data_key: 'RATE_TYPE_CLASS_LIST',
 *   // highlight the first item in the list on load
 *   onload: function () {
 *     if (this.data && this.data.classes && this.data.classes.length > 0) {
 *       this.screen.rateTypeClassLayout.selectClass( this.data.classes[0]);
 *     }
 *   }
 *}
 * </pre>
 * @namespace
 * @name DataProvider
 * @memberof $ui
 * @property {object} component - The <b>required</b> component property defines what type of component is being defined. This property must be $ui.DataProvider
 * @property {string} id - The <b>required</b> id property is used to uniquely define the data provider in the scope of the screen in which it belongs. Providing an id for your data provider is required because you can easily access your provider through your javascript coding and also reference it as the provider for a control.
 * 
 * @property {string} [data_key] - A string reference to a unique, registered data service key; This is required by the <b>fetch</b> method
 * @property {string} [data_resource]  A string overriding the name of the resource to retrieve; For JSON file requests, the name is prefixed and .json is added as the extension
 * @property {string} [data_type]  A string overriding the type of resource to retrieve (see $data.data_service_types for valid options)
 * 
 * @property {object} [data] - The data property by default is undefined. You can populate the data property as any kind of object. The data property holds the object that represents the data for the provider
 * @property {GenericEvent} [onload] - This event will fire when the data has been successfully loaded into the provider and controls have been updated
 * @property {GenericEvent} [onbeforeupdate] - This event will fire when the data property has been successfully set, but has not yet been used to update any controls connected to the provider. This gives you an opportunity to manipulate the data property of the data provider <b>before</b> controls are updated
 */
function $ui_DataProvider(object, component, screen){
	// Create our protected area
	object._protected = {
		model: object,
		updates: []
	};
	
	// Attach the ID to the main screen object
	if (object.id && screen) {
		screen[object.id] = object;
	}
	
	// Component Property
	object._protected.component = object.component;
	Object.defineProperty(object, 'component', {
		get: function() {return this._protected.component;},
		set: function() {
			console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','component'));
		},
		configurable: false}
	);
	
	// Screen property
	object.screen = screen;
	object._protected.screen = object.screen;
	Object.defineProperty(object, 'screen', {
		get: function() {return this._protected.screen;},
		set: function() {
			console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','screen'));
		},
		configurable: false}
	);
	
	// Data property
	object._protected.data = object.data;
	Object.defineProperty(object, 'data', {
		get: function() {return this._protected.data;},
		set: function(value) {
			this._protected.data = value;
			this._protected.updates = [];
			if (this.onbeforeupdate) {
				this.onbeforeupdate();
			}
			this._raiseEvent();
			if (value == undefined) return;
			if (this.onload) {
				this.onload();
			}
		},
		configurable: false}
	);

  object.clear = function() {
    // iterate through data object and reset each property to undefined
    var data = object.data,
      clear_data = {};
    for (var property in data) {
      if (data.hasOwnProperty(property)) {
        clear_data[property] = undefined;
      }
    }
    object.data = clear_data;
  };

  /**
   * The fetch function retrieves and populates the DataProvider's data property.
   * The fetch function will only work if the global <b>$ui.init()</b> function has been passed an option parameter that has configured the <b>globalDataProvider</b> value
   * @function fetch
   * @memberof $ui.DataProvider
   * @param onfail - this callback function is invoked if unable to retrieve the requested data
   * @param transform - an optional data transformation function that takes the data as a parameter
   *  and returns the transformed data
   */
  object.fetch = function(onfail, transform) {
    if ($ui.options.globalDataProvider != undefined) {
      $ui.options.globalDataProvider._getData.call(this.screen, this, function(data) {
        if (transform) {
          data = transform(data);
        }
        object.data = data;}, onfail);
    }
  }.$bind(object);

	/** 
	 * The refresh function will send a signal out to all connected components to refresh their data from the current content in memory from the provider. <b>NOTE: No <i>onbeforeupdate</i> or <i>onload</i> event will fire on the provider</b>
	 * @function refresh
	 * @memberof $ui.DataProvider
	 */
	object.refresh = function() {
		this._raiseEvent();
	}.$bind(object);
	
	/** 
	 * The getUpdates function will return an array of field updates on the provider since its data property has been set.
	 * @function getUpdatedFields
	 * @memberof $ui.DataProvider
	 * @returns {ProviderUpdate[]}
	 */
	object.getUpdatedFields = function() {
		var i,
			result = [];
		for (i = 0; i < this._protected.updates.length; i++) {
			result.push(this._protected.updates[i]); 
		}
		return result;		
	}.$bind(object);
	
	// Maintain a list of updated data
	object._propertyUpdated = function(property, value) {
		var i,
			entry,
			found = false,
			newEntry = {
				property: property,
				value: value
			};
		// See if we just need to update an existing entry
		for (i = 0; i < this._protected.updates.length; i++) {
			entry = this._protected.updates[i];
			if (entry.property == property) {
				this._protected.updates[i] = newEntry;
				found = true;
				break;
			}
		}
		if (found == false) {
			this._protected.updates.push(newEntry);
		}
	}.$bind(object);
	
	// Raise our event to let the rest of the app know to refresh
	object._raiseEvent = function() {
		var evt = document.createEvent('Events');
		evt.initEvent(this.screen.guid+'-'+this.id+'-updated', true, true);
		window.dispatchEvent(evt);
	}.$bind(object);
	
	// Private function to handle clean-up
	object._destroy = function() {
		this._protected.data = undefined;
	}.$bind(object);
	
	// See if the data was pre-defined
	if (object.data != undefined) {
		if (object.onbeforeupdate) {
			object.onbeforeupdate();
		}
		if (object.onload) {
			object.onload();
		}
	}
	
	return undefined;
}

/**
 * A data provider link provides a binding between a [control]{@link $ui.CoreComponent} and a data provider. The path for the <b>property</b> attribute starts at the root of the object that is provided as the data source for the data provider.<br><br>
 * The type of object that the property path should point to is dependent on the control and the data it uses to display and/or edit. If the control also allows the user to edit data or change settings, these changes will be applied to the property value in the data provider.<br><br>
 * <b>Sample Code:</b><br>
 * <pre>provider: {
 *    id: 'myProvider',
 *    property: 'posts'
 * }
 * </pre>
 * <br>
 * To access sub objects in the object chain from the data provider you can use normal <b>dot</b> notation:<br><br>
 * <b>Sample Code:</b><br>
 * <pre>provider: {
 *    id: 'myProvider',
 *    property: 'posts.item.thingy'
 * }
 * </pre>
 * <br>
 * @namespace
 * @name DataProviderLink
 * @memberof $ui
 * @property {string} id - This is the <b>mandatory</b> id of the data provider belonging to the screen which will be linked to this control.  
 * @property {string} property - This is the property path/name of the object to be used as the bound data for this control. A nested property can be defined simply by providing a path using <b>.</b> dot separators just like you were referring to the object via JavaScript
 */
 
 
/**
 * The ProviderUpdate is a value that specifies a property name from a {@link $ui.DataProvider} and the new value of the property
 * @namespace ProviderUpdate
 * @memberof $ui.DataProvider
 * @property [string] property - The name of the property updated
 * @property [object] value - The new value of the property
 */
 
 /**
 * The GlobalDataProviderEvent is used when initializing the toolkit and 
 * @callback GlobalDataProviderEvent
 * @param {$ui.DataProvider} dataProvider - The DataProvider instance
 * @param {DataEvent} callback - The callback data event to be fired when data is ready
 * @param {GenericEvent} onfail - Callback to be triggered if there was an error during retrieval
 */
/**
 * Represents an interaction event from the user interface.  This event is raised when a user interacts with a part of the interface. All interation events are sent to the $ui.oninteraction 
 * assigned function.  If valid values are not passed in for all of the parameters no event will be raised.
 * @class InteractionEvent
 * @param {string} screenId - The <b>id</b> property of the screen which contains the control providing the interaction
 * @param {string} controlID - The <b>id</b> property of the control in which the user interacted
 * @param {string} interaction - The interaction which took place
 * @param {object} component - The component type definition for which this interaction took place.   An example could be the value $ui.List.  This is <b>not</b> a pointer to the control.
 */
function InteractionEvent(screenId, controlId, interaction, component) {
	/**
	 * The <b>id</b> property of the screen which contains the control providing the interaction
	 * @member {string} screenId
	 * @memberOf InteractionEvent
	 */
	this.screenId = screenId;
	
	 /**
	 * The <b>id</b> property of the control in which the user interacted
	 * @member {string} controlId
	 * @memberOf InteractionEvent
	 */
	this.controlId = controlId;
	
	 
	 /**
	 * The interaction which took place
	 * @member {string} interaction
	 * @memberOf InteractionEvent
	 */
	this.interaction = interaction;
	
	/**
	 * The component type definition for which this interaction took place.  An example could be the value $ui.List.  This is <b>not</b> a pointer to the control
	 * @member {object} component
	 * @memberOf InteractionEvent
	 */
	this.component = component;
}


 


/**
 * A List object will display multiple list items based on the data provided to the control.  The type of item objects that are used should match the declaration of the <b>style</b> of the list control.<br><br>
 * The type of data provider value for a list control should point to a property in the data provider that would follow the same rules as hard coding an array of items.<br><br>
 * <b>Sample Declaration</b><br>
 * <pre>
 * {
 *   component: $ui.List,
 *   style: $ui.GenericListItem,
 *   items: [
 *      {
 *         img: 'thumbnails/foo.png',
 *         title: 'This is my title',
 *         accent: '6 hours ago',
 *         caption: 'My summary description'
 *      }
 *   ]
 *}
 * @namespace
 * @name List
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {object[]} [items] - The items property is an array of objects who's definition matches that of the requirements of the <b>style</b> property of the list
 * @property {object} style - This is a list item decalaration so that the list knows how to render. For example this could be set to {@link $ui.GenericListItem}
 * @property {ListActionEvent} [onaction] - The onaction event will fire when an action from a list item is triggered. Some list items may have multiple actions that can be taken. When one of these actions is selected by the user the onaction event will fire.
 * @property {GenericEvent} [onitemschanged] - The onitemschanged event will fire when any items have been added or removed from the list.  This will also fire on data provider updates.
 */
function $ui_List(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom,'ui-list');
	
	// Set our items property
	if (object.items == undefined) {
		object.items = [];
	}
	object._protected.items = object.items;
	Object.defineProperty(object, 'items', {
		get: function() {return this._protected.items;},
		set: function() {
			console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','items'));
		},
		configurable: false}
	);

	// Broker the onaction from a list item
	object._onaction = function(item, event) {
		if (this.onaction) {
			this.onaction(event);
		}
	}.$bind(object);
	
	// Create the DOM for a list item depending on the list type
	object._createItemDom = function(item) {
		var dom;
		// See if the item is a header
		if (item.component && (item.component == $ui.Header)) {
			dom = $ui.createControl(item,this.screen);
		} else if (this._itemConstructor != undefined) {
			dom = new this._itemConstructor(item,this.screen);
		}
		return dom;
	}.$bind(object);
	
	// Private function to add a new item to the list
	object._addItem = function(item) {
		item.parent = this;
		itemDom = this._createItemDom(item);
		if (itemDom) {
			this.dom.appendChild(itemDom);
			if (item._onafterinsert) {
				item._onafterinsert();
			}
			return true;
		} else {
			return false;
		}
	}.$bind(object);
	
	/** 
	 * You can add an item to the end of the list by calling the addItem function and passing in an object that matches the a list item
	 * @function addItem
	 * @memberof $ui.List
	 * @param {object} item - Item to be added to the list
	 */
	object.addItem = function(item) {
		if (this._addItem(item)) {
			this.items.push(item);
			// Trigger our changed event
			if (this.onitemschanged) {
				this.onitemschanged();
			}
			if (item._onshow) {
				item._onshow();
			}
			return true;
		} else {
			return false;
		}
	}.$bind(object);
	
	/** 
	 * The remove item function will remove an existing item from a list. If an invalid item is specified the removal will fail
	 * @function removeItem
	 * @memberof $ui.List
	 * @param {object} item - Item to be removed from the list
	 */
	object.removeItem = function(item) {
		if (item == undefined) return false;
		var index = this.items.indexOf(item);
		if (index < 0) return false;
		try {
			this.dom.removeChild(item.dom);
		} catch (ex) {
			console.log('$ui.List: ' + ex);
		}
		this.items.splice(index, 1);
		item.destroy(); 
		// Trigger our changed event
		if (this.onitemschanged) {
			this.onitemschanged();
		}
	}.$bind(object);
	
	/** 
	 * Insert item works similar to addItem but instead will insert the item into the list at the index specified. If an invalid index is specified it will result in failure to insert the item. To insert an item at the top of a list call insert with the index of 0.
	 * @function insertItem
	 * @memberOf $ui.List
	 * @param {object} item - Item to be inserted into the list
	 * @param {number} index - Index to insert the item
	 */
	object.insertItem = function(item, index) {
		item.parent = this;
		if (index < 0) {
			return false;
		} else if (this.items.length == 0) {
			this.addItem(item);
			return true;
		} else if (index > this.items.length - 1) {
			this.addItem(item);
			return true;
		} else { // Insert it at the index
			var existingItem = this.items[index],
				itemDom = this._createItemDom(item);
			this.items.splice(index, 0, item);
			this.dom.insertBefore(itemDom, existingItem.dom);
			// Trigger our changed event
			if (this.onitemschanged) {
				this.onitemschanged();
			}
			if (item._onshow) {
				item._onshow();
			}
			return true;
		} 
		return false;
	}.$bind(object);
	
	/** 
	 * You can refresh all the items in a list by calling the refreshItems function with an array of new items
	 * @function refreshItems
	 * @memberof $ui.List
	 * @param {object[]} items - Array of items to refresh the list
	 */
	object.refreshItems = function(itemArray) {
		var i,
			item;
		if (this.items) {
			// Remove all existing items first
			for (i = this.items.length - 1; i >= 0; i--) {
				item = this.items[i];
				try {
					this.dom.removeChild(item.dom);
				} catch (ex) {
					console.log('$ui.List: ' + ex);
				}
				this.items.pop();
				item.destroy();
			}
		}
		if (itemArray == undefined) return; // No data provided
		this.addItemBatch(itemArray);
		// Trigger our changed event
		if (this.onitemschanged) {
			this.onitemschanged();
		}
	}.$bind(object);
	
	/** 
	 * This function is much like the refreshItems function but instead it loads a list of items to the end of the current list and does not replace the existing list items.
	 * @function addItemBatch
	 * @memberof $ui.List
	 * @param {object[]} items - Array of items to be added to the list
	 */
	object.addItemBatch = function(itemArray) {
		var i,
			item;
		// Add all new items into the list
		for (i = 0; i < itemArray.length; i++) {
			item = itemArray[i];
			this.addItem(item);
		}
	}.$bind(object);
	
	/** 
	 * This function will filter the list items based on the name value pairs of search criteria.  All search criteria will be AND'ed
	 * @function filter
	 * @memberof $ui.List
	 * @param {ListFilter[]} filters - Array of filters to be used for this list
	 */
	object.filter = function(filters) {
		if (filters == undefined || filters == null) return;
		var i,
			j,
			filter,
			item,
			pattern,
			match = true;;
		for (i = 0; i < this.items.length; i++) {
			item = this.items[i];
			match = true;
			for (j = 0; j < filters.length; j++) {
				filter = filters[j];
				if (item[filter.name] != undefined) {
					pattern = new RegExp(filter.expression, 'gi');
					if (pattern.test(item[filter.name]) == false) {
						match = false;
						break;
					}
				}
			}
			item.visible = match;
		}
	}.$bind(object);
	
	/** 
	 * This function will reset any filter applied to the List
	 * @function filterReset
	 * @memberof $ui.List
	 */
	object.filterReset = function(filter) {
		var i;
		for (i = 0; i < this.items.length; i++) {
			this.items[i].visible = true;
		}
		
	}.$bind(object);
	
	
	// Private function to handle provider updates
	object._providerUpdate = function(value) {
		this.refreshItems(value);
	}.$bind(object);
	
	
	var i,
		extension;
	// Determine our item constructor
	for (i = 0; i < $ui._protected.definitions.length; i++) {
		extension = $ui._protected.definitions[i];
		if (extension.type != $ui.UIExtensionType.LISTITEM) continue;
		if (extension.component == object.style) {
			object._itemConstructor = extension.constructor;
			break;
		}
	}

	// Cycle through list items
	var	item,
		index;
	if (object.items) {
		for (i = 0; i < object.items.length; i++) {
			item = object.items[i];
			object._addItem(item);
		}
		// Trigger our changed event
		if (object.onitemschanged) {
			object.onitemschanged();
		}
	}
	
	// Relay the _onshow to list items
	object._onshow = function() {
		var i,
			item;
		for (i = 0; i < this.items.length; i++) {
			item = this.items[i];
			if (item._onshow) {
				item._onshow();
			}
		}
	}.$bind(object);
	
	return object.dom;
}

/**
 * The {@link $ui.List} <b>onaction</b> event will fire when the user interacts with a list item
 * @callback ListActionEvent
 * @param {ListEvent} event - The list event which was raised
 */
 
 /**
 * The {@link $ui.List} <b>onaction</b> event will fire when the user interacts with a list item
 * @class ListFilter
 * @memberof $ui
 * @param {string} name - The name of the property to be filtered
 * @param {string} expression - The regular expression to use to evaluate against the value of the named list item property
 */
 $ui.ListFilter = function(name, expression) {
	 this.name = name;
	 this.expression = expression;
 }
/**
 * The list event is what is triggered when a user interacts with the List control. It contains the target list item that the user was interacting with, the type of event which was triggered 
 * and an optional data property that contains extra data about the event.
 * @class ListEvent
 * @param {object} target - Target list item where the event originated
 * @param {string} eventType - The type of event that was triggered. Each list item has its own set of possible events that can be raised
 * @param {object} [data] - Optional data that can be passed with a list event
 */
function ListEvent(target, eventType, data) {
	/** 
	 * Target list item where the event originated
	 * @member {object} target
	 * @memberOf ListEvent
	 */
	this.target = target;
	
	/** 
	 * The type of event that was triggered. Each list item has its own set of possible events that can be raised
	 * @member {string} eventType
	 * @memberOf ListEvent
	 */
	this.eventType = eventType;
	
	/** 
	 * Optional data that can be passed with a list event
	 * @member {object} [data]
	 * @memberOf ListEvent
	 */
	this.data = data;
}


/**
 * The spinner control provides you the ability to give a visual indicator when your content is loading. The spinner has one main property <b>size</b>. <br><br>
 * <b>Sample Declaration</b><br>
 * <pre>
 * {
 *   component: $ui.Spinner,
 *   size: $ui.Spinner.SpinnerSize.LARGE
 *}
 * @namespace Spinner
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {$ui.Size} [size=$ui.Size.NORMAL] - Represents the size of the spinner component.
 * @property {$ui.Spinner.SpinnerColor} [forceColor] - This property specifies if the color should be forced to be dark or light. By default the system figures this out and does not need to be set. However, if you want to force a color in a certain scenario you can use this property.
 */
function $ui_Spinner(object, screen){
	$ui_CoreComponent.call(this, object, screen);
	// Size property
	object.size = (object.size) ? object.size : $ui.Size.NORMAL;
	object._protected.size = object.size;
	Object.defineProperty(object, 'size', {
		get: function() {return this._protected.size;},
		set: function(value) {
			if (this._protected.size == value) return;
			$ui.removeClass(this.dom, this._protected.size);
			this._protected.size = value;
			$ui.addClass(this.dom,value);			
		},
		configurable: false}
	);
	
	$ui.addClass(object.dom, 'ui-spinner')
	$ui.addClass(object.dom, object.size);
	$ui.addClass(object.dom, 'center');
	
	// Create the inner div
	object.dom.innerDiv = document.createElement('div');
	$ui.addClass(object.dom.innerDiv, 'inner');
	object.dom.appendChild(object.dom.innerDiv);
	
	// forceColor property
	object._protected.forceColor = object.forceColor;
	if (object.forceColor) {
		$ui.addClass(object.dom.innerDiv, object.forceColor);
	} else {
		if ($ui.theme.rootClass && $ui.theme.rootClass.indexOf('ui-theme-dark') > -1)  {
			$ui.addClass(object.dom.innerDiv, 'light');
		} else {
			$ui.addClass(object.dom.innerDiv, 'dark');
		}
	}
	Object.defineProperty(object, 'forceColor', {
		get: function() {return this._protected.forceColor;},
		set: function() {
			console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','forceColor'));			
		},
		configurable: false}
	);
	
	return object.dom
}

$ui_Spinner.prototype = new $ui_CoreComponent();
/**
 * The definition of an extension to be used in extending the <b>$ui</b> framework.
 * @class
 * @param {string} name - This would be the value you set as the <b>component</b> property for your control
 * @param {function} constructor - The function to be used as your control constructor
 * @param {$ui.UIExtensionType} [type=$ui.UIExtensionType.CONTROL] - The type of extension you are registering
 * @param {object} [definition] - Class definition for your extension, you can include properties such as constants here
 */
function UIExtension(name, constructor, type, definition) {
	/** 
	 * This would be the value you set as the <b>component</b> property for your control
	 * @member {string} name
	 * @memberOf UIExtension
	 */
	if (name == null) throw new Error('UIExtension: name cannot be null');
	if (name == undefined) throw new Error('UIExtension: name cannot be undefined');
	this.name = name;
	/** 
	 * The function to be used as your control constructor
	 * @member {function} constructor
	 * @memberOf UIExtension
	 */
	if (constructor == null) throw new Error('UIExtension: constructor cannot be null');
	if (constructor == undefined) throw new Error('UIExtension: constructor cannot be undefined');
	this.constructor = constructor;
	/** 
	 * The type of extension you are registering
	 * @member {$ui.UIExtensionType} [type=$ui.UIExtensionType.CONTROL]
	 * @memberOf UIExtension
	 */
	if (type == null || type == undefined) {
		this.type = $ui.UIExtensionType.CONTROL;
	} else if ((type != $ui.UIExtensionType.CONTROL) && (type != $ui.UIExtensionType.SCREEN) && (type != $ui.UIExtensionType.LISTITEM) && (type != $ui.UIExtensionType.ATTACHED_OBJECT)) {
		throw new Error('UIExtension: type is an invalid value');
	} else {
		this.type = type;
	}
	/** 
	 * Class definition for your extension, you can include properties such as constants here
	 * @member {object} [definition]
	 * @memberOf UIExtension
	 */
	if (definition == null || definition == undefined) {
		this.definition = {};
	} else {
		this.definition = definition;
	}
}
/**
 * The Button represents a standard button in the UI. 
 * <br><br><b>Sample Declaration</b>
 * <pre>
 * {
 *   component: $ui.Button,
 *   caption: 'Click Me'
 * }
 * </pre>
 * @namespace Button
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {string} caption - Represents the main text to show in the list item
 */
function $ui_Button(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom, 'ui-button theme-brand-background-color theme-highlight-text-color theme-border-color');
	if ($ui.theme.inHeadUnit == true) {
		$ui.addClass(object.dom, 'in-head-unit');
	}

	// Caption
	//object.dom.captionDiv = document.createElement('div');
	//$ui.addClass(object.dom.captionDiv,'caption theme-text-color');
	//object.dom.appendChild(object.dom.captionDiv);
	
	// caption property
	if (object.caption == undefined) {
		object.caption = '';
	}
	object.dom.textContent = object.caption;
	object._protected.caption = object.caption;
	Object.defineProperty(object, 'caption', {
		get: function() {return this._protected.caption;},
		set: function(value) {
			if (value == undefined) value = '';
			if (value == this._protected.caption) return;
			this._protected.caption = value;
			this.dom.textContent = value;
		},
		configurable: false}
	);
	
	
	// Handle our touch events
	object.dom.ontouchstart = function() {
		this.style.opacity = 0.7;
	}
	object.dom.ontouchend = function() {
		this.style.opacity = 1;
	}
	object.dom.ontouchcancel = object.dom.ontouchend;
	if (!$ui.isMobileDevice()) {
		object.dom.onmousedown = object.dom.ontouchstart;
		object.dom.onmouseup = object.dom.ontouchend;
		object.dom.onmouseleave = object.dom.ontouchend;
	}

	// Pass the onclick back to the list
	object.dom.onclick = function() {
		$ui.playTouchSound();
		if (this.model.onclick) {
			this.model.onclick();
		}
	};

	return object.dom;
}
/*!
 * Chart.js
 * http://chartjs.org/
 * Version: 1.0.1
 *
 * Copyright 2015 Nick Downie
 * Released under the MIT license
 * https://github.com/nnnick/Chart.js/blob/master/LICENSE.md
 */
(function(){"use strict";var t=this,i=t.Chart,e=function(t){this.canvas=t.canvas,this.ctx=t;this.width=t.canvas.width,this.height=t.canvas.height;return this.aspectRatio=this.width/this.height,s.retinaScale(this),this};e.defaults={global:{animation:!0,animationSteps:60,animationEasing:"easeOutQuart",showScale:!0,scaleOverride:!1,scaleSteps:null,scaleStepWidth:null,scaleStartValue:null,scaleLineColor:"rgba(0,0,0,.1)",scaleLineWidth:1,scaleShowLabels:!0,scaleLabel:"<%=value%>",scaleIntegersOnly:!0,scaleBeginAtZero:!1,scaleFontFamily:"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",scaleFontSize:12,scaleFontStyle:"normal",scaleFontColor:"#666",responsive:!1,maintainAspectRatio:!0,showTooltips:!0,customTooltips:!1,tooltipEvents:["mousemove","touchstart","touchmove","mouseout"],tooltipFillColor:"rgba(0,0,0,0.8)",tooltipFontFamily:"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",tooltipFontSize:14,tooltipFontStyle:"normal",tooltipFontColor:"#fff",tooltipTitleFontFamily:"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",tooltipTitleFontSize:14,tooltipTitleFontStyle:"bold",tooltipTitleFontColor:"#fff",tooltipYPadding:6,tooltipXPadding:6,tooltipCaretSize:8,tooltipCornerRadius:6,tooltipXOffset:10,tooltipTemplate:"<%if (label){%><%=label%>: <%}%><%= value %>",multiTooltipTemplate:"<%= value %>",multiTooltipKeyBackground:"#fff",onAnimationProgress:function(){},onAnimationComplete:function(){}}},e.types={};var s=e.helpers={},n=s.each=function(t,i,e){var s=Array.prototype.slice.call(arguments,3);if(t)if(t.length===+t.length){var n;for(n=0;n<t.length;n++)i.apply(e,[t[n],n].concat(s))}else for(var o in t)i.apply(e,[t[o],o].concat(s))},o=s.clone=function(t){var i={};return n(t,function(e,s){t.hasOwnProperty(s)&&(i[s]=e)}),i},a=s.extend=function(t){return n(Array.prototype.slice.call(arguments,1),function(i){n(i,function(e,s){i.hasOwnProperty(s)&&(t[s]=e)})}),t},h=s.merge=function(){var t=Array.prototype.slice.call(arguments,0);return t.unshift({}),a.apply(null,t)},l=s.indexOf=function(t,i){if(Array.prototype.indexOf)return t.indexOf(i);for(var e=0;e<t.length;e++)if(t[e]===i)return e;return-1},r=(s.where=function(t,i){var e=[];return s.each(t,function(t){i(t)&&e.push(t)}),e},s.findNextWhere=function(t,i,e){e||(e=-1);for(var s=e+1;s<t.length;s++){var n=t[s];if(i(n))return n}},s.findPreviousWhere=function(t,i,e){e||(e=t.length);for(var s=e-1;s>=0;s--){var n=t[s];if(i(n))return n}},s.inherits=function(t){var i=this,e=t&&t.hasOwnProperty("constructor")?t.constructor:function(){return i.apply(this,arguments)},s=function(){this.constructor=e};return s.prototype=i.prototype,e.prototype=new s,e.extend=r,t&&a(e.prototype,t),e.__super__=i.prototype,e}),c=s.noop=function(){},u=s.uid=function(){var t=0;return function(){return"chart-"+t++}}(),d=s.warn=function(t){window.console&&"function"==typeof window.console.warn&&console.warn(t)},p=s.amd="function"==typeof define&&define.amd,f=s.isNumber=function(t){return!isNaN(parseFloat(t))&&isFinite(t)},g=s.max=function(t){return Math.max.apply(Math,t)},m=s.min=function(t){return Math.min.apply(Math,t)},v=(s.cap=function(t,i,e){if(f(i)){if(t>i)return i}else if(f(e)&&e>t)return e;return t},s.getDecimalPlaces=function(t){return t%1!==0&&f(t)?t.toString().split(".")[1].length:0}),S=s.radians=function(t){return t*(Math.PI/180)},x=(s.getAngleFromPoint=function(t,i){var e=i.x-t.x,s=i.y-t.y,n=Math.sqrt(e*e+s*s),o=2*Math.PI+Math.atan2(s,e);return 0>e&&0>s&&(o+=2*Math.PI),{angle:o,distance:n}},s.aliasPixel=function(t){return t%2===0?0:.5}),y=(s.splineCurve=function(t,i,e,s){var n=Math.sqrt(Math.pow(i.x-t.x,2)+Math.pow(i.y-t.y,2)),o=Math.sqrt(Math.pow(e.x-i.x,2)+Math.pow(e.y-i.y,2)),a=s*n/(n+o),h=s*o/(n+o);return{inner:{x:i.x-a*(e.x-t.x),y:i.y-a*(e.y-t.y)},outer:{x:i.x+h*(e.x-t.x),y:i.y+h*(e.y-t.y)}}},s.calculateOrderOfMagnitude=function(t){return Math.floor(Math.log(t)/Math.LN10)}),C=(s.calculateScaleRange=function(t,i,e,s,n){var o=2,a=Math.floor(i/(1.5*e)),h=o>=a,l=g(t),r=m(t);l===r&&(l+=.5,r>=.5&&!s?r-=.5:l+=.5);for(var c=Math.abs(l-r),u=y(c),d=Math.ceil(l/(1*Math.pow(10,u)))*Math.pow(10,u),p=s?0:Math.floor(r/(1*Math.pow(10,u)))*Math.pow(10,u),f=d-p,v=Math.pow(10,u),S=Math.round(f/v);(S>a||a>2*S)&&!h;)if(S>a)v*=2,S=Math.round(f/v),S%1!==0&&(h=!0);else if(n&&u>=0){if(v/2%1!==0)break;v/=2,S=Math.round(f/v)}else v/=2,S=Math.round(f/v);return h&&(S=o,v=f/S),{steps:S,stepValue:v,min:p,max:p+S*v}},s.template=function(t,i){function e(t,i){return i.value;var e=/\W/.test(t)?new Function("obj","var p=[],print=function(){p.push.apply(p,arguments);};with(obj){p.push('"+t.replace(/[\r\t\n]/g," ").split("<%").join("	").replace(/((^|%>)[^\t]*)'/g,"$1\r").replace(/\t=(.*?)%>/g,"',$1,'").split("	").join("');").split("%>").join("p.push('").split("\r").join("\\'")+"');}return p.join('');"):s[t]=s[t];return i?e(i):e}if(t instanceof Function)return t(i);var s={};return e(t,i)}),w=(s.generateLabels=function(t,i,e,s){var o=new Array(i);return labelTemplateString&&n(o,function(i,n){o[n]=C(t,{value:e+s*(n+1)})}),o},s.easingEffects={linear:function(t){return t},easeInQuad:function(t){return t*t},easeOutQuad:function(t){return-1*t*(t-2)},easeInOutQuad:function(t){return(t/=.5)<1?.5*t*t:-0.5*(--t*(t-2)-1)},easeInCubic:function(t){return t*t*t},easeOutCubic:function(t){return 1*((t=t/1-1)*t*t+1)},easeInOutCubic:function(t){return(t/=.5)<1?.5*t*t*t:.5*((t-=2)*t*t+2)},easeInQuart:function(t){return t*t*t*t},easeOutQuart:function(t){return-1*((t=t/1-1)*t*t*t-1)},easeInOutQuart:function(t){return(t/=.5)<1?.5*t*t*t*t:-0.5*((t-=2)*t*t*t-2)},easeInQuint:function(t){return 1*(t/=1)*t*t*t*t},easeOutQuint:function(t){return 1*((t=t/1-1)*t*t*t*t+1)},easeInOutQuint:function(t){return(t/=.5)<1?.5*t*t*t*t*t:.5*((t-=2)*t*t*t*t+2)},easeInSine:function(t){return-1*Math.cos(t/1*(Math.PI/2))+1},easeOutSine:function(t){return 1*Math.sin(t/1*(Math.PI/2))},easeInOutSine:function(t){return-0.5*(Math.cos(Math.PI*t/1)-1)},easeInExpo:function(t){return 0===t?1:1*Math.pow(2,10*(t/1-1))},easeOutExpo:function(t){return 1===t?1:1*(-Math.pow(2,-10*t/1)+1)},easeInOutExpo:function(t){return 0===t?0:1===t?1:(t/=.5)<1?.5*Math.pow(2,10*(t-1)):.5*(-Math.pow(2,-10*--t)+2)},easeInCirc:function(t){return t>=1?t:-1*(Math.sqrt(1-(t/=1)*t)-1)},easeOutCirc:function(t){return 1*Math.sqrt(1-(t=t/1-1)*t)},easeInOutCirc:function(t){return(t/=.5)<1?-0.5*(Math.sqrt(1-t*t)-1):.5*(Math.sqrt(1-(t-=2)*t)+1)},easeInElastic:function(t){var i=1.70158,e=0,s=1;return 0===t?0:1==(t/=1)?1:(e||(e=.3),s<Math.abs(1)?(s=1,i=e/4):i=e/(2*Math.PI)*Math.asin(1/s),-(s*Math.pow(2,10*(t-=1))*Math.sin(2*(1*t-i)*Math.PI/e)))},easeOutElastic:function(t){var i=1.70158,e=0,s=1;return 0===t?0:1==(t/=1)?1:(e||(e=.3),s<Math.abs(1)?(s=1,i=e/4):i=e/(2*Math.PI)*Math.asin(1/s),s*Math.pow(2,-10*t)*Math.sin(2*(1*t-i)*Math.PI/e)+1)},easeInOutElastic:function(t){var i=1.70158,e=0,s=1;return 0===t?0:2==(t/=.5)?1:(e||(e=.3*1.5),s<Math.abs(1)?(s=1,i=e/4):i=e/(2*Math.PI)*Math.asin(1/s),1>t?-.5*s*Math.pow(2,10*(t-=1))*Math.sin(2*(1*t-i)*Math.PI/e):s*Math.pow(2,-10*(t-=1))*Math.sin(2*(1*t-i)*Math.PI/e)*.5+1)},easeInBack:function(t){var i=1.70158;return 1*(t/=1)*t*((i+1)*t-i)},easeOutBack:function(t){var i=1.70158;return 1*((t=t/1-1)*t*((i+1)*t+i)+1)},easeInOutBack:function(t){var i=1.70158;return(t/=.5)<1?.5*t*t*(((i*=1.525)+1)*t-i):.5*((t-=2)*t*(((i*=1.525)+1)*t+i)+2)},easeInBounce:function(t){return 1-w.easeOutBounce(1-t)},easeOutBounce:function(t){return(t/=1)<1/2.75?7.5625*t*t:2/2.75>t?1*(7.5625*(t-=1.5/2.75)*t+.75):2.5/2.75>t?1*(7.5625*(t-=2.25/2.75)*t+.9375):1*(7.5625*(t-=2.625/2.75)*t+.984375)},easeInOutBounce:function(t){return.5>t?.5*w.easeInBounce(2*t):.5*w.easeOutBounce(2*t-1)+.5}}),b=s.requestAnimFrame=function(){return window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame||function(t){return window.setTimeout(t,1e3/60)}}(),P=(s.cancelAnimFrame=function(){return window.cancelAnimationFrame||window.webkitCancelAnimationFrame||window.mozCancelAnimationFrame||window.oCancelAnimationFrame||window.msCancelAnimationFrame||function(t){return window.clearTimeout(t,1e3/60)}}(),s.animationLoop=function(t,i,e,s,n,o){var a=0,h=w[e]||w.linear,l=function(){a++;var e=a/i,r=h(e);t.call(o,r,e,a),s.call(o,r,e),i>a?o.animationFrame=b(l):n.apply(o)};b(l)},s.getRelativePosition=function(t){var i,e,s=t.originalEvent||t,n=t.currentTarget||t.srcElement,o=n.getBoundingClientRect();return s.touches?(i=s.touches[0].clientX-o.left,e=s.touches[0].clientY-o.top):(i=s.clientX-o.left,e=s.clientY-o.top),{x:i,y:e}},s.addEvent=function(t,i,e){t.addEventListener?t.addEventListener(i,e):t.attachEvent?t.attachEvent("on"+i,e):t["on"+i]=e}),L=s.removeEvent=function(t,i,e){t.removeEventListener?t.removeEventListener(i,e,!1):t.detachEvent?t.detachEvent("on"+i,e):t["on"+i]=c},k=(s.bindEvents=function(t,i,e){t.events||(t.events={}),n(i,function(i){t.events[i]=function(){e.apply(t,arguments)},P(t.chart.canvas,i,t.events[i])})},s.unbindEvents=function(t,i){n(i,function(i,e){L(t.chart.canvas,e,i)})}),F=s.getMaximumWidth=function(t){var i=t.parentNode;return i.clientWidth},R=s.getMaximumHeight=function(t){var i=t.parentNode;return i.clientHeight},T=(s.getMaximumSize=s.getMaximumWidth,s.retinaScale=function(t){var i=t.ctx,e=t.canvas.width,s=t.canvas.height;window.devicePixelRatio&&(i.canvas.style.width=e+"px",i.canvas.style.height=s+"px",i.canvas.height=s*window.devicePixelRatio,i.canvas.width=e*window.devicePixelRatio,i.scale(window.devicePixelRatio,window.devicePixelRatio))}),A=s.clear=function(t){t.ctx.clearRect(0,0,t.width,t.height)},M=s.fontString=function(t,i,e){return i+" "+t+"px "+e},W=s.longestText=function(t,i,e){t.font=i;var s=0;return n(e,function(i){var e=t.measureText(i).width;s=e>s?e:s}),s},z=s.drawRoundedRectangle=function(t,i,e,s,n,o){t.beginPath(),t.moveTo(i+o,e),t.lineTo(i+s-o,e),t.quadraticCurveTo(i+s,e,i+s,e+o),t.lineTo(i+s,e+n-o),t.quadraticCurveTo(i+s,e+n,i+s-o,e+n),t.lineTo(i+o,e+n),t.quadraticCurveTo(i,e+n,i,e+n-o),t.lineTo(i,e+o),t.quadraticCurveTo(i,e,i+o,e),t.closePath()};e.instances={},e.Type=function(t,i,s){this.options=i,this.chart=s,this.id=u(),e.instances[this.id]=this,i.responsive&&this.resize(),this.initialize.call(this,t)},a(e.Type.prototype,{initialize:function(){return this},clear:function(){return A(this.chart),this},stop:function(){return s.cancelAnimFrame.call(t,this.animationFrame),this},resize:function(t){this.stop();var i=this.chart.canvas,e=F(this.chart.canvas),s=this.options.maintainAspectRatio?e/this.chart.aspectRatio:R(this.chart.canvas);return i.width=this.chart.width=e,i.height=this.chart.height=s,T(this.chart),"function"==typeof t&&t.apply(this,Array.prototype.slice.call(arguments,1)),this},reflow:c,render:function(t){return t&&this.reflow(),this.options.animation&&!t?s.animationLoop(this.draw,this.options.animationSteps,this.options.animationEasing,this.options.onAnimationProgress,this.options.onAnimationComplete,this):(this.draw(),this.options.onAnimationComplete.call(this)),this},generateLegend:function(){return C(this.options.legendTemplate,this)},destroy:function(){this.clear(),k(this,this.events);var t=this.chart.canvas;t.width=this.chart.width,t.height=this.chart.height,t.style.removeProperty?(t.style.removeProperty("width"),t.style.removeProperty("height")):(t.style.removeAttribute("width"),t.style.removeAttribute("height")),delete e.instances[this.id]},showTooltip:function(t,i){"undefined"==typeof this.activeElements&&(this.activeElements=[]);var o=function(t){var i=!1;return t.length!==this.activeElements.length?i=!0:(n(t,function(t,e){t!==this.activeElements[e]&&(i=!0)},this),i)}.call(this,t);if(o||i){if(this.activeElements=t,this.draw(),this.options.customTooltips&&this.options.customTooltips(!1),t.length>0)if(this.datasets&&this.datasets.length>1){for(var a,h,r=this.datasets.length-1;r>=0&&(a=this.datasets[r].points||this.datasets[r].bars||this.datasets[r].segments,h=l(a,t[0]),-1===h);r--);var c=[],u=[],d=function(){var t,i,e,n,o,a=[],l=[],r=[];return s.each(this.datasets,function(i){t=i.points||i.bars||i.segments,t[h]&&t[h].hasValue()&&a.push(t[h])}),s.each(a,function(t){l.push(t.x),r.push(t.y),c.push(s.template(this.options.multiTooltipTemplate,t)),u.push({fill:t._saved.fillColor||t.fillColor,stroke:t._saved.strokeColor||t.strokeColor})},this),o=m(r),e=g(r),n=m(l),i=g(l),{x:n>this.chart.width/2?n:i,y:(o+e)/2}}.call(this,h);new e.MultiTooltip({x:d.x,y:d.y,xPadding:this.options.tooltipXPadding,yPadding:this.options.tooltipYPadding,xOffset:this.options.tooltipXOffset,fillColor:this.options.tooltipFillColor,textColor:this.options.tooltipFontColor,fontFamily:this.options.tooltipFontFamily,fontStyle:this.options.tooltipFontStyle,fontSize:this.options.tooltipFontSize,titleTextColor:this.options.tooltipTitleFontColor,titleFontFamily:this.options.tooltipTitleFontFamily,titleFontStyle:this.options.tooltipTitleFontStyle,titleFontSize:this.options.tooltipTitleFontSize,cornerRadius:this.options.tooltipCornerRadius,labels:c,legendColors:u,legendColorBackground:this.options.multiTooltipKeyBackground,title:t[0].label,chart:this.chart,ctx:this.chart.ctx,custom:this.options.customTooltips}).draw()}else n(t,function(t){var i=t.tooltipPosition();new e.Tooltip({x:Math.round(i.x),y:Math.round(i.y),xPadding:this.options.tooltipXPadding,yPadding:this.options.tooltipYPadding,fillColor:this.options.tooltipFillColor,textColor:this.options.tooltipFontColor,fontFamily:this.options.tooltipFontFamily,fontStyle:this.options.tooltipFontStyle,fontSize:this.options.tooltipFontSize,caretHeight:this.options.tooltipCaretSize,cornerRadius:this.options.tooltipCornerRadius,text:C(this.options.tooltipTemplate,t),chart:this.chart,custom:this.options.customTooltips}).draw()},this);return this}},toBase64Image:function(){return this.chart.canvas.toDataURL.apply(this.chart.canvas,arguments)}}),e.Type.extend=function(t){var i=this,s=function(){return i.apply(this,arguments)};if(s.prototype=o(i.prototype),a(s.prototype,t),s.extend=e.Type.extend,t.name||i.prototype.name){var n=t.name||i.prototype.name,l=e.defaults[i.prototype.name]?o(e.defaults[i.prototype.name]):{};e.defaults[n]=a(l,t.defaults),e.types[n]=s,e.prototype[n]=function(t,i){var o=h(e.defaults.global,e.defaults[n],i||{});return new s(t,o,this)}}else d("Name not provided for this chart, so it hasn't been registered");return i},e.Element=function(t){a(this,t),this.initialize.apply(this,arguments),this.save()},a(e.Element.prototype,{initialize:function(){},restore:function(t){return t?n(t,function(t){this[t]=this._saved[t]},this):a(this,this._saved),this},save:function(){return this._saved=o(this),delete this._saved._saved,this},update:function(t){return n(t,function(t,i){this._saved[i]=this[i],this[i]=t},this),this},transition:function(t,i){return n(t,function(t,e){this[e]=(t-this._saved[e])*i+this._saved[e]},this),this},tooltipPosition:function(){return{x:this.x,y:this.y}},hasValue:function(){return f(this.value)}}),e.Element.extend=r,e.Point=e.Element.extend({display:!0,inRange:function(t,i){var e=this.hitDetectionRadius+this.radius;return Math.pow(t-this.x,2)+Math.pow(i-this.y,2)<Math.pow(e,2)},draw:function(){if(this.display){var t=this.ctx;t.beginPath(),t.arc(this.x,this.y,this.radius,0,2*Math.PI),t.closePath(),t.strokeStyle=this.strokeColor,t.lineWidth=this.strokeWidth,t.fillStyle=this.fillColor,t.fill(),t.stroke()}}}),e.Arc=e.Element.extend({inRange:function(t,i){var e=s.getAngleFromPoint(this,{x:t,y:i}),n=e.angle>=this.startAngle&&e.angle<=this.endAngle,o=e.distance>=this.innerRadius&&e.distance<=this.outerRadius;return n&&o},tooltipPosition:function(){var t=this.startAngle+(this.endAngle-this.startAngle)/2,i=(this.outerRadius-this.innerRadius)/2+this.innerRadius;return{x:this.x+Math.cos(t)*i,y:this.y+Math.sin(t)*i}},draw:function(t){var i=this.ctx;i.beginPath(),i.arc(this.x,this.y,this.outerRadius,this.startAngle,this.endAngle),i.arc(this.x,this.y,this.innerRadius,this.endAngle,this.startAngle,!0),i.closePath(),i.strokeStyle=this.strokeColor,i.lineWidth=this.strokeWidth,i.fillStyle=this.fillColor,i.fill(),i.lineJoin="bevel",this.showStroke&&i.stroke()}}),e.Rectangle=e.Element.extend({draw:function(){var t=this.ctx,i=this.width/2,e=this.x-i,s=this.x+i,n=this.base-(this.base-this.y),o=this.strokeWidth/2;this.showStroke&&(e+=o,s-=o,n+=o),t.beginPath(),t.fillStyle=this.fillColor,t.strokeStyle=this.strokeColor,t.lineWidth=this.strokeWidth,t.moveTo(e,this.base),t.lineTo(e,n),t.lineTo(s,n),t.lineTo(s,this.base),t.fill(),this.showStroke&&t.stroke()},height:function(){return this.base-this.y},inRange:function(t,i){return t>=this.x-this.width/2&&t<=this.x+this.width/2&&i>=this.y&&i<=this.base}}),e.Tooltip=e.Element.extend({draw:function(){var t=this.chart.ctx;t.font=M(this.fontSize,this.fontStyle,this.fontFamily),this.xAlign="center",this.yAlign="above";var i=this.caretPadding=2,e=t.measureText(this.text).width+2*this.xPadding,s=this.fontSize+2*this.yPadding,n=s+this.caretHeight+i;this.x+e/2>this.chart.width?this.xAlign="left":this.x-e/2<0&&(this.xAlign="right"),this.y-n<0&&(this.yAlign="below");var o=this.x-e/2,a=this.y-n;if(t.fillStyle=this.fillColor,this.custom)this.custom(this);else{switch(this.yAlign){case"above":t.beginPath(),t.moveTo(this.x,this.y-i),t.lineTo(this.x+this.caretHeight,this.y-(i+this.caretHeight)),t.lineTo(this.x-this.caretHeight,this.y-(i+this.caretHeight)),t.closePath(),t.fill();break;case"below":a=this.y+i+this.caretHeight,t.beginPath(),t.moveTo(this.x,this.y+i),t.lineTo(this.x+this.caretHeight,this.y+i+this.caretHeight),t.lineTo(this.x-this.caretHeight,this.y+i+this.caretHeight),t.closePath(),t.fill()}switch(this.xAlign){case"left":o=this.x-e+(this.cornerRadius+this.caretHeight);break;case"right":o=this.x-(this.cornerRadius+this.caretHeight)}z(t,o,a,e,s,this.cornerRadius),t.fill(),t.fillStyle=this.textColor,t.textAlign="center",t.textBaseline="middle",t.fillText(this.text,o+e/2,a+s/2)}}}),e.MultiTooltip=e.Element.extend({initialize:function(){this.font=M(this.fontSize,this.fontStyle,this.fontFamily),this.titleFont=M(this.titleFontSize,this.titleFontStyle,this.titleFontFamily),this.height=this.labels.length*this.fontSize+(this.labels.length-1)*(this.fontSize/2)+2*this.yPadding+1.5*this.titleFontSize,this.ctx.font=this.titleFont;var t=this.ctx.measureText(this.title).width,i=W(this.ctx,this.font,this.labels)+this.fontSize+3,e=g([i,t]);this.width=e+2*this.xPadding;var s=this.height/2;this.y-s<0?this.y=s:this.y+s>this.chart.height&&(this.y=this.chart.height-s),this.x>this.chart.width/2?this.x-=this.xOffset+this.width:this.x+=this.xOffset},getLineHeight:function(t){var i=this.y-this.height/2+this.yPadding,e=t-1;return 0===t?i+this.titleFontSize/2:i+(1.5*this.fontSize*e+this.fontSize/2)+1.5*this.titleFontSize},draw:function(){if(this.custom)this.custom(this);else{z(this.ctx,this.x,this.y-this.height/2,this.width,this.height,this.cornerRadius);var t=this.ctx;t.fillStyle=this.fillColor,t.fill(),t.closePath(),t.textAlign="left",t.textBaseline="middle",t.fillStyle=this.titleTextColor,t.font=this.titleFont,t.fillText(this.title,this.x+this.xPadding,this.getLineHeight(0)),t.font=this.font,s.each(this.labels,function(i,e){t.fillStyle=this.textColor,t.fillText(i,this.x+this.xPadding+this.fontSize+3,this.getLineHeight(e+1)),t.fillStyle=this.legendColorBackground,t.fillRect(this.x+this.xPadding,this.getLineHeight(e+1)-this.fontSize/2,this.fontSize,this.fontSize),t.fillStyle=this.legendColors[e].fill,t.fillRect(this.x+this.xPadding,this.getLineHeight(e+1)-this.fontSize/2,this.fontSize,this.fontSize)},this)}}}),e.Scale=e.Element.extend({initialize:function(){this.fit()},buildYLabels:function(){this.yLabels=[];for(var t=v(this.stepValue),i=0;i<=this.steps;i++)this.yLabels.push(C(this.templateString,{value:(this.min+i*this.stepValue).toFixed(t)}));this.yLabelWidth=this.display&&this.showLabels?W(this.ctx,this.font,this.yLabels):0},addXLabel:function(t){this.xLabels.push(t),this.valuesCount++,this.fit()},removeXLabel:function(){this.xLabels.shift(),this.valuesCount--,this.fit()},fit:function(){this.startPoint=this.display?this.fontSize:0,this.endPoint=this.display?this.height-1.5*this.fontSize-5:this.height,this.startPoint+=this.padding,this.endPoint-=this.padding;var t,i=this.endPoint-this.startPoint;for(this.calculateYRange(i),this.buildYLabels(),this.calculateXLabelRotation();i>this.endPoint-this.startPoint;)i=this.endPoint-this.startPoint,t=this.yLabelWidth,this.calculateYRange(i),this.buildYLabels(),t<this.yLabelWidth&&this.calculateXLabelRotation()},calculateXLabelRotation:function(){this.ctx.font=this.font;var t,i,e=this.ctx.measureText(this.xLabels[0]).width,s=this.ctx.measureText(this.xLabels[this.xLabels.length-1]).width;if(this.xScalePaddingRight=s/2+3,this.xScalePaddingLeft=e/2>this.yLabelWidth+10?e/2:this.yLabelWidth+10,this.xLabelRotation=0,this.display){var n,o=W(this.ctx,this.font,this.xLabels);this.xLabelWidth=o;for(var a=Math.floor(this.calculateX(1)-this.calculateX(0))-6;this.xLabelWidth>a&&0===this.xLabelRotation||this.xLabelWidth>a&&this.xLabelRotation<=90&&this.xLabelRotation>0;)n=Math.cos(S(this.xLabelRotation)),t=n*e,i=n*s,t+this.fontSize/2>this.yLabelWidth+8&&(this.xScalePaddingLeft=t+this.fontSize/2),this.xScalePaddingRight=this.fontSize/2,this.xLabelRotation++,this.xLabelWidth=n*o;this.xLabelRotation>0&&(this.endPoint-=Math.sin(S(this.xLabelRotation))*o+3)}else this.xLabelWidth=0,this.xScalePaddingRight=this.padding,this.xScalePaddingLeft=this.padding},calculateYRange:c,drawingArea:function(){return this.startPoint-this.endPoint},calculateY:function(t){var i=this.drawingArea()/(this.min-this.max);return this.endPoint-i*(t-this.min)},calculateX:function(t){var i=(this.xLabelRotation>0,this.width-(this.xScalePaddingLeft+this.xScalePaddingRight)),e=i/(this.valuesCount-(this.offsetGridLines?0:1)),s=e*t+this.xScalePaddingLeft;return this.offsetGridLines&&(s+=e/2),Math.round(s)},update:function(t){s.extend(this,t),this.fit()},draw:function(){var t=this.ctx,i=(this.endPoint-this.startPoint)/this.steps,e=Math.round(this.xScalePaddingLeft);this.display&&(t.fillStyle=this.textColor,t.font=this.font,n(this.yLabels,function(n,o){var a=this.endPoint-i*o,h=Math.round(a),l=this.showHorizontalLines;t.textAlign="right",t.textBaseline="middle",this.showLabels&&t.fillText(n,e-10,a),0!==o||l||(l=!0),l&&t.beginPath(),o>0?(t.lineWidth=this.gridLineWidth,t.strokeStyle=this.gridLineColor):(t.lineWidth=this.lineWidth,t.strokeStyle=this.lineColor),h+=s.aliasPixel(t.lineWidth),l&&(t.moveTo(e,h),t.lineTo(this.width,h),t.stroke(),t.closePath()),t.lineWidth=this.lineWidth,t.strokeStyle=this.lineColor,t.beginPath(),t.moveTo(e-5,h),t.lineTo(e,h),t.stroke(),t.closePath()},this),n(this.xLabels,function(i,e){var s=this.calculateX(e)+x(this.lineWidth),n=this.calculateX(e-(this.offsetGridLines?.5:0))+x(this.lineWidth),o=this.xLabelRotation>0,a=this.showVerticalLines;0!==e||a||(a=!0),a&&t.beginPath(),e>0?(t.lineWidth=this.gridLineWidth,t.strokeStyle=this.gridLineColor):(t.lineWidth=this.lineWidth,t.strokeStyle=this.lineColor),a&&(t.moveTo(n,this.endPoint),t.lineTo(n,this.startPoint-3),t.stroke(),t.closePath()),t.lineWidth=this.lineWidth,t.strokeStyle=this.lineColor,t.beginPath(),t.moveTo(n,this.endPoint),t.lineTo(n,this.endPoint+5),t.stroke(),t.closePath(),t.save(),t.translate(s,o?this.endPoint+12:this.endPoint+8),t.rotate(-1*S(this.xLabelRotation)),t.font=this.font,t.textAlign=o?"right":"center",t.textBaseline=o?"middle":"top",t.fillText(i,0,0),t.restore()},this))}}),e.RadialScale=e.Element.extend({initialize:function(){this.size=m([this.height,this.width]),this.drawingArea=this.display?this.size/2-(this.fontSize/2+this.backdropPaddingY):this.size/2},calculateCenterOffset:function(t){var i=this.drawingArea/(this.max-this.min);return(t-this.min)*i},update:function(){this.lineArc?this.drawingArea=this.display?this.size/2-(this.fontSize/2+this.backdropPaddingY):this.size/2:this.setScaleSize(),this.buildYLabels()},buildYLabels:function(){this.yLabels=[];for(var t=v(this.stepValue),i=0;i<=this.steps;i++)this.yLabels.push(C(this.templateString,{value:(this.min+i*this.stepValue).toFixed(t)}))},getCircumference:function(){return 2*Math.PI/this.valuesCount},setScaleSize:function(){var t,i,e,s,n,o,a,h,l,r,c,u,d=m([this.height/2-this.pointLabelFontSize-5,this.width/2]),p=this.width,g=0;for(this.ctx.font=M(this.pointLabelFontSize,this.pointLabelFontStyle,this.pointLabelFontFamily),i=0;i<this.valuesCount;i++)t=this.getPointPosition(i,d),e=this.ctx.measureText(C(this.templateString,{value:this.labels[i]})).width+5,0===i||i===this.valuesCount/2?(s=e/2,t.x+s>p&&(p=t.x+s,n=i),t.x-s<g&&(g=t.x-s,a=i)):i<this.valuesCount/2?t.x+e>p&&(p=t.x+e,n=i):i>this.valuesCount/2&&t.x-e<g&&(g=t.x-e,a=i);l=g,r=Math.ceil(p-this.width),o=this.getIndexAngle(n),h=this.getIndexAngle(a),c=r/Math.sin(o+Math.PI/2),u=l/Math.sin(h+Math.PI/2),c=f(c)?c:0,u=f(u)?u:0,this.drawingArea=d-(u+c)/2,this.setCenterPoint(u,c)},setCenterPoint:function(t,i){var e=this.width-i-this.drawingArea,s=t+this.drawingArea;this.xCenter=(s+e)/2,this.yCenter=this.height/2},getIndexAngle:function(t){var i=2*Math.PI/this.valuesCount;return t*i-Math.PI/2},getPointPosition:function(t,i){var e=this.getIndexAngle(t);return{x:Math.cos(e)*i+this.xCenter,y:Math.sin(e)*i+this.yCenter}},draw:function(){if(this.display){var t=this.ctx;if(n(this.yLabels,function(i,e){if(e>0){var s,n=e*(this.drawingArea/this.steps),o=this.yCenter-n;if(this.lineWidth>0)if(t.strokeStyle=this.lineColor,t.lineWidth=this.lineWidth,this.lineArc)t.beginPath(),t.arc(this.xCenter,this.yCenter,n,0,2*Math.PI),t.closePath(),t.stroke();else{t.beginPath();for(var a=0;a<this.valuesCount;a++)s=this.getPointPosition(a,this.calculateCenterOffset(this.min+e*this.stepValue)),0===a?t.moveTo(s.x,s.y):t.lineTo(s.x,s.y);t.closePath(),t.stroke()}if(this.showLabels){if(t.font=M(this.fontSize,this.fontStyle,this.fontFamily),this.showLabelBackdrop){var h=t.measureText(i).width;t.fillStyle=this.backdropColor,t.fillRect(this.xCenter-h/2-this.backdropPaddingX,o-this.fontSize/2-this.backdropPaddingY,h+2*this.backdropPaddingX,this.fontSize+2*this.backdropPaddingY)}t.textAlign="center",t.textBaseline="middle",t.fillStyle=this.fontColor,t.fillText(i,this.xCenter,o)}}},this),!this.lineArc){t.lineWidth=this.angleLineWidth,t.strokeStyle=this.angleLineColor;for(var i=this.valuesCount-1;i>=0;i--){if(this.angleLineWidth>0){var e=this.getPointPosition(i,this.calculateCenterOffset(this.max));t.beginPath(),t.moveTo(this.xCenter,this.yCenter),t.lineTo(e.x,e.y),t.stroke(),t.closePath()}var s=this.getPointPosition(i,this.calculateCenterOffset(this.max)+5);t.font=M(this.pointLabelFontSize,this.pointLabelFontStyle,this.pointLabelFontFamily),t.fillStyle=this.pointLabelFontColor;var o=this.labels.length,a=this.labels.length/2,h=a/2,l=h>i||i>o-h,r=i===h||i===o-h;t.textAlign=0===i?"center":i===a?"center":a>i?"left":"right",t.textBaseline=r?"middle":l?"bottom":"top",t.fillText(this.labels[i],s.x,s.y)}}}}}),s.addEvent(window,"resize",function(){var t;return function(){clearTimeout(t),t=setTimeout(function(){n(e.instances,function(t){t.options.responsive&&t.resize(t.render,!0)})},50)}}()),p?define(function(){return e}):"object"==typeof module&&module.exports&&(module.exports=e),t.Chart=e,e.noConflict=function(){return t.Chart=i,e}}).call(this),function(){"use strict";var t=this,i=t.Chart,e=i.helpers,s={scaleBeginAtZero:!0,scaleShowGridLines:!0,scaleGridLineColor:"rgba(0,0,0,.05)",scaleGridLineWidth:1,scaleShowHorizontalLines:!0,scaleShowVerticalLines:!0,barShowStroke:!0,barStrokeWidth:2,barValueSpacing:5,barDatasetSpacing:1,legendTemplate:'<ul class="<%=name.toLowerCase()%>-legend"><% for (var i=0; i<datasets.length; i++){%><li><span style="background-color:<%=datasets[i].fillColor%>"></span><%if(datasets[i].label){%><%=datasets[i].label%><%}%></li><%}%></ul>'};i.Type.extend({name:"Bar",defaults:s,initialize:function(t){var s=this.options;this.ScaleClass=i.Scale.extend({offsetGridLines:!0,calculateBarX:function(t,i,e){var n=this.calculateBaseWidth(),o=this.calculateX(e)-n/2,a=this.calculateBarWidth(t);return o+a*i+i*s.barDatasetSpacing+a/2},calculateBaseWidth:function(){return this.calculateX(1)-this.calculateX(0)-2*s.barValueSpacing},calculateBarWidth:function(t){var i=this.calculateBaseWidth()-(t-1)*s.barDatasetSpacing;return i/t}}),this.datasets=[],this.options.showTooltips&&e.bindEvents(this,this.options.tooltipEvents,function(t){var i="mouseout"!==t.type?this.getBarsAtEvent(t):[];this.eachBars(function(t){t.restore(["fillColor","strokeColor"])}),e.each(i,function(t){t.fillColor=t.highlightFill,t.strokeColor=t.highlightStroke}),this.showTooltip(i)}),this.BarClass=i.Rectangle.extend({strokeWidth:this.options.barStrokeWidth,showStroke:this.options.barShowStroke,ctx:this.chart.ctx}),e.each(t.datasets,function(i){var s={label:i.label||null,fillColor:i.fillColor,strokeColor:i.strokeColor,bars:[]};this.datasets.push(s),e.each(i.data,function(e,n){s.bars.push(new this.BarClass({value:e,label:t.labels[n],datasetLabel:i.label,strokeColor:i.strokeColor,fillColor:i.fillColor,highlightFill:i.highlightFill||i.fillColor,highlightStroke:i.highlightStroke||i.strokeColor}))},this)},this),this.buildScale(t.labels),this.BarClass.prototype.base=this.scale.endPoint,this.eachBars(function(t,i,s){e.extend(t,{width:this.scale.calculateBarWidth(this.datasets.length),x:this.scale.calculateBarX(this.datasets.length,s,i),y:this.scale.endPoint}),t.save()},this),this.render()},update:function(){this.scale.update(),e.each(this.activeElements,function(t){t.restore(["fillColor","strokeColor"])}),this.eachBars(function(t){t.save()}),this.render()},eachBars:function(t){e.each(this.datasets,function(i,s){e.each(i.bars,t,this,s)},this)},getBarsAtEvent:function(t){for(var i,s=[],n=e.getRelativePosition(t),o=function(t){s.push(t.bars[i])},a=0;a<this.datasets.length;a++)for(i=0;i<this.datasets[a].bars.length;i++)if(this.datasets[a].bars[i].inRange(n.x,n.y))return e.each(this.datasets,o),s;return s},buildScale:function(t){var i=this,s=function(){var t=[];return i.eachBars(function(i){t.push(i.value)}),t},n={templateString:this.options.scaleLabel,height:this.chart.height,width:this.chart.width,ctx:this.chart.ctx,textColor:this.options.scaleFontColor,fontSize:this.options.scaleFontSize,fontStyle:this.options.scaleFontStyle,fontFamily:this.options.scaleFontFamily,valuesCount:t.length,beginAtZero:this.options.scaleBeginAtZero,integersOnly:this.options.scaleIntegersOnly,calculateYRange:function(t){var i=e.calculateScaleRange(s(),t,this.fontSize,this.beginAtZero,this.integersOnly);e.extend(this,i)},xLabels:t,font:e.fontString(this.options.scaleFontSize,this.options.scaleFontStyle,this.options.scaleFontFamily),lineWidth:this.options.scaleLineWidth,lineColor:this.options.scaleLineColor,showHorizontalLines:this.options.scaleShowHorizontalLines,showVerticalLines:this.options.scaleShowVerticalLines,gridLineWidth:this.options.scaleShowGridLines?this.options.scaleGridLineWidth:0,gridLineColor:this.options.scaleShowGridLines?this.options.scaleGridLineColor:"rgba(0,0,0,0)",padding:this.options.showScale?0:this.options.barShowStroke?this.options.barStrokeWidth:0,showLabels:this.options.scaleShowLabels,display:this.options.showScale};this.options.scaleOverride&&e.extend(n,{calculateYRange:e.noop,steps:this.options.scaleSteps,stepValue:this.options.scaleStepWidth,min:this.options.scaleStartValue,max:this.options.scaleStartValue+this.options.scaleSteps*this.options.scaleStepWidth}),this.scale=new this.ScaleClass(n)},addData:function(t,i){e.each(t,function(t,e){this.datasets[e].bars.push(new this.BarClass({value:t,label:i,x:this.scale.calculateBarX(this.datasets.length,e,this.scale.valuesCount+1),y:this.scale.endPoint,width:this.scale.calculateBarWidth(this.datasets.length),base:this.scale.endPoint,strokeColor:this.datasets[e].strokeColor,fillColor:this.datasets[e].fillColor}))},this),this.scale.addXLabel(i),this.update()},removeData:function(){this.scale.removeXLabel(),e.each(this.datasets,function(t){t.bars.shift()},this),this.update()},reflow:function(){e.extend(this.BarClass.prototype,{y:this.scale.endPoint,base:this.scale.endPoint});
var t=e.extend({height:this.chart.height,width:this.chart.width});this.scale.update(t)},draw:function(t){var i=t||1;this.clear();this.chart.ctx;this.scale.draw(i),e.each(this.datasets,function(t,s){e.each(t.bars,function(t,e){t.hasValue()&&(t.base=this.scale.endPoint,t.transition({x:this.scale.calculateBarX(this.datasets.length,s,e),y:this.scale.calculateY(t.value),width:this.scale.calculateBarWidth(this.datasets.length)},i).draw())},this)},this)}})}.call(this),function(){"use strict";var t=this,i=t.Chart,e=i.helpers,s={segmentShowStroke:!0,segmentStrokeColor:"#fff",segmentStrokeWidth:2,percentageInnerCutout:50,animationSteps:100,animationEasing:"easeOutBounce",animateRotate:!0,animateScale:!1,legendTemplate:'<ul class="<%=name.toLowerCase()%>-legend"><% for (var i=0; i<segments.length; i++){%><li><span style="background-color:<%=segments[i].fillColor%>"></span><%if(segments[i].label){%><%=segments[i].label%><%}%></li><%}%></ul>'};i.Type.extend({name:"Doughnut",defaults:s,initialize:function(t){this.segments=[],this.outerRadius=(e.min([this.chart.width,this.chart.height])-this.options.segmentStrokeWidth/2)/2,this.SegmentArc=i.Arc.extend({ctx:this.chart.ctx,x:this.chart.width/2,y:this.chart.height/2}),this.options.showTooltips&&e.bindEvents(this,this.options.tooltipEvents,function(t){var i="mouseout"!==t.type?this.getSegmentsAtEvent(t):[];e.each(this.segments,function(t){t.restore(["fillColor"])}),e.each(i,function(t){t.fillColor=t.highlightColor}),this.showTooltip(i)}),this.calculateTotal(t),e.each(t,function(t,i){this.addData(t,i,!0)},this),this.render()},getSegmentsAtEvent:function(t){var i=[],s=e.getRelativePosition(t);return e.each(this.segments,function(t){t.inRange(s.x,s.y)&&i.push(t)},this),i},addData:function(t,i,e){var s=i||this.segments.length;this.segments.splice(s,0,new this.SegmentArc({value:t.value,outerRadius:this.options.animateScale?0:this.outerRadius,innerRadius:this.options.animateScale?0:this.outerRadius/100*this.options.percentageInnerCutout,fillColor:t.color,highlightColor:t.highlight||t.color,showStroke:this.options.segmentShowStroke,strokeWidth:this.options.segmentStrokeWidth,strokeColor:this.options.segmentStrokeColor,startAngle:1.5*Math.PI,circumference:this.options.animateRotate?0:this.calculateCircumference(t.value),label:t.label})),e||(this.reflow(),this.update())},calculateCircumference:function(t){return 2*Math.PI*(t/this.total)},calculateTotal:function(t){this.total=0,e.each(t,function(t){this.total+=t.value},this)},update:function(){this.calculateTotal(this.segments),e.each(this.activeElements,function(t){t.restore(["fillColor"])}),e.each(this.segments,function(t){t.save()}),this.render()},removeData:function(t){var i=e.isNumber(t)?t:this.segments.length-1;this.segments.splice(i,1),this.reflow(),this.update()},reflow:function(){e.extend(this.SegmentArc.prototype,{x:this.chart.width/2,y:this.chart.height/2}),this.outerRadius=(e.min([this.chart.width,this.chart.height])-this.options.segmentStrokeWidth/2)/2,e.each(this.segments,function(t){t.update({outerRadius:this.outerRadius,innerRadius:this.outerRadius/100*this.options.percentageInnerCutout})},this)},draw:function(t){var i=t?t:1;this.clear(),e.each(this.segments,function(t,e){t.transition({circumference:this.calculateCircumference(t.value),outerRadius:this.outerRadius,innerRadius:this.outerRadius/100*this.options.percentageInnerCutout},i),t.endAngle=t.startAngle+t.circumference,t.draw(),0===e&&(t.startAngle=1.5*Math.PI),e<this.segments.length-1&&(this.segments[e+1].startAngle=t.endAngle)},this)}}),i.types.Doughnut.extend({name:"Pie",defaults:e.merge(s,{percentageInnerCutout:0})})}.call(this),function(){"use strict";var t=this,i=t.Chart,e=i.helpers,s={scaleShowGridLines:!0,scaleGridLineColor:"rgba(0,0,0,.05)",scaleGridLineWidth:1,scaleShowHorizontalLines:!0,scaleShowVerticalLines:!0,bezierCurve:!0,bezierCurveTension:.4,pointDot:!0,pointDotRadius:4,pointDotStrokeWidth:1,pointHitDetectionRadius:20,datasetStroke:!0,datasetStrokeWidth:2,datasetFill:!0,legendTemplate:'<ul class="<%=name.toLowerCase()%>-legend"><% for (var i=0; i<datasets.length; i++){%><li><span style="background-color:<%=datasets[i].strokeColor%>"></span><%if(datasets[i].label){%><%=datasets[i].label%><%}%></li><%}%></ul>'};i.Type.extend({name:"Line",defaults:s,initialize:function(t){this.PointClass=i.Point.extend({strokeWidth:this.options.pointDotStrokeWidth,radius:this.options.pointDotRadius,display:this.options.pointDot,hitDetectionRadius:this.options.pointHitDetectionRadius,ctx:this.chart.ctx,inRange:function(t){return Math.pow(t-this.x,2)<Math.pow(this.radius+this.hitDetectionRadius,2)}}),this.datasets=[],this.options.showTooltips&&e.bindEvents(this,this.options.tooltipEvents,function(t){var i="mouseout"!==t.type?this.getPointsAtEvent(t):[];this.eachPoints(function(t){t.restore(["fillColor","strokeColor"])}),e.each(i,function(t){t.fillColor=t.highlightFill,t.strokeColor=t.highlightStroke}),this.showTooltip(i)}),e.each(t.datasets,function(i){var s={label:i.label||null,fillColor:i.fillColor,strokeColor:i.strokeColor,pointColor:i.pointColor,pointStrokeColor:i.pointStrokeColor,points:[]};this.datasets.push(s),e.each(i.data,function(e,n){s.points.push(new this.PointClass({value:e,label:t.labels[n],datasetLabel:i.label,strokeColor:i.pointStrokeColor,fillColor:i.pointColor,highlightFill:i.pointHighlightFill||i.pointColor,highlightStroke:i.pointHighlightStroke||i.pointStrokeColor}))},this),this.buildScale(t.labels),this.eachPoints(function(t,i){e.extend(t,{x:this.scale.calculateX(i),y:this.scale.endPoint}),t.save()},this)},this),this.render()},update:function(){this.scale.update(),e.each(this.activeElements,function(t){t.restore(["fillColor","strokeColor"])}),this.eachPoints(function(t){t.save()}),this.render()},eachPoints:function(t){e.each(this.datasets,function(i){e.each(i.points,t,this)},this)},getPointsAtEvent:function(t){var i=[],s=e.getRelativePosition(t);return e.each(this.datasets,function(t){e.each(t.points,function(t){t.inRange(s.x,s.y)&&i.push(t)})},this),i},buildScale:function(t){var s=this,n=function(){var t=[];return s.eachPoints(function(i){t.push(i.value)}),t},o={templateString:this.options.scaleLabel,height:this.chart.height,width:this.chart.width,ctx:this.chart.ctx,textColor:this.options.scaleFontColor,fontSize:this.options.scaleFontSize,fontStyle:this.options.scaleFontStyle,fontFamily:this.options.scaleFontFamily,valuesCount:t.length,beginAtZero:this.options.scaleBeginAtZero,integersOnly:this.options.scaleIntegersOnly,calculateYRange:function(t){var i=e.calculateScaleRange(n(),t,this.fontSize,this.beginAtZero,this.integersOnly);e.extend(this,i)},xLabels:t,font:e.fontString(this.options.scaleFontSize,this.options.scaleFontStyle,this.options.scaleFontFamily),lineWidth:this.options.scaleLineWidth,lineColor:this.options.scaleLineColor,showHorizontalLines:this.options.scaleShowHorizontalLines,showVerticalLines:this.options.scaleShowVerticalLines,gridLineWidth:this.options.scaleShowGridLines?this.options.scaleGridLineWidth:0,gridLineColor:this.options.scaleShowGridLines?this.options.scaleGridLineColor:"rgba(0,0,0,0)",padding:this.options.showScale?0:this.options.pointDotRadius+this.options.pointDotStrokeWidth,showLabels:this.options.scaleShowLabels,display:this.options.showScale};this.options.scaleOverride&&e.extend(o,{calculateYRange:e.noop,steps:this.options.scaleSteps,stepValue:this.options.scaleStepWidth,min:this.options.scaleStartValue,max:this.options.scaleStartValue+this.options.scaleSteps*this.options.scaleStepWidth}),this.scale=new i.Scale(o)},addData:function(t,i){e.each(t,function(t,e){this.datasets[e].points.push(new this.PointClass({value:t,label:i,x:this.scale.calculateX(this.scale.valuesCount+1),y:this.scale.endPoint,strokeColor:this.datasets[e].pointStrokeColor,fillColor:this.datasets[e].pointColor}))},this),this.scale.addXLabel(i),this.update()},removeData:function(){this.scale.removeXLabel(),e.each(this.datasets,function(t){t.points.shift()},this),this.update()},reflow:function(){var t=e.extend({height:this.chart.height,width:this.chart.width});this.scale.update(t)},draw:function(t){var i=t||1;this.clear();var s=this.chart.ctx,n=function(t){return null!==t.value},o=function(t,i,s){return e.findNextWhere(i,n,s)||t},a=function(t,i,s){return e.findPreviousWhere(i,n,s)||t};this.scale.draw(i),e.each(this.datasets,function(t){var h=e.where(t.points,n);e.each(t.points,function(t,e){t.hasValue()&&t.transition({y:this.scale.calculateY(t.value),x:this.scale.calculateX(e)},i)},this),this.options.bezierCurve&&e.each(h,function(t,i){var s=i>0&&i<h.length-1?this.options.bezierCurveTension:0;t.controlPoints=e.splineCurve(a(t,h,i),t,o(t,h,i),s),t.controlPoints.outer.y>this.scale.endPoint?t.controlPoints.outer.y=this.scale.endPoint:t.controlPoints.outer.y<this.scale.startPoint&&(t.controlPoints.outer.y=this.scale.startPoint),t.controlPoints.inner.y>this.scale.endPoint?t.controlPoints.inner.y=this.scale.endPoint:t.controlPoints.inner.y<this.scale.startPoint&&(t.controlPoints.inner.y=this.scale.startPoint)},this),s.lineWidth=this.options.datasetStrokeWidth,s.strokeStyle=t.strokeColor,s.beginPath(),e.each(h,function(t,i){if(0===i)s.moveTo(t.x,t.y);else if(this.options.bezierCurve){var e=a(t,h,i);s.bezierCurveTo(e.controlPoints.outer.x,e.controlPoints.outer.y,t.controlPoints.inner.x,t.controlPoints.inner.y,t.x,t.y)}else s.lineTo(t.x,t.y)},this),s.stroke(),this.options.datasetFill&&h.length>0&&(s.lineTo(h[h.length-1].x,this.scale.endPoint),s.lineTo(h[0].x,this.scale.endPoint),s.fillStyle=t.fillColor,s.closePath(),s.fill()),e.each(h,function(t){t.draw()})},this)}})}.call(this),function(){"use strict";var t=this,i=t.Chart,e=i.helpers,s={scaleShowLabelBackdrop:!0,scaleBackdropColor:"rgba(255,255,255,0.75)",scaleBeginAtZero:!0,scaleBackdropPaddingY:2,scaleBackdropPaddingX:2,scaleShowLine:!0,segmentShowStroke:!0,segmentStrokeColor:"#fff",segmentStrokeWidth:2,animationSteps:100,animationEasing:"easeOutBounce",animateRotate:!0,animateScale:!1,legendTemplate:'<ul class="<%=name.toLowerCase()%>-legend"><% for (var i=0; i<segments.length; i++){%><li><span style="background-color:<%=segments[i].fillColor%>"></span><%if(segments[i].label){%><%=segments[i].label%><%}%></li><%}%></ul>'};i.Type.extend({name:"PolarArea",defaults:s,initialize:function(t){this.segments=[],this.SegmentArc=i.Arc.extend({showStroke:this.options.segmentShowStroke,strokeWidth:this.options.segmentStrokeWidth,strokeColor:this.options.segmentStrokeColor,ctx:this.chart.ctx,innerRadius:0,x:this.chart.width/2,y:this.chart.height/2}),this.scale=new i.RadialScale({display:this.options.showScale,fontStyle:this.options.scaleFontStyle,fontSize:this.options.scaleFontSize,fontFamily:this.options.scaleFontFamily,fontColor:this.options.scaleFontColor,showLabels:this.options.scaleShowLabels,showLabelBackdrop:this.options.scaleShowLabelBackdrop,backdropColor:this.options.scaleBackdropColor,backdropPaddingY:this.options.scaleBackdropPaddingY,backdropPaddingX:this.options.scaleBackdropPaddingX,lineWidth:this.options.scaleShowLine?this.options.scaleLineWidth:0,lineColor:this.options.scaleLineColor,lineArc:!0,width:this.chart.width,height:this.chart.height,xCenter:this.chart.width/2,yCenter:this.chart.height/2,ctx:this.chart.ctx,templateString:this.options.scaleLabel,valuesCount:t.length}),this.updateScaleRange(t),this.scale.update(),e.each(t,function(t,i){this.addData(t,i,!0)},this),this.options.showTooltips&&e.bindEvents(this,this.options.tooltipEvents,function(t){var i="mouseout"!==t.type?this.getSegmentsAtEvent(t):[];e.each(this.segments,function(t){t.restore(["fillColor"])}),e.each(i,function(t){t.fillColor=t.highlightColor}),this.showTooltip(i)}),this.render()},getSegmentsAtEvent:function(t){var i=[],s=e.getRelativePosition(t);return e.each(this.segments,function(t){t.inRange(s.x,s.y)&&i.push(t)},this),i},addData:function(t,i,e){var s=i||this.segments.length;this.segments.splice(s,0,new this.SegmentArc({fillColor:t.color,highlightColor:t.highlight||t.color,label:t.label,value:t.value,outerRadius:this.options.animateScale?0:this.scale.calculateCenterOffset(t.value),circumference:this.options.animateRotate?0:this.scale.getCircumference(),startAngle:1.5*Math.PI})),e||(this.reflow(),this.update())},removeData:function(t){var i=e.isNumber(t)?t:this.segments.length-1;this.segments.splice(i,1),this.reflow(),this.update()},calculateTotal:function(t){this.total=0,e.each(t,function(t){this.total+=t.value},this),this.scale.valuesCount=this.segments.length},updateScaleRange:function(t){var i=[];e.each(t,function(t){i.push(t.value)});var s=this.options.scaleOverride?{steps:this.options.scaleSteps,stepValue:this.options.scaleStepWidth,min:this.options.scaleStartValue,max:this.options.scaleStartValue+this.options.scaleSteps*this.options.scaleStepWidth}:e.calculateScaleRange(i,e.min([this.chart.width,this.chart.height])/2,this.options.scaleFontSize,this.options.scaleBeginAtZero,this.options.scaleIntegersOnly);e.extend(this.scale,s,{size:e.min([this.chart.width,this.chart.height]),xCenter:this.chart.width/2,yCenter:this.chart.height/2})},update:function(){this.calculateTotal(this.segments),e.each(this.segments,function(t){t.save()}),this.render()},reflow:function(){e.extend(this.SegmentArc.prototype,{x:this.chart.width/2,y:this.chart.height/2}),this.updateScaleRange(this.segments),this.scale.update(),e.extend(this.scale,{xCenter:this.chart.width/2,yCenter:this.chart.height/2}),e.each(this.segments,function(t){t.update({outerRadius:this.scale.calculateCenterOffset(t.value)})},this)},draw:function(t){var i=t||1;this.clear(),e.each(this.segments,function(t,e){t.transition({circumference:this.scale.getCircumference(),outerRadius:this.scale.calculateCenterOffset(t.value)},i),t.endAngle=t.startAngle+t.circumference,0===e&&(t.startAngle=1.5*Math.PI),e<this.segments.length-1&&(this.segments[e+1].startAngle=t.endAngle),t.draw()},this),this.scale.draw()}})}.call(this),function(){"use strict";var t=this,i=t.Chart,e=i.helpers;i.Type.extend({name:"Radar",defaults:{scaleShowLine:!0,angleShowLineOut:!0,scaleShowLabels:!1,scaleBeginAtZero:!0,angleLineColor:"rgba(0,0,0,.1)",angleLineWidth:1,pointLabelFontFamily:"'Arial'",pointLabelFontStyle:"normal",pointLabelFontSize:10,pointLabelFontColor:"#666",pointDot:!0,pointDotRadius:3,pointDotStrokeWidth:1,pointHitDetectionRadius:20,datasetStroke:!0,datasetStrokeWidth:2,datasetFill:!0,legendTemplate:'<ul class="<%=name.toLowerCase()%>-legend"><% for (var i=0; i<datasets.length; i++){%><li><span style="background-color:<%=datasets[i].strokeColor%>"></span><%if(datasets[i].label){%><%=datasets[i].label%><%}%></li><%}%></ul>'},initialize:function(t){this.PointClass=i.Point.extend({strokeWidth:this.options.pointDotStrokeWidth,radius:this.options.pointDotRadius,display:this.options.pointDot,hitDetectionRadius:this.options.pointHitDetectionRadius,ctx:this.chart.ctx}),this.datasets=[],this.buildScale(t),this.options.showTooltips&&e.bindEvents(this,this.options.tooltipEvents,function(t){var i="mouseout"!==t.type?this.getPointsAtEvent(t):[];this.eachPoints(function(t){t.restore(["fillColor","strokeColor"])}),e.each(i,function(t){t.fillColor=t.highlightFill,t.strokeColor=t.highlightStroke}),this.showTooltip(i)}),e.each(t.datasets,function(i){var s={label:i.label||null,fillColor:i.fillColor,strokeColor:i.strokeColor,pointColor:i.pointColor,pointStrokeColor:i.pointStrokeColor,points:[]};this.datasets.push(s),e.each(i.data,function(e,n){var o;this.scale.animation||(o=this.scale.getPointPosition(n,this.scale.calculateCenterOffset(e))),s.points.push(new this.PointClass({value:e,label:t.labels[n],datasetLabel:i.label,x:this.options.animation?this.scale.xCenter:o.x,y:this.options.animation?this.scale.yCenter:o.y,strokeColor:i.pointStrokeColor,fillColor:i.pointColor,highlightFill:i.pointHighlightFill||i.pointColor,highlightStroke:i.pointHighlightStroke||i.pointStrokeColor}))},this)},this),this.render()},eachPoints:function(t){e.each(this.datasets,function(i){e.each(i.points,t,this)},this)},getPointsAtEvent:function(t){var i=e.getRelativePosition(t),s=e.getAngleFromPoint({x:this.scale.xCenter,y:this.scale.yCenter},i),n=2*Math.PI/this.scale.valuesCount,o=Math.round((s.angle-1.5*Math.PI)/n),a=[];return(o>=this.scale.valuesCount||0>o)&&(o=0),s.distance<=this.scale.drawingArea&&e.each(this.datasets,function(t){a.push(t.points[o])}),a},buildScale:function(t){this.scale=new i.RadialScale({display:this.options.showScale,fontStyle:this.options.scaleFontStyle,fontSize:this.options.scaleFontSize,fontFamily:this.options.scaleFontFamily,fontColor:this.options.scaleFontColor,showLabels:this.options.scaleShowLabels,showLabelBackdrop:this.options.scaleShowLabelBackdrop,backdropColor:this.options.scaleBackdropColor,backdropPaddingY:this.options.scaleBackdropPaddingY,backdropPaddingX:this.options.scaleBackdropPaddingX,lineWidth:this.options.scaleShowLine?this.options.scaleLineWidth:0,lineColor:this.options.scaleLineColor,angleLineColor:this.options.angleLineColor,angleLineWidth:this.options.angleShowLineOut?this.options.angleLineWidth:0,pointLabelFontColor:this.options.pointLabelFontColor,pointLabelFontSize:this.options.pointLabelFontSize,pointLabelFontFamily:this.options.pointLabelFontFamily,pointLabelFontStyle:this.options.pointLabelFontStyle,height:this.chart.height,width:this.chart.width,xCenter:this.chart.width/2,yCenter:this.chart.height/2,ctx:this.chart.ctx,templateString:this.options.scaleLabel,labels:t.labels,valuesCount:t.datasets[0].data.length}),this.scale.setScaleSize(),this.updateScaleRange(t.datasets),this.scale.buildYLabels()},updateScaleRange:function(t){var i=function(){var i=[];return e.each(t,function(t){t.data?i=i.concat(t.data):e.each(t.points,function(t){i.push(t.value)})}),i}(),s=this.options.scaleOverride?{steps:this.options.scaleSteps,stepValue:this.options.scaleStepWidth,min:this.options.scaleStartValue,max:this.options.scaleStartValue+this.options.scaleSteps*this.options.scaleStepWidth}:e.calculateScaleRange(i,e.min([this.chart.width,this.chart.height])/2,this.options.scaleFontSize,this.options.scaleBeginAtZero,this.options.scaleIntegersOnly);e.extend(this.scale,s)},addData:function(t,i){this.scale.valuesCount++,e.each(t,function(t,e){var s=this.scale.getPointPosition(this.scale.valuesCount,this.scale.calculateCenterOffset(t));this.datasets[e].points.push(new this.PointClass({value:t,label:i,x:s.x,y:s.y,strokeColor:this.datasets[e].pointStrokeColor,fillColor:this.datasets[e].pointColor}))},this),this.scale.labels.push(i),this.reflow(),this.update()},removeData:function(){this.scale.valuesCount--,this.scale.labels.shift(),e.each(this.datasets,function(t){t.points.shift()},this),this.reflow(),this.update()},update:function(){this.eachPoints(function(t){t.save()}),this.reflow(),this.render()},reflow:function(){e.extend(this.scale,{width:this.chart.width,height:this.chart.height,size:e.min([this.chart.width,this.chart.height]),xCenter:this.chart.width/2,yCenter:this.chart.height/2}),this.updateScaleRange(this.datasets),this.scale.setScaleSize(),this.scale.buildYLabels()},draw:function(t){var i=t||1,s=this.chart.ctx;this.clear(),this.scale.draw(),e.each(this.datasets,function(t){e.each(t.points,function(t,e){t.hasValue()&&t.transition(this.scale.getPointPosition(e,this.scale.calculateCenterOffset(t.value)),i)},this),s.lineWidth=this.options.datasetStrokeWidth,s.strokeStyle=t.strokeColor,s.beginPath(),e.each(t.points,function(t,i){0===i?s.moveTo(t.x,t.y):s.lineTo(t.x,t.y)},this),s.closePath(),s.stroke(),s.fillStyle=t.fillColor,s.fill(),e.each(t.points,function(t){t.hasValue()&&t.draw()})},this)}})}.call(this);

/**
 * The Circle Menu object represents a choice menu of multiple menu items. The type of data provider value for a circle menu control should point to a property in the data provider that would follow the same rules as hard coding an array of items.<br><br>
 * <b>Sample Declaration</b><br>
 * <pre>
 * {
 *   component: $ui.CircleMenu,
 *    items: [
 *    {
 *        caption: 'music',
 *        visible: false,
 *        img: 'img/music.png'
 *    },
 *    {
 *        caption: 'maps',
 *        img: 'img/maps.png'
 *    }],
 *    onclick: function(item) {
 *        console.log(item.caption + ' clicked');
 *    }
 *}
 * @namespace CircleMenu
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {$ui.CircleMenuItem[]} [items] - The items property is an array of menu items to be displayed in the control
 * @property {CircleMenuClickEvent} [onclick] - This event fires when an item in the menu is clicked. The parameter passed to the event is [the item]{@link $ui.CircleMenuItem} which was clicked.
 */
function $ui_CircleMenu(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom,'ui-circle-menu');
	
	// Holds our indicators
	object._protected.indicators = [];
	
	// Create our inner scrollable area
	object.dom.inner = document.createElement('div');
	$ui.addClass(object.dom.inner, 'inner');
	object.dom.appendChild(object.dom.inner);
	
	// Create indicator area
	object.dom.indicatorContainer = document.createElement('div');
	$ui.addClass(object.dom.indicatorContainer, 'indicator-container');
	object.dom.appendChild(object.dom.indicatorContainer);
	
	// Items property
	if (object.items == undefined) {
		object.items = [];
	}
	object._protected.items = object.items;
	Object.defineProperty(object, 'items', {
		get: function() {return this._protected.items;},
		set: function() {
			console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','items'));					
		},
		configurable: false}
	);
	
	// Re layout the menu items
	object._recalculateLayout = function() {
		if (this.items.length === 0) return;
		var i,
			x,
			y,
			item,
			coord,
			visibleItems = [],
			offsetHeight = this.dom.offsetHeight,
			offsetWidth = this.dom.offsetWidth,
			coordinates = [];
		// Gather only our visible items
		for (i = 0; i < this.items.length; i++) {
			item = this.items[i];
			if (item.visible == true) {
				visibleItems.push(item);
			}
		}
		var numItems = visibleItems.length,
			numIndicators = Math.ceil(numItems/6),
			indicator,
			size = visibleItems[0].getSize();
			
		// Clear old indicators
		for (i = 0; i < this._protected.indicators.length; i++) {
			indicator = this._protected.indicators[i];
			indicator.parentNode.removeChild(indicator);
		}
		this._protected.indicators = [];
			
		// Draw our page indicators if necessary
		if (numIndicators > 1) {
			this.dom.indicatorContainer.style.display = 'block';
			this.dom.inner.style.cursor = 'pointer';
			// Handle our gestures
			this._protected.hammer = new Hammer(this.dom.inner);
			this._protected.hammer.on('pan', this._onpan);
			this._protected.hammer.on('panend', this._onpanend);
			this._protected.hammer.on('pancancel', this._onpanend);
			this._protected.hammer.on('swipeleft', this._onswipeleft);
			this._protected.hammer.on('swiperight', this._onswiperight);
			// Set our indicators
			for (i = 0; i < numIndicators; i++) {
				indicator = document.createElement('div');
				indicator._index = i;
				$ui.addClass(indicator,'indicator');
				this.dom.indicatorContainer.appendChild(indicator);
				this._protected.indicators.push(indicator);
				indicator.inner = document.createElement('div');
				$ui.addClass(indicator.inner, 'inner theme-circle-menu-indicator');
				if (i == 0) {
					$ui.addClass(indicator.inner,'theme-circle-menu-indicator-selected');
				}
				indicator.appendChild(indicator.inner);
			}
			this._protected.selectedIndicator = this._protected.indicators[0];
			this.dom.indicatorContainer.style.width = (numIndicators * 40) + 'px';
			this.dom.inner.style['-webkit-transition'] = '-webkit-transform 0.1s ease-out';
			this.dom.inner.style['-webkit-transform'] = 'translate3d(0px,0px,0px)';
		} else {
			this.dom.indicatorContainer.style.display = 'none';
			this.dom.inner.style.cursor = 'default';
			this._protected.hammer = undefined;
			this._protected.selectedIndicator = undefined;
		}
		this.dom.inner.style.width = (numIndicators * 100) + '%';
			
		// Determine our layout
		if ($system && $system.isClientDevice) {
			var coord,
				row = 0,
				col = 0,
				maxItems = (numItems > 6) ? 6 : numItems,
				slot = Math.floor(offsetWidth/2),
				xOffset = Math.floor(slot/2 - size/2),
				rowHeight = Math.floor(offsetHeight/3),
				yOffset = Math.floor(rowHeight/2 - size/2);
			// Loop through and set our coordinates
			for (i = 0; i < maxItems; i++) {
				coord = {
					X: (col * slot) + xOffset,
					Y: (row * rowHeight) + yOffset
				};
				coordinates.push(coord);
				col++
				if (col > 1) {
					row++;
					col = 0;
				}
			}
		} else {
			switch (true) {
				case (numItems <= 3):
					var buffer = (numItems === 2) ? Math.floor(size/2) : 0, // This provides some spacing on the left/right
						slot = Math.floor((offsetWidth-(buffer*2))/numItems),
						xOffset = Math.floor(slot/2 - size/2);
					y = Math.floor(offsetHeight/2 - size/2);
					for (i = 0; i < numItems; i++) {
						coord = {
							X: (i * slot) + buffer + xOffset,
							Y: y
						};
						coordinates.push(coord);
					}
					break;
				case (numItems <= 6):
						var slot = Math.floor(offsetWidth/3),
							xOffset = Math.floor(slot/2 - size/2),
							row = Math.floor(offsetHeight/2),
							yOffset = Math.floor(row/2 - size/2);
						// Top row
						for (i = 0; i < 3; i++) {
							coord = {
								X: (i * slot) + xOffset,
								Y: yOffset
							};
							coordinates.push(coord);
						}
						// Now bottom row
						var buffer = ((numItems-3) === 2) ? Math.floor(size/2) : 0;
						slot = Math.floor((offsetWidth-(buffer*2))/(numItems-3));
						xOffset = Math.floor(slot/2 - size/2);
						for (i = 3; i < numItems; i++) {
							coord = {
								X: ((i-3) * slot) + buffer + xOffset,
								Y: row + yOffset
							};
							coordinates.push(coord);
						}
					break;				
				case (numItems > 6):
					var numInserted = 0,
						page = 0;
					while (numInserted < numItems) {
						var slot = Math.floor(offsetWidth/3),
							xOffset = Math.floor(slot/2 - size/2) + (page * offsetWidth),
							row = Math.floor(offsetHeight/2),
							yOffset = Math.floor(row/2 - size/2);
						// Top row
						for (i = 0; (i < 3) && (numInserted < numItems); i++) {
							coord = {
								X: (i * slot) + xOffset,
								Y: yOffset
							};
							coordinates.push(coord);
							numInserted++;
						}
						if (numInserted < numItems) {
							// Now bottom row
							var buffer = ((numItems - numInserted) === 2) ? Math.floor(size/2) : 0,
								numSlots = ((numItems - numInserted) >= 3) ? 3 : (numItems - numInserted);
							slot = Math.floor((offsetWidth-(buffer*2))/numSlots);
							xOffset = Math.floor(slot/2 - size/2) + (page * offsetWidth);
							for (i = 3; (i < numItems) && (numInserted < numItems) && (i < 6); i++) {
								coord = {
									X: ((i-3) * slot) + buffer + xOffset,
									Y: row + yOffset
								};
								coordinates.push(coord);
								numInserted++;
							}
						}
						page++;
					}
					break;
			}
		}
		// Set our coordinates
		for (i = 0; i < visibleItems.length; i++) {
			item = visibleItems[i];
			coord = coordinates[i];
			item.dom.style['-webkit-transform'] = 'translate('+coord.X+'px,'+coord.Y+'px)';
		}
	}.$bind(object);
	
	// Reset our transition flag for menu items to know not to click when in transition
	object._resetTransition = function() {
		this._protected.inTransition = false;
	}.$bind(object);
	
	// Handle the dragging of the menu
	object._onpan = function(event) {
		if (this._protected.selectedIndicator == undefined) return;
		this._protected.inTransition = true;
		if (this._protected.swiping == true) return;
		var location = 0;
		if (this._protected.selectedIndicator._index > 0) {
			location = (this._protected.selectedIndicator._index * this.dom.offsetWidth)*(-1);
		}
		this.dom.inner.style['-webkit-transition'] = '';
		this.dom.inner.style['-webkit-transform'] = 'translate3d('+ (location + event.deltaX) + 'px,0px,0px)';
	}.$bind(object);
	
	// Handle the drag end of the menu
	object._onpanend = function(event) {
		window.setTimeout(this._resetTransition,0);
		// Don't adjust if there was a swipe gesture
		if (this._protected.swiping == true) {
			this._protected.swiping = false;
			return;
		}
		if(Math.abs(event.deltaX) > (this.dom.offsetWidth / 2)) {
			if(event.deltaX > 0) {
				if (this._protected.selectedIndicator && this._protected.selectedIndicator._index > 0) {
					this._decreaseIndicator();
				} else {
					this.dom.inner.style['-webkit-transition'] = '-webkit-transform 0.1s ease-out';
					this.dom.inner.style['-webkit-transform'] = 'translate3d(-'+ (this._protected.selectedIndicator._index * this.dom.offsetWidth) +'px,0px,0px)';
				}
			} else {
				if (this._protected.selectedIndicator && this._protected.selectedIndicator._index < this._protected.indicators.length -1) {
					this._increaseIndicator();
				} else {
					this.dom.inner.style['-webkit-transition'] = '-webkit-transform 0.1s ease-out';
					this.dom.inner.style['-webkit-transform'] = 'translate3d(-'+ (this._protected.selectedIndicator._index * this.dom.offsetWidth) +'px,0px,0px)';
				}
			}	
		} else {
			this.dom.inner.style['-webkit-transition'] = '-webkit-transform 0.1s ease-out';
			this.dom.inner.style['-webkit-transform'] = 'translate3d(-'+ (this._protected.selectedIndicator._index * this.dom.offsetWidth) +'px,0px,0px)';
		}
	}.$bind(object);
	
	// Handle the swipe left of the menu
	object._onswipeleft = function(event) {
		this._protected.swiping = true;
		this._increaseIndicator();
	}.$bind(object);
	
	// Handle the swipe right of the menu
	object._onswiperight = function(event) {
		this._protected.swiping = true;
		this._decreaseIndicator();
	}.$bind(object);
	
	// Increases the indicator location and current selected indicator
	object._increaseIndicator = function() {
		if (this._protected.selectedIndicator == undefined) return;
		if (this._protected.selectedIndicator._index <= this._protected.indicators.length - 2) {
			this._protected.selectedIndicator = this._protected.indicators[this._protected.selectedIndicator._index + 1];
			$ui.addClass(this._protected.selectedIndicator.inner,'theme-circle-menu-indicator-selected');
			var i,
				indicator;
			for (i = 0; i < this._protected.indicators.length; i++) {
				indicator = this._protected.indicators[i];
				if (indicator != this._protected.selectedIndicator) {
					$ui.removeClass(indicator.inner,'theme-circle-menu-indicator-selected');
				}
			}
		} 	
		this.dom.inner.style['-webkit-transition'] = '-webkit-transform 0.1s ease-out';
		this.dom.inner.style['-webkit-transform'] = 'translate3d(-'+ (this._protected.selectedIndicator._index * this.dom.offsetWidth) +'px,0px,0px)';
	}.$bind(object);
	
	// Decreases the indicator location and current selected indicator
	object._decreaseIndicator = function() {
		if (this._protected.selectedIndicator == undefined) return;
		if (this._protected.selectedIndicator._index > 0) {
			this._protected.selectedIndicator = this._protected.indicators[this._protected.selectedIndicator._index - 1];
			$ui.addClass(this._protected.selectedIndicator.inner,'theme-circle-menu-indicator-selected');
			var i,
				indicator;
			for (i = 0; i < this._protected.indicators.length; i++) {
				indicator = this._protected.indicators[i];
				if (indicator != this._protected.selectedIndicator) {
					$ui.removeClass(indicator.inner,'theme-circle-menu-indicator-selected');
				}
			}
		} 	
		this.dom.inner.style['-webkit-transition'] = '-webkit-transform 0.1s ease-out';
		this.dom.inner.style['-webkit-transform'] = 'translate3d(-'+ (this._protected.selectedIndicator._index * this.dom.offsetWidth) +'px,0px,0px)';
	}.$bind(object);
	
	// Private function to add a new item to the list
	object._addItem = function(item) {
		item.parent = this;
		itemDom = new $ui_CircleMenuItem(item, this.screen);
		if (itemDom) {
			this.dom.inner.appendChild(itemDom);
			return true;
		} else {
			return false;
		}
	}.$bind(object);
	
	/** 
	 * You can add an item to the end of the menu by calling the addItem function and passing in an object that matches the a menu item
	 * @function addItem
	 * @memberof $ui.CircleMenu
	 * @param {$ui.CircleMenuItem} item - Item to be added to the menu
	 */
	object.addItem = function(item) {
		if (this._addItem(item)) {
			this.items.push(item);
			return true;
		} else {
			return false;
		}
		this._recalculateLayout();
	}.$bind(object);
	
	/** 
	 * You can refresh all the items in a menu by calling the refreshItems function with an array of new items
	 * @function refreshItems
	 * @memberof $ui.CircleMenu
	 * @param {$ui.CircleMenuItem[]} items - Array of items to refresh the menu
	 */
	object.refreshItems = function(itemArray) {
		if (itemArray == undefined) return; // No data provided
		var i,
			item;
		if (this.items) {
			// Remove all existing items first
			for (i = this.items.length - 1; i >= 0; i--) {
				item = this.items[i];
				try {
					if (item.dom && item.dom.parentNode) {
						item.dom.parentNode.removeChild(item.dom);
					}
				} catch (ex) {
					console.log('$ui.List: ' + ex);
				}
				this.items.pop();
				if (item._destroy) {
					item._destroy();
				}
			}
		}
		this.addItemBatch(itemArray);
	}.$bind(object);
	
	/** 
	 * This function is much like the refreshItems function but instead it loads a list of circle menu items to the end of the current menu and does not replace the existing menu items.
	 * @function addItemBatch
	 * @memberof $ui.CircleMenu
	 * @param {$ui.CircleMenuItem[]} items - Array of items to be added to the menu
	 */
	object.addItemBatch = function(itemArray) {
		var i,
			item;
		// Add all new items into the list
		for (i = 0; i < itemArray.length; i++) {
			item = itemArray[i];
			if (this._addItem(item)) {
				this.items.push(item);
			}
		}
		this._recalculateLayout();
	}.$bind(object);
	
	/** 
	 * Insert item works similar to addItem but instead will insert the item into the menu at the index specified. If an invalid index is specified it will result in failure to insert the item. To insert an item at the top of a menu call insert with the index of 0.
	 * @function insertItem
	 * @memberof $ui.CircleMenu
	 * @param {$ui.CircleMenuItem} item - Item to be inserted into the menu
	 * @param {number} index - Index to insert the item
	 */
	object.insertItem = function(item, index) {
		item.parent = this;
		if (index < 0) {
			return false;
		} else if (this.items.length == 0) {
			this.addItem(item);
			return true;
		} else if (index > this.items.length - 1) {
			this.addItem(item);
			return true;
		} else { // Insert it at the index
			var existingItem = this.items[index],
				itemDom = new $ui_CircleMenuItem(item, this.screen);
			this.items.splice(index, 0, item);
			this.dom.inner.insertBefore(itemDom, existingItem.dom);
			return true;
		} 
		return false;
	}.$bind(object);
	
	// Private function to handle provider updates
	object._providerUpdate = function(value) {
		this.refreshItems(value);
	}.$bind(object);
	
	// Handle resize of screen
	object._onresize = function() {
		this._recalculateLayout();
	}.$bind(object);
	
	// If there is no data provider then just create the items
	if (!object.provider) {
		var i,
			item,
			itemDom;
		for (i = 0; i < object.items.length; i++) {
			item = object.items[i];
			object._addItem(item);
		}
		// Re-calculate once the screen dimensions have been calculated
		setTimeout(object._onresize,0); 
	}	
	
	return object.dom;
}

/**
 * The {@link $ui.CircleMenu} <b>onclick</b> event will fire when the user clicks a menu item
 * @callback CircleMenuClickEvent
 * @param {$ui.CircleMenuItem} item - The menu item that the user clicked
 */
/**
 * A circle menu item is used within a [Circle Menu]{@link $ui.CircleMenu}.  <b>NOTE: It cannot be defined on its own outside of a circle menu</b> 
 * @namespace CircleMenuItem
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {string} caption - Text to appear on the menu item
 * @property {string} img - Path to the image to be displayed in the menu item
 */
function $ui_CircleMenuItem(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom,'menu-item');
	
	// Create inner circle
	object.dom.inner = document.createElement('div');
	object.dom.inner.model = object;
	$ui.addClass(object.dom.inner,'circle theme-border-color theme-screen-background-color');
	object.dom.appendChild(object.dom.inner);
	object.dom.inner.onclick = function(event) {
		if (this.model.parent._protected.inTransition == true) return; // Don't want to click while user is swiping
		this.model._raiseInteractionEvent('data-interaction-click');
		$ui.playTouchSound();
		if (this.model.parent.onclick) {
			this.model.parent.onclick(this.model);
		}
	}
	object.dom.inner.ontouchstart = function() {
		$ui.addClass(this,'theme-brand-background-color');
	}
	object.dom.inner.ontouchend = function() {
		$ui.removeClass(this,'theme-brand-background-color');
	}
	object.dom.inner.ontouchcancel = object.dom.inner.ontouchend;
	if (!$ui.isMobileDevice()) {
		object.dom.inner.onmousedown = object.dom.inner.ontouchstart;
		object.dom.inner.onmouseup = object.dom.inner.ontouchend;
		object.dom.inner.onmouseleave = object.dom.inner.ontouchend;
	}
	// Add our mark for automation
	if (object.id) {
		object.dom.inner.setAttribute('data-interaction-click', object.id);
	}
	
	// Create the icon area 
	object.dom.icon = document.createElement('div');
	$ui.addClass(object.dom.icon,'icon');
	object.dom.inner.appendChild(object.dom.icon);
	
	// Image Property
	if (object.img) {
		object.dom.icon.style.backgroundImage = 'url("'+ object.img + '")';
	}
	object._protected.img = object.img;
	Object.defineProperty(object, 'img', {
		get: function() {return this._protected.img;},
		set: function(value) {
			if (value == this._protected.img) return;
			this._protected.img = value;
			if (value == undefined) {
				this.dom.icon.style.backgroundImage = '';
			} else {
				this.dom.icon.style.backgroundImage = 'url("'+ value + '")';
			}
		},
		configurable: false}
	);
	
	// Caption Property
	object.dom.captionDiv = document.createElement('div');
	$ui.addClass(object.dom.captionDiv,'caption theme-text-color');
	object.dom.appendChild(object.dom.captionDiv);
	if (object.caption) {
		object.dom.captionDiv.textContent = object.caption;
	}
	object._protected.caption = object.caption;
	Object.defineProperty(object, 'caption', {
		get: function() {return this._protected.caption;},
		set: function(value) {
			if (value == this._protected.caption) return;
			this._protected.caption = value;
			if (value == undefined) {
				this.dom.captionDiv.textContent = '';
			} else {
				this.dom.captionDiv.textContent = value;
			}
		},
		configurable: false}
	);
	
	// Returns the size of the menu item
	object.getSize = function() {
		return this.dom.offsetWidth;
	}
	object.getSize = object.getSize.$bind(object);
	
	// Handle Visibility change
	object._setVisible = function(value) {
		if (this.parent) {
			this.parent._recalculateLayout();
		}
	}
	object._setVisible = object._setVisible.$bind(object);
	
	return object.dom;
}
/**
 * A Column represents a column of user interface items in a {@link $ui.ColumnLayout}
 * @namespace Column
 * @memberof $ui
 * @property {number} [span=1] - Specifies the span of the column.
 * @property {$ui.CoreComponent[]} [content] - Specifies the controls to be displayed in this column
*/
function $ui_Column(object, screen){
	$ui_CoreComponent.call(this, object, screen);
	if (object) {
		$ui.addClass(object.dom, 'ui-column');
		
		// Set our span
		if (object.span) {
			object.dom.style.width = (object._spanPercentage * object.span) + '%';
		} else {
			object.dom.style.width = object._spanPercentage + '%';
		}
		
		// content property
		if (object.content == undefined) {
			object.content = [];
		}
		object._protected.content = object.content;
		Object.defineProperty(object, 'content', {
			get: function() {return this._protected.content;},
			set: function() {
				console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','content'));
			},
			configurable: false}
		);
		
		// Now create the content
		var j,
			control;
		for (j = 0; j < object.content.length; j++) {
			control = object.content[j];
			controlDom = $ui.createControl(control, screen);
			if (controlDom) {
				object.dom.appendChild(controlDom);
			}
		}
		
		/** 
		 * Validate all the controls contained in this column (including nested controls) and return the boolean result
		 * @function validate
		 * @memberof $ui.Column
		 * @returns {boolean}
		 */
		object.validate = function() {
			var i,
				control,
				result = true;
			for (i = 0; i < this.content.length; i++) {
				control = this.content[i];
				if (control.validate)  {
					if (control.validate() == false) {
						result = false;
					}
				}
			}
			return result;
		}.$bind(object);
		
		// This function is called to cascade down a visibility change to child controls
		object._cascadeVisibility = function() {
			var i,
				control;			
			for (i = 0; i < this.content.length; i++) {
				control = this.content[i];
				if (control._cascadeVisibility) {
					control._cascadeVisibility();
				} else {
					if (control._onshow) {
						control._onshow();
					}
				}
			}
		}.$bind(object);
		
		// Cascade our visibility when it is set to "true"
		object._setVisible = function(value) {
			if (value == true) {
				this._cascadeVisibility();
			}
		}.$bind(object);
		
		return object.dom;
	}
}

/**
 * A Column layout specifies a set of columns which contain controls.  The number of columns, or their span, will determine the percentage width for each column
 * @namespace ColumnLayout
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {$ui.Column[]} columns - Contains all of the columns for this ColumnLayout
 * @property {boolean} [padding=false] - Specify <b>true</b> if you wish each of the columns to have padding inside them
 * @property {boolean} [fillToParent=false] - If set to <b>true</b> this column layout will grow to 100% of the height of its container.
*/
function $ui_ColumnLayout(object, screen){
	$ui_CoreComponent.call(this, object, screen);
	// Make sure this is only added to a HomeScreen
	if (object) {
		$ui.addClass(object.dom, 'ui-column-layout');
		
		// Check for padding
		if (object.padding == true) {
			$ui.addClass(object.dom, 'padding');
		}
		
		// Columns property
		if (object.columns == undefined) {
			object.columns = [];
		}
		object._protected.columns = object.columns;
		Object.defineProperty(object, 'columns', {
			get: function() {return this._protected.columns;},
			set: function() {
				console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','columns'));
			},
			configurable: false}
		);
		
		// fillToParent property
		if (object.fillToParent != true) {
			object.fillToParent = false;
		} else {
			$ui.addClass(object.dom,'fill');
		}
		object._protected.fillToParent = object.fillToParent;
		Object.defineProperty(object, 'fillToParent', {
			get: function() {return this._protected.fillToParent;},
			set: function(value) {
				if (value == this._protected.fillToParent) return;
				if (value == true) {
					$ui.addClass(this.dom, 'fill');
				} else {
					$ui.removeClass(this.dom,'fill');
				}
				this._protected.fillToParent = value;
			},
			configurable: false}
		);
		
		// Cycle through columns
		var i,
			j,
			column,
			spanPercentage,
			spanCount = 0,
			control,
			controlDom;
		// First move through to understand what a span of 1 is equal to
		for (i = 0; i < object.columns.length; i++) {
			column = object.columns[i];
			if (column.span) {
				spanCount = spanCount + column.span;
			} else {
				spanCount++;
			}
		}
		// Figure out our percentage
		if (spanCount == 0) {
			spanPercentage = 100;
		} else {
			spanPercentage = 100/spanCount;
		}
		// Now create the columns
		for (i = 0; i < object.columns.length; i++) {
			column = object.columns[i];
			column._spanPercentage = spanPercentage;
			if (column.component != $ui.Column) continue;
			new $ui_Column(column, screen);
			object.dom.appendChild(column.dom);
		}
		// Add a div to the end to ensure the container this column layout is embedded in grows to the height of the 
		// tallest column
		object.dom.clearElement = document.createElement('div');
		$ui.addClass(object.dom.clearElement, 'clear-element');
		object.dom.appendChild(object.dom.clearElement);
		
		/** 
		 * Validate all the controls contained in this column layout (including nested controls) and return the boolean result
		 * @function validate
		 * @memberof $ui.ColumnLayout
		 * @returns {boolean}
		 */
		object.validate = function() {
			var i,
				column,
				result = true;
			for (i = 0; i < this.columns.length; i++) {
				column = this.columns[i];
				if (column.validate() == false) {
						result = false;
				}
			}
			return result;
		}.$bind(object);
		
		// This function is called to cascade down a visibility change to child controls
		object._cascadeVisibility = function() {
			var i,
				column;
			for (i = 0; i < this.columns.length; i++) {
				column = this.columns[i];
				if (column._cascadeVisibility) {
					column._cascadeVisibility();
				}
			}
		}.$bind(object);
		
		// Cascade our visibility when it is set to "true"
		object._setVisible = function(value) {
			if (value == true) {
				this._cascadeVisibility();
			}
		}.$bind(object);
		
		return object.dom;	
	}
}

/**
 * The Control Group object represents a grouping of multiple different controls.  This component can be useful when you want to group different controls together for toggling visibility.<br><br>
 * <b>Sample Declaration</b><br>
 * <pre>
 * {
 *   component: $ui.ControlGroup,
 *    id: 'myGrouping',
 *    content: [
 *       {
 *           component: $ui.Header,
 *           caption: 'My Header',
 *       },
 *       {
 *           component: $ui.List,
 *           style: $ui.GenericListItem
 *       }
 *    ]
 *}
 * @namespace ControlGroup
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {$ui.CoreComponent[]} [content] - The content property is an array of control definitions to be displayed in the control
*/
function $ui_ControlGroup(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom,'ui-control-group');
	
	// Content property
	if (object.content == undefined) {
		object.content = [];
	}
	object._protected.content = object.content;
	Object.defineProperty(object, 'content', {
		get: function() {return this._protected.content;},
		set: function() {
			console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','content'));			
		},
		configurable: false}
	);
	if (object.content) {
		var i,
			item,
			itemDom;
		for (i = 0; i < object.content.length; i++) {
			item = object.content[i];
			itemDom = $ui.createControl(item, object.screen);
			if (itemDom) {
				object.dom.appendChild(itemDom);
			}
		}
	}	
	
	return object.dom;
}
/*! Hammer.JS - v2.0.4 - 2014-09-28
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2014 Jorik Tangelder;
 * Licensed under the MIT license */
!function(a,b,c,d){"use strict";function e(a,b,c){return setTimeout(k(a,c),b)}function f(a,b,c){return Array.isArray(a)?(g(a,c[b],c),!0):!1}function g(a,b,c){var e;if(a)if(a.forEach)a.forEach(b,c);else if(a.length!==d)for(e=0;e<a.length;)b.call(c,a[e],e,a),e++;else for(e in a)a.hasOwnProperty(e)&&b.call(c,a[e],e,a)}function h(a,b,c){for(var e=Object.keys(b),f=0;f<e.length;)(!c||c&&a[e[f]]===d)&&(a[e[f]]=b[e[f]]),f++;return a}function i(a,b){return h(a,b,!0)}function j(a,b,c){var d,e=b.prototype;d=a.prototype=Object.create(e),d.constructor=a,d._super=e,c&&h(d,c)}function k(a,b){return function(){return a.apply(b,arguments)}}function l(a,b){return typeof a==kb?a.apply(b?b[0]||d:d,b):a}function m(a,b){return a===d?b:a}function n(a,b,c){g(r(b),function(b){a.addEventListener(b,c,!1)})}function o(a,b,c){g(r(b),function(b){a.removeEventListener(b,c,!1)})}function p(a,b){for(;a;){if(a==b)return!0;a=a.parentNode}return!1}function q(a,b){return a.indexOf(b)>-1}function r(a){return a.trim().split(/\s+/g)}function s(a,b,c){if(a.indexOf&&!c)return a.indexOf(b);for(var d=0;d<a.length;){if(c&&a[d][c]==b||!c&&a[d]===b)return d;d++}return-1}function t(a){return Array.prototype.slice.call(a,0)}function u(a,b,c){for(var d=[],e=[],f=0;f<a.length;){var g=b?a[f][b]:a[f];s(e,g)<0&&d.push(a[f]),e[f]=g,f++}return c&&(d=b?d.sort(function(a,c){return a[b]>c[b]}):d.sort()),d}function v(a,b){for(var c,e,f=b[0].toUpperCase()+b.slice(1),g=0;g<ib.length;){if(c=ib[g],e=c?c+f:b,e in a)return e;g++}return d}function w(){return ob++}function x(a){var b=a.ownerDocument;return b.defaultView||b.parentWindow}function y(a,b){var c=this;this.manager=a,this.callback=b,this.element=a.element,this.target=a.options.inputTarget,this.domHandler=function(b){l(a.options.enable,[a])&&c.handler(b)},this.init()}function z(a){var b,c=a.options.inputClass;return new(b=c?c:rb?N:sb?Q:qb?S:M)(a,A)}function A(a,b,c){var d=c.pointers.length,e=c.changedPointers.length,f=b&yb&&d-e===0,g=b&(Ab|Bb)&&d-e===0;c.isFirst=!!f,c.isFinal=!!g,f&&(a.session={}),c.eventType=b,B(a,c),a.emit("hammer.input",c),a.recognize(c),a.session.prevInput=c}function B(a,b){var c=a.session,d=b.pointers,e=d.length;c.firstInput||(c.firstInput=E(b)),e>1&&!c.firstMultiple?c.firstMultiple=E(b):1===e&&(c.firstMultiple=!1);var f=c.firstInput,g=c.firstMultiple,h=g?g.center:f.center,i=b.center=F(d);b.timeStamp=nb(),b.deltaTime=b.timeStamp-f.timeStamp,b.angle=J(h,i),b.distance=I(h,i),C(c,b),b.offsetDirection=H(b.deltaX,b.deltaY),b.scale=g?L(g.pointers,d):1,b.rotation=g?K(g.pointers,d):0,D(c,b);var j=a.element;p(b.srcEvent.target,j)&&(j=b.srcEvent.target),b.target=j}function C(a,b){var c=b.center,d=a.offsetDelta||{},e=a.prevDelta||{},f=a.prevInput||{};(b.eventType===yb||f.eventType===Ab)&&(e=a.prevDelta={x:f.deltaX||0,y:f.deltaY||0},d=a.offsetDelta={x:c.x,y:c.y}),b.deltaX=e.x+(c.x-d.x),b.deltaY=e.y+(c.y-d.y)}function D(a,b){var c,e,f,g,h=a.lastInterval||b,i=b.timeStamp-h.timeStamp;if(b.eventType!=Bb&&(i>xb||h.velocity===d)){var j=h.deltaX-b.deltaX,k=h.deltaY-b.deltaY,l=G(i,j,k);e=l.x,f=l.y,c=mb(l.x)>mb(l.y)?l.x:l.y,g=H(j,k),a.lastInterval=b}else c=h.velocity,e=h.velocityX,f=h.velocityY,g=h.direction;b.velocity=c,b.velocityX=e,b.velocityY=f,b.direction=g}function E(a){for(var b=[],c=0;c<a.pointers.length;)b[c]={clientX:lb(a.pointers[c].clientX),clientY:lb(a.pointers[c].clientY)},c++;return{timeStamp:nb(),pointers:b,center:F(b),deltaX:a.deltaX,deltaY:a.deltaY}}function F(a){var b=a.length;if(1===b)return{x:lb(a[0].clientX),y:lb(a[0].clientY)};for(var c=0,d=0,e=0;b>e;)c+=a[e].clientX,d+=a[e].clientY,e++;return{x:lb(c/b),y:lb(d/b)}}function G(a,b,c){return{x:b/a||0,y:c/a||0}}function H(a,b){return a===b?Cb:mb(a)>=mb(b)?a>0?Db:Eb:b>0?Fb:Gb}function I(a,b,c){c||(c=Kb);var d=b[c[0]]-a[c[0]],e=b[c[1]]-a[c[1]];return Math.sqrt(d*d+e*e)}function J(a,b,c){c||(c=Kb);var d=b[c[0]]-a[c[0]],e=b[c[1]]-a[c[1]];return 180*Math.atan2(e,d)/Math.PI}function K(a,b){return J(b[1],b[0],Lb)-J(a[1],a[0],Lb)}function L(a,b){return I(b[0],b[1],Lb)/I(a[0],a[1],Lb)}function M(){this.evEl=Nb,this.evWin=Ob,this.allow=!0,this.pressed=!1,y.apply(this,arguments)}function N(){this.evEl=Rb,this.evWin=Sb,y.apply(this,arguments),this.store=this.manager.session.pointerEvents=[]}function O(){this.evTarget=Ub,this.evWin=Vb,this.started=!1,y.apply(this,arguments)}function P(a,b){var c=t(a.touches),d=t(a.changedTouches);return b&(Ab|Bb)&&(c=u(c.concat(d),"identifier",!0)),[c,d]}function Q(){this.evTarget=Xb,this.targetIds={},y.apply(this,arguments)}function R(a,b){var c=t(a.touches),d=this.targetIds;if(b&(yb|zb)&&1===c.length)return d[c[0].identifier]=!0,[c,c];var e,f,g=t(a.changedTouches),h=[],i=this.target;if(f=c.filter(function(a){return p(a.target,i)}),b===yb)for(e=0;e<f.length;)d[f[e].identifier]=!0,e++;for(e=0;e<g.length;)d[g[e].identifier]&&h.push(g[e]),b&(Ab|Bb)&&delete d[g[e].identifier],e++;return h.length?[u(f.concat(h),"identifier",!0),h]:void 0}function S(){y.apply(this,arguments);var a=k(this.handler,this);this.touch=new Q(this.manager,a),this.mouse=new M(this.manager,a)}function T(a,b){this.manager=a,this.set(b)}function U(a){if(q(a,bc))return bc;var b=q(a,cc),c=q(a,dc);return b&&c?cc+" "+dc:b||c?b?cc:dc:q(a,ac)?ac:_b}function V(a){this.id=w(),this.manager=null,this.options=i(a||{},this.defaults),this.options.enable=m(this.options.enable,!0),this.state=ec,this.simultaneous={},this.requireFail=[]}function W(a){return a&jc?"cancel":a&hc?"end":a&gc?"move":a&fc?"start":""}function X(a){return a==Gb?"down":a==Fb?"up":a==Db?"left":a==Eb?"right":""}function Y(a,b){var c=b.manager;return c?c.get(a):a}function Z(){V.apply(this,arguments)}function $(){Z.apply(this,arguments),this.pX=null,this.pY=null}function _(){Z.apply(this,arguments)}function ab(){V.apply(this,arguments),this._timer=null,this._input=null}function bb(){Z.apply(this,arguments)}function cb(){Z.apply(this,arguments)}function db(){V.apply(this,arguments),this.pTime=!1,this.pCenter=!1,this._timer=null,this._input=null,this.count=0}function eb(a,b){return b=b||{},b.recognizers=m(b.recognizers,eb.defaults.preset),new fb(a,b)}function fb(a,b){b=b||{},this.options=i(b,eb.defaults),this.options.inputTarget=this.options.inputTarget||a,this.handlers={},this.session={},this.recognizers=[],this.element=a,this.input=z(this),this.touchAction=new T(this,this.options.touchAction),gb(this,!0),g(b.recognizers,function(a){var b=this.add(new a[0](a[1]));a[2]&&b.recognizeWith(a[2]),a[3]&&b.requireFailure(a[3])},this)}function gb(a,b){var c=a.element;g(a.options.cssProps,function(a,d){c.style[v(c.style,d)]=b?a:""})}function hb(a,c){var d=b.createEvent("Event");d.initEvent(a,!0,!0),d.gesture=c,c.target.dispatchEvent(d)}var ib=["","webkit","moz","MS","ms","o"],jb=b.createElement("div"),kb="function",lb=Math.round,mb=Math.abs,nb=Date.now,ob=1,pb=/mobile|tablet|ip(ad|hone|od)|android/i,qb="ontouchstart"in a,rb=v(a,"PointerEvent")!==d,sb=qb&&pb.test(navigator.userAgent),tb="touch",ub="pen",vb="mouse",wb="kinect",xb=25,yb=1,zb=2,Ab=4,Bb=8,Cb=1,Db=2,Eb=4,Fb=8,Gb=16,Hb=Db|Eb,Ib=Fb|Gb,Jb=Hb|Ib,Kb=["x","y"],Lb=["clientX","clientY"];y.prototype={handler:function(){},init:function(){this.evEl&&n(this.element,this.evEl,this.domHandler),this.evTarget&&n(this.target,this.evTarget,this.domHandler),this.evWin&&n(x(this.element),this.evWin,this.domHandler)},destroy:function(){this.evEl&&o(this.element,this.evEl,this.domHandler),this.evTarget&&o(this.target,this.evTarget,this.domHandler),this.evWin&&o(x(this.element),this.evWin,this.domHandler)}};var Mb={mousedown:yb,mousemove:zb,mouseup:Ab},Nb="mousedown",Ob="mousemove mouseup";j(M,y,{handler:function(a){var b=Mb[a.type];b&yb&&0===a.button&&(this.pressed=!0),b&zb&&1!==a.which&&(b=Ab),this.pressed&&this.allow&&(b&Ab&&(this.pressed=!1),this.callback(this.manager,b,{pointers:[a],changedPointers:[a],pointerType:vb,srcEvent:a}))}});var Pb={pointerdown:yb,pointermove:zb,pointerup:Ab,pointercancel:Bb,pointerout:Bb},Qb={2:tb,3:ub,4:vb,5:wb},Rb="pointerdown",Sb="pointermove pointerup pointercancel";a.MSPointerEvent&&(Rb="MSPointerDown",Sb="MSPointerMove MSPointerUp MSPointerCancel"),j(N,y,{handler:function(a){var b=this.store,c=!1,d=a.type.toLowerCase().replace("ms",""),e=Pb[d],f=Qb[a.pointerType]||a.pointerType,g=f==tb,h=s(b,a.pointerId,"pointerId");e&yb&&(0===a.button||g)?0>h&&(b.push(a),h=b.length-1):e&(Ab|Bb)&&(c=!0),0>h||(b[h]=a,this.callback(this.manager,e,{pointers:b,changedPointers:[a],pointerType:f,srcEvent:a}),c&&b.splice(h,1))}});var Tb={touchstart:yb,touchmove:zb,touchend:Ab,touchcancel:Bb},Ub="touchstart",Vb="touchstart touchmove touchend touchcancel";j(O,y,{handler:function(a){var b=Tb[a.type];if(b===yb&&(this.started=!0),this.started){var c=P.call(this,a,b);b&(Ab|Bb)&&c[0].length-c[1].length===0&&(this.started=!1),this.callback(this.manager,b,{pointers:c[0],changedPointers:c[1],pointerType:tb,srcEvent:a})}}});var Wb={touchstart:yb,touchmove:zb,touchend:Ab,touchcancel:Bb},Xb="touchstart touchmove touchend touchcancel";j(Q,y,{handler:function(a){var b=Wb[a.type],c=R.call(this,a,b);c&&this.callback(this.manager,b,{pointers:c[0],changedPointers:c[1],pointerType:tb,srcEvent:a})}}),j(S,y,{handler:function(a,b,c){var d=c.pointerType==tb,e=c.pointerType==vb;if(d)this.mouse.allow=!1;else if(e&&!this.mouse.allow)return;b&(Ab|Bb)&&(this.mouse.allow=!0),this.callback(a,b,c)},destroy:function(){this.touch.destroy(),this.mouse.destroy()}});var Yb=v(jb.style,"touchAction"),Zb=Yb!==d,$b="compute",_b="auto",ac="manipulation",bc="none",cc="pan-x",dc="pan-y";T.prototype={set:function(a){a==$b&&(a=this.compute()),Zb&&(this.manager.element.style[Yb]=a),this.actions=a.toLowerCase().trim()},update:function(){this.set(this.manager.options.touchAction)},compute:function(){var a=[];return g(this.manager.recognizers,function(b){l(b.options.enable,[b])&&(a=a.concat(b.getTouchAction()))}),U(a.join(" "))},preventDefaults:function(a){if(!Zb){var b=a.srcEvent,c=a.offsetDirection;if(this.manager.session.prevented)return void b.preventDefault();var d=this.actions,e=q(d,bc),f=q(d,dc),g=q(d,cc);return e||f&&c&Hb||g&&c&Ib?this.preventSrc(b):void 0}},preventSrc:function(a){this.manager.session.prevented=!0,a.preventDefault()}};var ec=1,fc=2,gc=4,hc=8,ic=hc,jc=16,kc=32;V.prototype={defaults:{},set:function(a){return h(this.options,a),this.manager&&this.manager.touchAction.update(),this},recognizeWith:function(a){if(f(a,"recognizeWith",this))return this;var b=this.simultaneous;return a=Y(a,this),b[a.id]||(b[a.id]=a,a.recognizeWith(this)),this},dropRecognizeWith:function(a){return f(a,"dropRecognizeWith",this)?this:(a=Y(a,this),delete this.simultaneous[a.id],this)},requireFailure:function(a){if(f(a,"requireFailure",this))return this;var b=this.requireFail;return a=Y(a,this),-1===s(b,a)&&(b.push(a),a.requireFailure(this)),this},dropRequireFailure:function(a){if(f(a,"dropRequireFailure",this))return this;a=Y(a,this);var b=s(this.requireFail,a);return b>-1&&this.requireFail.splice(b,1),this},hasRequireFailures:function(){return this.requireFail.length>0},canRecognizeWith:function(a){return!!this.simultaneous[a.id]},emit:function(a){function b(b){c.manager.emit(c.options.event+(b?W(d):""),a)}var c=this,d=this.state;hc>d&&b(!0),b(),d>=hc&&b(!0)},tryEmit:function(a){return this.canEmit()?this.emit(a):void(this.state=kc)},canEmit:function(){for(var a=0;a<this.requireFail.length;){if(!(this.requireFail[a].state&(kc|ec)))return!1;a++}return!0},recognize:function(a){var b=h({},a);return l(this.options.enable,[this,b])?(this.state&(ic|jc|kc)&&(this.state=ec),this.state=this.process(b),void(this.state&(fc|gc|hc|jc)&&this.tryEmit(b))):(this.reset(),void(this.state=kc))},process:function(){},getTouchAction:function(){},reset:function(){}},j(Z,V,{defaults:{pointers:1},attrTest:function(a){var b=this.options.pointers;return 0===b||a.pointers.length===b},process:function(a){var b=this.state,c=a.eventType,d=b&(fc|gc),e=this.attrTest(a);return d&&(c&Bb||!e)?b|jc:d||e?c&Ab?b|hc:b&fc?b|gc:fc:kc}}),j($,Z,{defaults:{event:"pan",threshold:10,pointers:1,direction:Jb},getTouchAction:function(){var a=this.options.direction,b=[];return a&Hb&&b.push(dc),a&Ib&&b.push(cc),b},directionTest:function(a){var b=this.options,c=!0,d=a.distance,e=a.direction,f=a.deltaX,g=a.deltaY;return e&b.direction||(b.direction&Hb?(e=0===f?Cb:0>f?Db:Eb,c=f!=this.pX,d=Math.abs(a.deltaX)):(e=0===g?Cb:0>g?Fb:Gb,c=g!=this.pY,d=Math.abs(a.deltaY))),a.direction=e,c&&d>b.threshold&&e&b.direction},attrTest:function(a){return Z.prototype.attrTest.call(this,a)&&(this.state&fc||!(this.state&fc)&&this.directionTest(a))},emit:function(a){this.pX=a.deltaX,this.pY=a.deltaY;var b=X(a.direction);b&&this.manager.emit(this.options.event+b,a),this._super.emit.call(this,a)}}),j(_,Z,{defaults:{event:"pinch",threshold:0,pointers:2},getTouchAction:function(){return[bc]},attrTest:function(a){return this._super.attrTest.call(this,a)&&(Math.abs(a.scale-1)>this.options.threshold||this.state&fc)},emit:function(a){if(this._super.emit.call(this,a),1!==a.scale){var b=a.scale<1?"in":"out";this.manager.emit(this.options.event+b,a)}}}),j(ab,V,{defaults:{event:"press",pointers:1,time:500,threshold:5},getTouchAction:function(){return[_b]},process:function(a){var b=this.options,c=a.pointers.length===b.pointers,d=a.distance<b.threshold,f=a.deltaTime>b.time;if(this._input=a,!d||!c||a.eventType&(Ab|Bb)&&!f)this.reset();else if(a.eventType&yb)this.reset(),this._timer=e(function(){this.state=ic,this.tryEmit()},b.time,this);else if(a.eventType&Ab)return ic;return kc},reset:function(){clearTimeout(this._timer)},emit:function(a){this.state===ic&&(a&&a.eventType&Ab?this.manager.emit(this.options.event+"up",a):(this._input.timeStamp=nb(),this.manager.emit(this.options.event,this._input)))}}),j(bb,Z,{defaults:{event:"rotate",threshold:0,pointers:2},getTouchAction:function(){return[bc]},attrTest:function(a){return this._super.attrTest.call(this,a)&&(Math.abs(a.rotation)>this.options.threshold||this.state&fc)}}),j(cb,Z,{defaults:{event:"swipe",threshold:10,velocity:.65,direction:Hb|Ib,pointers:1},getTouchAction:function(){return $.prototype.getTouchAction.call(this)},attrTest:function(a){var b,c=this.options.direction;return c&(Hb|Ib)?b=a.velocity:c&Hb?b=a.velocityX:c&Ib&&(b=a.velocityY),this._super.attrTest.call(this,a)&&c&a.direction&&a.distance>this.options.threshold&&mb(b)>this.options.velocity&&a.eventType&Ab},emit:function(a){var b=X(a.direction);b&&this.manager.emit(this.options.event+b,a),this.manager.emit(this.options.event,a)}}),j(db,V,{defaults:{event:"tap",pointers:1,taps:1,interval:300,time:250,threshold:2,posThreshold:10},getTouchAction:function(){return[ac]},process:function(a){var b=this.options,c=a.pointers.length===b.pointers,d=a.distance<b.threshold,f=a.deltaTime<b.time;if(this.reset(),a.eventType&yb&&0===this.count)return this.failTimeout();if(d&&f&&c){if(a.eventType!=Ab)return this.failTimeout();var g=this.pTime?a.timeStamp-this.pTime<b.interval:!0,h=!this.pCenter||I(this.pCenter,a.center)<b.posThreshold;this.pTime=a.timeStamp,this.pCenter=a.center,h&&g?this.count+=1:this.count=1,this._input=a;var i=this.count%b.taps;if(0===i)return this.hasRequireFailures()?(this._timer=e(function(){this.state=ic,this.tryEmit()},b.interval,this),fc):ic}return kc},failTimeout:function(){return this._timer=e(function(){this.state=kc},this.options.interval,this),kc},reset:function(){clearTimeout(this._timer)},emit:function(){this.state==ic&&(this._input.tapCount=this.count,this.manager.emit(this.options.event,this._input))}}),eb.VERSION="2.0.4",eb.defaults={domEvents:!1,touchAction:$b,enable:!0,inputTarget:null,inputClass:null,preset:[[bb,{enable:!1}],[_,{enable:!1},["rotate"]],[cb,{direction:Hb}],[$,{direction:Hb},["swipe"]],[db],[db,{event:"doubletap",taps:2},["tap"]],[ab]],cssProps:{userSelect:"none",touchSelect:"none",touchCallout:"none",contentZooming:"none",userDrag:"none",tapHighlightColor:"rgba(0,0,0,0)"}};var lc=1,mc=2;fb.prototype={set:function(a){return h(this.options,a),a.touchAction&&this.touchAction.update(),a.inputTarget&&(this.input.destroy(),this.input.target=a.inputTarget,this.input.init()),this},stop:function(a){this.session.stopped=a?mc:lc},recognize:function(a){var b=this.session;if(!b.stopped){this.touchAction.preventDefaults(a);var c,d=this.recognizers,e=b.curRecognizer;(!e||e&&e.state&ic)&&(e=b.curRecognizer=null);for(var f=0;f<d.length;)c=d[f],b.stopped===mc||e&&c!=e&&!c.canRecognizeWith(e)?c.reset():c.recognize(a),!e&&c.state&(fc|gc|hc)&&(e=b.curRecognizer=c),f++}},get:function(a){if(a instanceof V)return a;for(var b=this.recognizers,c=0;c<b.length;c++)if(b[c].options.event==a)return b[c];return null},add:function(a){if(f(a,"add",this))return this;var b=this.get(a.options.event);return b&&this.remove(b),this.recognizers.push(a),a.manager=this,this.touchAction.update(),a},remove:function(a){if(f(a,"remove",this))return this;var b=this.recognizers;return a=this.get(a),b.splice(s(b,a),1),this.touchAction.update(),this},on:function(a,b){var c=this.handlers;return g(r(a),function(a){c[a]=c[a]||[],c[a].push(b)}),this},off:function(a,b){var c=this.handlers;return g(r(a),function(a){b?c[a].splice(s(c[a],b),1):delete c[a]}),this},emit:function(a,b){this.options.domEvents&&hb(a,b);var c=this.handlers[a]&&this.handlers[a].slice();if(c&&c.length){b.type=a,b.preventDefault=function(){b.srcEvent.preventDefault()};for(var d=0;d<c.length;)c[d](b),d++}},destroy:function(){this.element&&gb(this,!1),this.handlers={},this.session={},this.input.destroy(),this.element=null}},h(eb,{INPUT_START:yb,INPUT_MOVE:zb,INPUT_END:Ab,INPUT_CANCEL:Bb,STATE_POSSIBLE:ec,STATE_BEGAN:fc,STATE_CHANGED:gc,STATE_ENDED:hc,STATE_RECOGNIZED:ic,STATE_CANCELLED:jc,STATE_FAILED:kc,DIRECTION_NONE:Cb,DIRECTION_LEFT:Db,DIRECTION_RIGHT:Eb,DIRECTION_UP:Fb,DIRECTION_DOWN:Gb,DIRECTION_HORIZONTAL:Hb,DIRECTION_VERTICAL:Ib,DIRECTION_ALL:Jb,Manager:fb,Input:y,TouchAction:T,TouchInput:Q,MouseInput:M,PointerEventInput:N,TouchMouseInput:S,SingleTouchInput:O,Recognizer:V,AttrRecognizer:Z,Tap:db,Pan:$,Swipe:cb,Pinch:_,Rotate:bb,Press:ab,on:n,off:o,each:g,merge:i,extend:h,inherit:j,bindFn:k,prefixed:v}),typeof define==kb&&define.amd?define(function(){return eb}):"undefined"!=typeof module&&module.exports?module.exports=eb:a[c]=eb}(window,document,"Hammer");
//# sourceMappingURL=hammer.min.map
$ui.themeDark = {
	backgroundImageColor: '#D94646',
	inHeadUnit: true,
	chart: { // Not in CSS because charts are <canvas>
		color: '#747474', //#F0F0F0
		color_OK: '#D94646',//#FAD60A
		color_GOOD: '#D94646',//#FDBF2F
		color_GREAT: '#D94646', //#A3D525
		color_RANDOM1: '#D94646', //#97BBCD
	},
	variables: [
		{
			name: '@brand-color',
			value: '#D94646'
		},
		{
			name: '@highlight-text-color',
			value: '#FFFFFF'
		},
		{
			name: '@foreground-color',
			value: '#FFFFFF'
		},
		{
			name: '@border-color',
			value: '#FFFFFF'
		},
		{
			name: '@background-color',
			value: '#000000'
		},
		{
			name: '@dark-color',
			value: '#747474'
		},
		{
			name: '@profile-wedge-color',
			value: '#D94646'// #FDBF2F
		},
		{
			name: '@green-color',
			value: '#779933'
		}
	],
	classList: [
		{
			className: '.theme-border-color',
			properties: [
				{
					name: 'border-color',
					value: '@border-color !important'
				}
			]
		},
		{
			className: '.theme-brand-border-color',
			properties: [
				{
					name: 'border-color',
					value: '@brand-color !important'
				}
			]
		},
		{
			className: '.theme-tile-border-color',
			properties: [
				{
					name: 'border-color',
					value: '@brand-color !important'
				}
			]
		},
		{
			className: '.theme-dark-border-color',
			properties: [
				{
					name: 'border-color',
					value: '@dark-color !important'
				}
			]
		},
		{
			className: '.theme-text-color',
			properties: [
				{
					name: 'color',
					value: '@foreground-color'
				}
			]
		},
		{
			className: '.theme-dark-text-color',
			properties: [
				{
					name: 'color',
					value: '@dark-color'
				}
			]
		},
		{
			className: '.theme-highlight-text-color',
			properties: [
				{
					name: 'color',
					value: '@highlight-text-color'
				}
			]
		},
		{
			className: '.theme-brand-text-color',
			properties: [
				{
					name: 'color',
					value: '@brand-color'
				}
			]
		},
		{
			className: '.theme-hint-text-color',
			properties: [
				{
					name: 'color',
					value: '#999999'
				}
			]
		},
		{
			className: '.theme-warning-text-color',
			properties: [
				{
					name: 'color',
					value: 'red'
				}
			]
		},
		{
			className: '.theme-screen-background-color',
			properties: [
				{
					name: 'background-color',
					value: '@background-color'
				}
			]
		},
		{
			className: '.theme-brand-background-color',
			properties: [
				{
					name: 'background-color',
					value: '@brand-color'
				}
			]
		},
		{
			className: '.theme-light-background-color',
			properties: [
				{
					name: 'background-color',
					value: '@foreground-color'
				}
			]
		},
		{
			className: '.theme-dark-background-color',
			properties: [
				{
					name: 'background-color',
					value: '@dark-color'
				}
			]
		},
		/****************  Call Button ******************/
		{
			className: '.theme-call-button',
			properties: [
				{
					name: 'background-color',
					value: '@green-color'
				}
			]
		},
		/****************  Generic List Items ******************/
		{
			className: '.theme-generic-list-accent-color',
			properties: [
				{
					name: 'color',
					value: '@brand-color'
				}
			]
		},
		/****************  Segmented Control ******************/
		{
			className: '.theme-segmented-control',
			properties: [
				{
					name: 'border-color',
					value: '@foreground-color'
				},
				{
					name: 'background-color',
					value: '@background-color'
				},
				{
					name: 'color',
					value: '@foreground-color'
				}
			]
		},
		/****************  Posts ******************/
		{
			className: '.theme-post-control',
			properties: [
				{
					name: 'color',
					value: '#D3D3D3'
				},
				{
					name: 'background-color',
					value: '@background-color'
				}
			]
		},
		/****************  Profile ******************/
		{
			className: '.theme-profile-vehicle-background-color',
			properties: [
				{
					name: 'background-color',
					value: '@background-color' // Light theme should be same as border color
				}
			]
		},
		{
			className: '.theme-profile-wedge-background-color',
			properties: [
				{
					name: 'background-color',
					value: '@profile-wedge-color'
				}
			]
		},
		{
			className: '.theme-profile-rank',
			properties: [
				{
					name: 'background-color',
					value: '@profile-wedge-color'
				},
				{
					name: 'color',
					value: '@highlight-text-color'
				}
			]
		},
		{
			className: '.theme-profile-rank-text-color',
			properties: [
				{
					name: 'color',
					value: '@highlight-text-color' // Light theme should be @dark-color
				}
			]
		},
		{
			className: '.theme-profile-label-text-color',
			properties: [
				{
					name: 'color',
					value: '@border-color' 
				}
			]
		},
		{
			className: '.theme-profile-stats',
			properties: [
				{
					name: 'border-color',
					value: '@brand-color' // Light theme should be @border-color
				},
				{
					name: 'background-color',
					value: '@background-color'
				}
			]
		},
		{
			className: '.theme-profile-number-color',
			properties: [
				{
					name: 'color',
					value: '@profile-wedge-color'
				}
			]
		},
		{
			className: '.theme-profile-avatar',
			properties: [
				{
					name: 'background-color',
					value: '@dark-color' // Light theme should be @border-color
				},
				{
					name: 'border-color',
					value: '@brand-color' // Light theme should be white
				},
				{
					name: 'box-shadow',
					value: 'inherit' // Light theme should be 0px 0px 7px #B6B6B6; 
				}
			]
		},
		/****************  On Off Switch ******************/
		{
			className: '.theme-on-off-switch',
			properties: [
				{
					name: 'background-image',
					value: 'linear-gradient(to top, @dark-color, #B9B9B9 80%);' 
				}
			]
		},
		{
			className: '.theme-on-off-switch-inner-ring',
			properties: [
				{
					name: 'border-color',
					value: '@background-color' 
				},
				{
					name: 'background-image',
					value: 'linear-gradient(to top,#B9B9B9,#5c5c5c 25%);' 
				}
			]
		},
		{
			className: '.theme-on-off-switch-inner-ring-on',
			properties: [
				{
					name: 'border-color',
					value: '@background-color' 
				},
				{
					name: 'background-image',
					value: 'linear-gradient(to bottom, #B9B9B9, #5c5c5c 25%);' 
				}
			]
		},
		{
			className: '.theme-on-off-switch-indicator-on',
			properties: [
				{
					name: 'background-color',
					value: '@green-color'
				}
			]
		},
		{
			className: '.theme-on-off-switch',
			properties: [
				{
					name: 'background-image',
					value: 'linear-gradient(to top,#747474, #B9B9B9 50%);' 
				}
			]
		},
		/****************  Circle Menu ******************/
		{
			className: '.theme-circle-menu-indicator',
			properties: [
				{
					name: 'background-color',
					value: '@dark-color' 
				}
			]
		},
		{
			className: '.theme-circle-menu-indicator-selected',
			properties: [
				{
					name: 'background-color',
					value: '@foreground-color' 
				}
			]
		}
	]
};

$ui.themeLight = {
	backgroundImageColor: '#D94646',
	inHeadUnit: true,
	chart: { // Not in CSS because charts are <canvas>
		color: '#747474', //#F0F0F0
		color_OK: '#D94646',//#FAD60A
		color_GOOD: '#D94646',//#FDBF2F
		color_GREAT: '#D94646', //#A3D525
		color_RANDOM1: '#D94646', //#97BBCD
	},
	variables: [
		{
			name: '@brand-color',
			value: '#D94646'
		},
		{
			name: '@highlight-text-color',
			value: '#FFFFFF'
		},
		{
			name: '@foreground-color',
			value: '#FFFFFF'
		},
		{
			name: '@border-color',
			value: '#FFFFFF'
		},
		{
			name: '@background-color',
			value: '#000000'
		},
		{
			name: '@dark-color',
			value: '#747474'
		},
		{
			name: '@profile-wedge-color',
			value: '#D94646'// #FDBF2F
		}
	],
	classList: [
		{
			className: '.theme-border-color',
			properties: [
				{
					name: 'border-color',
					value: '@border-color !important'
				}
			]
		},
		{
			className: '.theme-brand-border-color',
			properties: [
				{
					name: 'border-color',
					value: '@brand-color !important'
				}
			]
		},
		{
			className: '.theme-tile-border-color',
			properties: [
				{
					name: 'border-color',
					value: '@brand-color !important'
				}
			]
		},
		{
			className: '.theme-dark-border-color',
			properties: [
				{
					name: 'border-color',
					value: '@dark-color !important'
				}
			]
		},
		{
			className: '.theme-text-color',
			properties: [
				{
					name: 'color',
					value: '@foreground-color'
				}
			]
		},
		{
			className: '.theme-dark-text-color',
			properties: [
				{
					name: 'color',
					value: '@dark-color'
				}
			]
		},
		{
			className: '.theme-highlight-text-color',
			properties: [
				{
					name: 'color',
					value: '@highlight-text-color'
				}
			]
		},
		{
			className: '.theme-brand-text-color',
			properties: [
				{
					name: 'color',
					value: '@brand-color'
				}
			]
		},
		{
			className: '.theme-screen-background-color',
			properties: [
				{
					name: 'background-color',
					value: '@background-color'
				}
			]
		},
		{
			className: '.theme-brand-background-color',
			properties: [
				{
					name: 'background-color',
					value: '@brand-color'
				}
			]
		},
		{
			className: '.theme-light-background-color',
			properties: [
				{
					name: 'background-color',
					value: '@foreground-color'
				}
			]
		},
		{
			className: '.theme-dark-background-color',
			properties: [
				{
					name: 'background-color',
					value: '@dark-color'
				}
			]
		},
		/****************  Generic List Items ******************/
		{
			className: '.theme-generic-list-accent-color',
			properties: [
				{
					name: 'color',
					value: '@brand-color'
				}
			]
		},
		/****************  Segmented Control ******************/
		{
			className: '.theme-segmented-control',
			properties: [
				{
					name: 'border-color',
					value: '@foreground-color'
				},
				{
					name: 'background-color',
					value: '@background-color'
				},
				{
					name: 'color',
					value: '@foreground-color'
				}
			]
		},
		/****************  Posts ******************/
		{
			className: '.theme-post-control',
			properties: [
				{
					name: 'color',
					value: '#D3D3D3'
				},
				{
					name: 'background-color',
					value: '@background-color'
				}
			]
		},
		/****************  Profile ******************/
		{
			className: '.theme-profile-vehicle-background-color',
			properties: [
				{
					name: 'background-color',
					value: '@background-color' // Light theme should be same as border color
				}
			]
		},
		{
			className: '.theme-profile-wedge-background-color',
			properties: [
				{
					name: 'background-color',
					value: '@profile-wedge-color'
				}
			]
		},
		{
			className: '.theme-profile-rank',
			properties: [
				{
					name: 'background-color',
					value: '@profile-wedge-color'
				},
				{
					name: 'color',
					value: '@highlight-text-color'
				}
			]
		},
		{
			className: '.theme-profile-rank-text-color',
			properties: [
				{
					name: 'color',
					value: '@highlight-text-color' // Light theme should be @dark-color
				}
			]
		},
		{
			className: '.theme-profile-label-text-color',
			properties: [
				{
					name: 'color',
					value: '@border-color' 
				}
			]
		},
		{
			className: '.theme-profile-stats',
			properties: [
				{
					name: 'border-color',
					value: '@brand-color' // Light theme should be @border-color
				},
				{
					name: 'background-color',
					value: '@background-color'
				}
			]
		},
		{
			className: '.theme-profile-number-color',
			properties: [
				{
					name: 'color',
					value: '@profile-wedge-color'
				}
			]
		},
		{
			className: '.theme-profile-avatar',
			properties: [
				{
					name: 'background-color',
					value: '@dark-color' // Light theme should be @border-color
				},
				{
					name: 'border-color',
					value: '@brand-color' // Light theme should be white
				},
				{
					name: 'box-shadow',
					value: 'inherit' // Light theme should be 0px 0px 7px #B6B6B6; 
				}
			]
		}
	]
};

/**
 * The CoreTile object represents the abstract base class for all tile controls. <br><br>
 * <b>NOTE: This base class should never be declared in a screen's declaration. It will not actually render and return a tile. It is simply an abstract base class.</b>
 * @namespace CoreTile
 * @memberof $ui
 * @extends $ui.CoreComponent
 */
function $ui_CoreTile(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	if (object) {
		$ui.addClass(object.dom,'ui-tile theme-text-color theme-tile-border-color theme-screen-background-color');
		object._contentShowing = false;
		/** 
		 * The size of a tile. This property should be set by the internal code of a derivative Tile class.
		 * @name _size
		 * @memberof $ui.CoreTile
		 * @protected
		 * @type {$ui.TileSize}
		 */
		if (object._size && (object._size != $ui.TileSize.STANDARD)) {
			$ui.addClass(object.dom, object._size);
		}
		object._protected._size = object._size;
		Object.defineProperty(object, '_size', {
			get: function() {return this._protected._size;},
			set: function() {
				console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','_size'));			
			},
			configurable: false}
		);
		
		// Create our loading area
		object.dom.loadingDiv = document.createElement('div');
		$ui.addClass(object.dom.loadingDiv, 'loading');
		object.dom.appendChild(object.dom.loadingDiv);
		object.dom.spinner = new $ui_Spinner({component: $ui.Spinner, size: $ui.Spinner.SMALL},screen);
		object.dom.loadingDiv.appendChild(object.dom.spinner);
		
		// Create our content area
		object.dom.contentDiv = document.createElement('div');
		$ui.addClass(object.dom.contentDiv, 'content');
		object.dom.appendChild(object.dom.contentDiv);	
		
		/** 
		 * This function is to be called when a tile needs to be toggled between the loading state and content state. 
		 * @function showContent
		 * @memberof $ui.CoreTile
		 * @param {boolean} value - The value parameter represents the boolean state of visibility of the tile content.
		 */
		object.showContent = function(value) {
			if (value == this._contentShowing) return;
			if (value) {
				this.dom.loadingDiv.style.display = 'none';
				this.dom.contentDiv.style.display = 'inherit';
			} else {
				this.dom.loadingDiv.style.display = 'inline';
				this.dom.contentDiv.style.display = 'none';
			}
			this._contentShowing = value;
		}.$bind(object);
	}
}
/**
 * The CoreTileDonutChart is the abstract base class of any donut chart tiles. This base class should never be declared in a screen's declaration.
 * <b>NOTE: It will not actually render and return a tile. It is simply an abstract base class.</b>
 * @namespace CoreTileDonutChart
 * @memberof $ui
 * @extends $ui.CoreTile
 */
function $ui_CoreTileDonutChart(object, screen) {
	// Set our default animation
	if (object.animated == undefined) {
		object.animated = true;
	}
	$ui_CoreTile.call(this, object, screen);
	if (object) {
		$ui.addClass(object.dom,'ui-tile-donut-chart');

		// Create our chart area
		object.dom.chartDiv = document.createElement('div');
		$ui.addClass(object.dom.chartDiv, 'chart'); // Base class styling
		object.dom.contentDiv.appendChild(object.dom.chartDiv);
		
		// Create our canvas area
		object.dom.canvas = document.createElement('canvas');
		object.dom.chartDiv.appendChild(object.dom.canvas);

		// Create our chart
		object.chart = new Chart(object.dom.canvas.getContext('2d'));
		
		/** 
		 * This function takes a value parameter which is an array of data point objects. These data point objects defined a section of the chart and consist of two properties representing value and color
		 * @function _setData
		 * @memberof $ui.CoreTileDonutChart
		 * @param {object[]} value - Array of data points. <br/><b>Example:</b>
		 * <pre>
		 * [
		 *   {
		 *      value: 10,
		 *      color: '#000000',
		 *   },
		 *   {
		 *      value: 90,
		 *      color: '#FEFEFE',
		 *   }
		 * ]
		 * </pre>
		 * @protected
		 */
		object._setData = function(data) {
			this._protected.data = data;
			this.chart.Doughnut(data,{showTooltips: false, animation: this.animated, segmentStrokeColor : "transparent",});
		}.$bind(object);
		
		// Create the caption area
		object.dom.caption = document.createElement('div');
		$ui.addClass(object.dom.caption,'caption');
		object.dom.contentDiv.appendChild(object.dom.caption);
		
		/** 
		 * This function will set the caption of the Donut chart.
		 * @function _setCaption
		 * @memberof $ui.CoreTileDonutChart
		 * @param {string} value - Text for the caption
		 * @protected
		 */
		object._setCaption = function(value) {
			this.dom.caption.innerHTML = value;
		}.$bind(object);
		
		// Create the accent area
		object.dom.accent = document.createElement('div');
		$ui.addClass(object.dom.accent,'accent');
		object.dom.contentDiv.appendChild(object.dom.accent);
		object.dom.accent.style.color = $ui.theme.chart.color;
		
		/** 
		 * This function will set the accent text of the Donut chart
		 * @function _setAccent
		 * @memberof $ui.CoreTileDonutChart
		 * @param {string} value - Text for the accent
		 * @protected
		 */
		object._setAccent = function(value) {
			if (value == undefined) {
				$ui.removeClass(this.dom.contentDiv, 'has-accent');
				this.dom.accent.textContent = '';
				this.accent = value;
				return;
			}
			this.accent = value;
			$ui.addClass(this.dom.contentDiv, 'has-accent');
			this.dom.accent.textContent = value;
		}.$bind(object);
	}
}
/**
 * The CoreTileGauge is the abstract base class of any gauge chart tiles.
 * <b>NOTE: It will not actually render and return a tile. It is simply an abstract base class.</b><br><br>
 * <b>Sample Declaration:</b>
 * <pre>
 * {
 *    min: 0,
 *    max: 1.5,
 *    value: 1
 *}
 * </pre>
 * @namespace CoreTileGauge
 * @memberof $ui
 * @extends $ui.CoreTile
 * @property {number} min - This is the minimum numeric value that you want to display at the left hand side of the gauge
 * @property {number} max - This is the maximum numeric value that you want to display at the right hand side of the gauge
 * @property {number} value - The numeric value you want to display. This should be between min and max.
 */
function $ui_CoreTileGauge(object, screen) {
	if (object) object._size = undefined; // Always square
	$ui_CoreTile.call(this, object, screen);
	if (object) {
		$ui.addClass(object.dom,'ui-tile-gauge');

		// Create our title area
		object.dom.titleDiv = document.createElement('div');
		$ui.addClass(object.dom.titleDiv,'title');
		object.dom.contentDiv.appendChild(object.dom.titleDiv);
		
		/** 
		 * This function will set the title of the gauge chart.
		 * @function _setTitle
		 * @memberof $ui.CoreTileGauge
		 * @param {string} value - Value to be used as the title
		 * @protected
		 */
		object._setTitle = function(value) {
			if (value == undefined || value == null) value = '';
			object.dom.titleDiv.textContent = value;
		}.$bind(object);
		
		// Create our chart area
		object.dom.chartDiv = document.createElement('div');
		$ui.addClass(object.dom.chartDiv, 'chart'); // Base class styling
		object.dom.contentDiv.appendChild(object.dom.chartDiv);
		
		// Create our canvas area
		object.dom.canvas = document.createElement('canvas');
		object.dom.canvas.width = 200;
		object.dom.canvas.height = 200;
		$ui.addClass(object.dom.canvas,'graph-canvas');
		object.dom.chartDiv.appendChild(object.dom.canvas);

		// Add our bottom labels
		object.dom.labels = document.createElement('div');
		$ui.addClass(object.dom.labels, 'labels-area');
		object.dom.chartDiv.appendChild(object.dom.labels);
		
		// Min Label
		object.dom.minLabel = document.createElement('div');
		$ui.addClass(object.dom.minLabel, 'label');
		$ui.addClass(object.dom.minLabel, 'left');
		object.dom.labels.appendChild(object.dom.minLabel);
		
		// Max Label
		object.dom.maxLabel = document.createElement('div');
		$ui.addClass(object.dom.maxLabel, 'label');
		$ui.addClass(object.dom.maxLabel, 'right');
		object.dom.labels.appendChild(object.dom.maxLabel);
		
		// Accent Label
		object.dom.accentLabel = document.createElement('div');
		$ui.addClass(object.dom.accentLabel, 'label');
		$ui.addClass(object.dom.accentLabel, 'center');
		object.dom.labels.appendChild(object.dom.accentLabel);
		/** 
		 * This function will set the title of the gauge chart.
		 * @function _setAccent
		 * @memberof $ui.CoreTileGauge
		 * @param {string} value - Value to use as the accent text
		 * @protected
		 */
		object._setAccent = function(value) {
			if (value == undefined || value == null) value = '';
			object.dom.accentLabel.textContent = value;
		}
		object._setAccent = object._setAccent.$bind(object);
		
		// Value Label
		object.dom.valueDiv = document.createElement('div');
		$ui.addClass(object.dom.valueDiv, 'value');
		object.dom.chartDiv.appendChild(object.dom.valueDiv);
		
		// Create our chart Context 
		var ctx = object.dom.canvas.getContext('2d');
		object.dom.ctx = ctx;
		object._width = object.dom.canvas.width;
		object._height = object.dom.canvas.height;
		
		// This will render our filled in area
		object._renderLoop = function() {
			if (this._degrees > this._newDegrees) {
				return;
			}
			requestAnimationFrame(this._renderLoop)
			
			//Angle in radians = angle in degrees * PI / 180
			var ctx = this.dom.ctx,
				radians = this._degrees * Math.PI / 180;
			
			//Clear the canvas every time a chart is drawn
			ctx.clearRect(0, 0, this._width, this._height);
		
			//Background 180 degree arc
			ctx.beginPath();
			ctx.strokeStyle = $ui.theme.chart.color;
			ctx.lineWidth = 40;
			ctx.arc(this._width/2, this._height/2, 80, 0 - 180*Math.PI/180, Math.PI/180, false); //you can see the arc now
			ctx.stroke();
			
			// Now render our value
			ctx.beginPath();
			ctx.strokeStyle = this._color;
			//The arc starts from the rightmost end. If we deduct 180 degrees from the angles
			//the arc will start from the leftmost end
			ctx.arc(this._width/2, this._height/2, 80, 0 - 180*Math.PI/180, radians - 180*Math.PI/180, false); 
			//you can see the arc now
			ctx.stroke();
			
			if (this._degrees <= this._newDegrees) {
				this._degrees = this._degrees + this._step;
			}
			
		}.$bind(object);
		
		// This function will populate the control with the current values and then render the control
		object._populateData = function() {
			// Correct any bad data
			if (this.min == undefined) this.min = 0;
			if (this.max == undefined) this.max = 100;
			if (this.value == undefined) this.value = this.min;
			if (this.value < this.min) this.value = this.min;
			
			// Set our labels
			this.dom.minLabel.textContent = this.min;
			this.dom.maxLabel.textContent = this.max;
			this.dom.valueDiv.textContent = this.value;
			
			var percent = ((this.value - this.min)/this.max);
			this._newDegrees = percent * 180;
			switch (true) {
				case (percent < 0.33):
					this._color = $ui.theme.chart.color_GREAT;
					this._step = 2;
					break;
				case (percent < 0.77):
					this._color = $ui.theme.chart.color_GOOD;
					this._step = 7;
					break;
				default:
					this._color = $ui.theme.chart.color_OK;
					this._step = 10;
					break;
			}
			//this._degrees = 0;
			this._degrees = this._newDegrees - this._step;// temporary to stop slow animation
			this._renderLoop();
		}.$bind(object);
	}
}
/**
 * The DockLayout object represents a layout that allows for a static content and also scrolling content. The DockLayout will size itself to all the available space provided by its parent control.
 * <br><br><b>Sample Declaration</b>
 * <pre>
 * {
 *    component: $ui.DockLayout,
 *    dock: [
 *        {
 *            component: $ui.SegmentedControl,
 *            options: ['one','two']
 *        }
 *    ],
 *    content: [
 *        {
 *            component: $ui.List
 *        }
 *    ]
 *}
 * </pre>
 * @namespace DockLayout
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {$ui.CoreComponent[]} dock - This array holds all of the component definitions for the docked content
 * @property {$ui.CoreComponent[]} content - This array holds all of the component definitions for the scrollable area of the dock layout
 * @property {$ui.DockLayout.DockLocation} [location=$ui.DockLayout.DockLocation.TOP] - This property allows you to set the location of the docked content.
 */
function $ui_DockLayout(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom,'ui-dock-layout');
	
	// Create our dock area
	object.dom.dock = document.createElement('div');
	$ui.addClass(object.dom.dock, 'dock');
	
	var i,
		control,
		controlDom;
	
	// Load our dock
	if (object.dock) {
		for (i = 0; i < object.dock.length; i++) {
			control = object.dock[i];
			controlDom = $ui.createControl(control, screen);
			if (controlDom) {
				object.dom.dock.appendChild(controlDom);
			}
		}
	}
	
	// Create our contents area
	object.dom.contentDiv = document.createElement('div');
	$ui.addClass(object.dom.contentDiv, 'contents');
	
	// Load our contents
	if (object.content) {
		for (i = 0; i < object.content.length; i++) {
			control = object.content[i];
			controlDom = $ui.createControl(control, screen);
			if (controlDom) {
				object.dom.contentDiv.appendChild(controlDom);
			}
		}
	}
	
	// Check our dock location
	if (object.location === $ui.DockLayout.DockLocation.BOTTOM) {
		object.dom.appendChild(object.dom.contentDiv);
		object.dom.appendChild(object.dom.dock)
	} else {
		object.dom.appendChild(object.dom.dock)
		object.dom.appendChild(object.dom.contentDiv);
	}
	
	return object.dom;
}
/**
 * The generic list item type is used with the {@link $ui.List} component. A List component will define the type of list item it wishes to display by setting the <b>style</b> property of the control. 
 * <br><br><b>Sample Declaration</b>
 * <pre>
 * {
 *   img: 'thumbnails/foo.png',
 *   title: 'This is my title',
 *   accent: '6 hours ago',
 *   caption: 'My summary description'
 *}
 * </pre>
 * @namespace GenericListItem
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {string} [img] - Represents the path to the image that will appear in the list item
 * @property {string} title - Represents the main title to display
 * @property {string} [accent] - Represents the accent text to go along with the title and caption
 * @property {string} [caption] - Represents the main text to show in the list item
 */
function $ui_GenericListItem(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom, 'ui-generic-list-item theme-text-color theme-screen-background-color theme-dark-border-color');
	
	if ($ui.theme.inHeadUnit == true) {
		$ui.addClass(object.dom, 'in-head-unit');
	}
	
	// Create the image
	object.dom.img = document.createElement('div');
	$ui.addClass(object.dom.img,'img');
	object.dom.appendChild(object.dom.img);
	
	// Details section
	object.dom.details = document.createElement('div');
	$ui.addClass(object.dom.details,'details');
	object.dom.appendChild(object.dom.details);
	
	// Title
	object.dom.titleArea = document.createElement('div');
	$ui.addClass(object.dom.titleArea,'title');
	object.dom.details.appendChild(object.dom.titleArea);

	// Caption
	object.dom.captionDiv = document.createElement('div');
	$ui.addClass(object.dom.captionDiv,'caption');
	object.dom.details.appendChild(object.dom.captionDiv);
	
	// Accent
	object.dom.accent = document.createElement('div');
	$ui.addClass(object.dom.accent,'accent theme-generic-list-accent-color');
	object.dom.details.appendChild(object.dom.accent);
	
	// Load the image
	object._loadImage = function() {
		if(this.img != undefined && this.img != null && this.img != '') {
			// Image Loader
			this._loader = new Image();
			this._loader.model = object;
			this._loader.onload = function() {
				this.model.dom.img.style.backgroundImage = 'url("'+ this.model.img + '")';
				this.model.dom.img.style.opacity = '1.0';
				this.model._loader = undefined;
			}
			this._loader.onerror = function() {
				this.model.dom.img.style.backgroundImage = '';
				this.model.dom.img.style.opacity = '1.0';
				this.model._loader = undefined;
			}
			this._loader.src = object.img;
		} else {
			this.dom.img.style.opacity = '1.0';
			this.dom.loader = undefined;
		}
	}.$bind(object);
	
	// img property
	object._loadImage();
	object._protected.img = object.img;
	Object.defineProperty(object, 'img', {
		get: function() {return this._protected.img;},
		set: function(value) {
			if (value == this._protected.img) return;
			this._protected.img = value;
			this._loadImage();
		},
		configurable: false}
	);
	
	// Caption property
	if (object.caption) {
		object.dom.captionDiv.textContent = object.caption;
	} else {
		$ui.addClass(object.dom, 'no-caption');
	}
	object._protected.caption = object.caption;
	Object.defineProperty(object, 'caption', {
		get: function() {return this._protected.caption;},
		set: function(value) {
			if (value == this._protected.caption) return;
			this._protected.caption = value;
			if (value == undefined) {
				$ui.addClass(this.dom, 'no-caption');
			} else {
				$ui.removeClass(this.dom, 'no-caption');
				this.dom.captionDiv.textContent = value;
			}
		},
		configurable: false}
	);
	
	// accent Property
	if(object.accent != undefined) {
		object.dom.accent.textContent = object.accent;
		$ui.addClass(object.dom, 'has-accent');
	} 
	object._protected.accent = object.accent;
	Object.defineProperty(object, 'accent', {
		get: function() {return this._protected.accent;},
		set: function(value) {
			if (value == this._protected.accent) return;
			this._protected.accent = value;
			if (value == undefined) {
				$ui.removeClass(this.dom, 'has-accent');
			} else {
				$ui.addClass(this.dom, 'has-accent');
			}
		},
		configurable: false}
	);
	
	// Title Property
	object.dom.titleArea.textContent = object.title;
	object._protected.title = object.title;
	Object.defineProperty(object, 'title', {
		get: function() {return this._protected.title;},
		set: function(value) {
			if (value == this._protected.title) return;
			this._protected.title = value;
			this.dom.titleArea.textContent = value;
		},
		configurable: false}
	);
	
	// Handle our touch events
	object.dom.ontouchstart = function() {
		$ui.removeClass(this, 'theme-screen-background-color');
		$ui.addClass(this, 'theme-brand-background-color');
		$ui.removeClass(this, 'theme-text-color');
		$ui.addClass(this, 'theme-highlight-text-color');
		// Update our accent text
		if (this.model.dom && this.model.dom.accent) {
			$ui.removeClass(this.model.dom.accent, 'theme-generic-list-accent-color');
		}
	}
	object.dom.ontouchend = function() {
		$ui.removeClass(this, 'theme-brand-background-color');
		$ui.addClass(this, 'theme-screen-background-color');
		$ui.removeClass(this, 'theme-highlight-text-color');
		$ui.addClass(this, 'theme-text-color');
		// Update our accent text
		if (this.model.dom && this.model.dom.accent) {
			$ui.addClass(this.model.dom.accent, 'theme-generic-list-accent-color');
		}
	}
	object.dom.ontouchcancel = object.dom.ontouchend;
	if (!$ui.isMobileDevice()) {
		object.dom.onmousedown = object.dom.ontouchstart;
		object.dom.onmouseup = object.dom.ontouchend;
		object.dom.onmouseleave = object.dom.ontouchend;
	}

	// Pass the onclick back to the list
	object.dom.addEventListener('click', function() {
		if (this.model.parent.onaction == undefined) return;
		var event = new ListEvent(this.model, $ui.GenericListItem.GenericListEvent.ONCLICK);
		this.model.parent._onaction(this.model, event);
		$ui.playTouchSound();
	},false);

	return object.dom;
}
/**
 * The Header object represents a screen separator with a caption.  This component can be useful when you wish to label different areas of the screen.  Headers can also be used as
 * an item in a {@link $ui.List} control<br><br>
 * <b>Sample Declaration</b><br>
 * <pre>
 * {
 *   component: $ui.Header,
 *   caption: 'My Lovely Header'
 * }
 * @namespace Header
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {string} [caption] - The caption to be displayed in the control
*/
function $ui_Header(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom,'ui-header theme-text-color theme-brand-border-color');
	if ($ui.theme.inHeadUnit == true) {
		$ui.addClass(object.dom, 'in-head-unit');
	}
	if (object.caption) {
		object.dom.textContent = object.caption;
	}
	
	return object.dom;
}
/**
 * The image list item type is used with the {@link $ui.List} component. A List component will define the type of list item it wishes to display by setting the <b>style</b> property of the control. 
 * <br><br><b>Sample Declaration</b>
 * <pre>
 * {
 *   img: 'thumbnails/foo.png',
 *   caption: 'My summary description'
 *}
 * </pre>
 * @namespace ImageListItem
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {string} img - Represents the path to the image that will appear in the list item
 * @property {string} [caption] - Represents the main text to show in the list item
 */
function $ui_ImageListItem(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom, 'ui-image-list-item');
	
	// Create the image
	object.dom.img = document.createElement('div');
	$ui.addClass(object.dom.img,'img');
	object.dom.appendChild(object.dom.img);
	
	if(object.img != undefined && object.img != null && object.img != '') {
		// Image Loader
		object._loader = new Image();
		object._loader.model = object;
		object._loader.onload = function() {
			this.model.dom.img.style.backgroundImage = 'url("'+ this.model.img + '")';
			this.model.dom.img.style.opacity = '1.0';
			this.model._loader = undefined;
		}
		object._loader.onerror = function() {
			this.model.dom.img.style.backgroundImage = '';
			this.model.dom.img.style.opacity = '1.0';
			this.model._loader = undefined;
		}
		object._loader.src = object.img;
	} else {
		object.dom.img.style.opacity = '1.0';
		object.dom.loader = undefined;
	}
	

	// Caption
	object.dom.captionDiv = document.createElement('div');
	$ui.addClass(object.dom.captionDiv,'caption theme-highlight-text-color');
	object.dom.appendChild(object.dom.captionDiv);
	if (object.caption) {
		object.dom.captionDiv.textContent = object.caption;
	} else {
		$ui.addClass(object.dom.captionDiv, 'no-caption');
	}

	// Pass the onclick back to the list
	object.dom.addEventListener('click', function() {
		if (this.model.parent.onaction == undefined) return;
		var event = new ListEvent(this.model, $ui.ImageListItem.ImageListEvent.ONCLICK);
		this.model.parent._onaction(this.model, event);
		$ui.playTouchSound();
	},false);

	return object.dom;
}
/**
 * An input can provide either single line or multi-line input with various different display options and interactions<br>
 * <b>Sample Declaration</b>
 * <pre>
 * {
 *     component: $ui.Input,
 *     hint: 'Password',
 *     password: true,
 *     onenterkey: function() {
 *        // Login
 *    }
 * }
 * @namespace Input
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {string} [text] - The text that is contained in the input
 * @property {string} [hint] - The to show up as background "hint" text to let the user know what to enter into the control
 * @property {number} [tabIndex] - Optionally set the tab index for this input
 * @property {$ui.Input.InputType} [inputType] - Optionally set the type of input for this field. By default it is text.
 * @property {boolean} [password=false] - Set this value to <b>true</b> if you wish to have a password mask on the control
 * @property {boolean} [warning=false] - This <b>read only</b> flag will be set to <b>true</b> if the control has a validation error.
 * @property {boolean} [multiLine=false] - Set this value to <b>true</b> if you wish the control to allow for multi-line input
 * @property {number} [minLinesToShow=1] - This optional property allows you to specify how many lines high a multiLine input should be by default. 
 * The minLinesToShow property is ignored if multiLine is not set to <b>true</b>. The property is also ignored if it is not greater than 1 which is the default.<br><br> 
 * The control will then show a minimum number of lines as specified, but will also grow as the user types in content that will extend that minimum number just like it regularly does with a multiLine input.
 * @property {number} [maxLinesToShow=1] - This optional property allows you to specify how many lines high a multiLine input should grow to. The maxLinesToShow property is ignored if multiLine is not set to <b>true</b>. The property is also ignored if it is not greater than 1 which is the default. The control will then grow to a maximum number of lines as specified.
 * @property {GenericEvent} [onenterkey] - This event will fire when the user presses the enter key on their keyboard
 * @property {GenericEvent} [onchange] - The onchange event will fire whenever the user types in the input box. <i>NOTE: It will not fire when the text property is changed programatically.</i>
 * @property {GenericEvent} [onfocus] - The onfocus event will fire whenever the input received the focus.
 * @property {GenericEvent} [onblur] - The onblur event will fire whenever the input box loses focus.
 * @property {GenericEvent} [onvalidate] - The onvalidate event will fire when the <b>validate()</b> function is called. If you wish to have the validation fail, return <b>false</b> from your function. When validate() is called it will perform internal validation based on the <b>inputType</b> and also call the onvalidate function.  If either returns false the input will go into its warning state 
 */
function $ui_Input(object, screen){
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom, 'ui-input');
	object.dom.style.borderColor = $ui.theme.borderColor;
	
	if ($ui.isApple == true) {
		$ui.addClass(object.dom, 'iOS');
	}
	
	if ($ui.theme.inHeadUnit == true) {
		$ui.addClass(object.dom, 'in-head-unit');
	}
	
	// inputType property
	object._protected.inputType = object.inputType;
	Object.defineProperty(object, 'inputType', {
		get: function() {return this._protected.inputType;},
		set: function() {
			console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','inputType'));
		},
		configurable: false}
	);
	
	// Warning property
	object.warning = false;
	object._protected.warning = object.warning;
	Object.defineProperty(object, 'warning', {
		get: function() {return this._protected.warning;},
		set: function() {
			console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','warning'));
		},
		configurable: false}
	);
	
	// Configure our placeholder
	object.dom.placeholder = document.createElement('div');
	$ui.addClass(object.dom.placeholder,'placeholder theme-hint-text-color');
	object.dom.appendChild(object.dom.placeholder);

	// Multi-Line property
	object._protected.multiLine = object.multiLine;
	Object.defineProperty(object, 'multiLine', {
		get: function() {return this._protected.multiLine;},
		set: function() {
			console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','multiLine'));
		},
		configurable: false}
	);
	
	// Private function called from the base class for setting the enabled state
	object._setEnabled = function(value) {
		if (value == true) {
			this.dom.input.removeAttribute('readonly');
			// TODO: Set Color
		} else {
			this.dom.input.setAttribute('readonly','true');
			// TODO: Set Color
		}
	}.$bind(object);
	
	// Style our enabled state
	if (object.enabled == false) {
		object._setEnabled(false);
	}
	
	// Figure out if we need to set the placeholder/hint
	object.computePlaceholder = function() {
		var small = (this.dom.input.value == '' || this.dom.input.value == undefined) ? false : true;
		if (small) {
			$ui.addClass(this.dom.placeholder,'draw-small');
			$ui.addClass(this.dom.input, 'small-placeholder');
			if (this.dom.textAreaSize != undefined) {
				$ui.addClass(this.dom.textAreaSize, 'small-placeholder');
			}
		} else {
			$ui.removeClass(this.dom.placeholder,'draw-small')
			$ui.removeClass(this.dom.input, 'small-placeholder');
			if (this.dom.textAreaSize != undefined) {
				$ui.removeClass(this.dom.textAreaSize, 'small-placeholder');
			}
		}
	}.$bind(object);
	
	// See if it is single or multi-line input
	if (object.multiLine == true) {
		object.dom.input = document.createElement('textarea');
		$ui.addClass(object.dom.input, 'textarea');
		object.dom.appendChild(object.dom.input);
		object.dom.textAreaSize = document.createElement('div');
		$ui.addClass(object.dom.textAreaSize, 'textarea-size');
		object.dom.appendChild(object.dom.textAreaSize);
		// Check for text
		if (object.text) {
			object.dom.input.value = object.text;
			object.dom.textAreaSize.innerHTML = object.text;
		}
		if ((object.minLinesToShow != undefined) && (parseInt(object.minLinesToShow) > 1)) {
			var minHeight = object.minLinesToShow * 35;
			object.dom.textAreaSize.style['min-height'] = minHeight + 'px';
		}
		if ((object.maxLinesToShow != undefined) && (parseInt(object.maxLinesToShow) > 1)) {
			var maxHeight = (object.maxLinesToShow -1) * 35;
			object.dom.textAreaSize.style['max-height'] = maxHeight + 'px';
			object.dom.input.style['overflow-y'] = 'scroll';
			object.dom.input.onscroll = function() {
				if (this.scrollTop > 0) {
					this.model.dom.placeholder.style.display = 'none';
				} else {
					this.model.dom.placeholder.style.display = 'inherit';
				}
			}
		}
	} else {
		// Create our actual input box
		object.dom.input = document.createElement('input');		
		if(object.password == true){
			object.dom.input.setAttribute('type', 'password');
		}
		else {
			object.dom.input.setAttribute('type', 'text');
		}
		$ui.addClass(object.dom.input, 'text');
		object.dom.input.style.color = $ui.theme.textColor;
		// Check for text
		if (object.text) {
			object.dom.input.setAttribute('value',object.text);
		}
		object.dom.appendChild(object.dom.input);
	} 
	// Set our automation markers
	if (object.id) {
		object.dom.input.setAttribute('data-interaction-input',object.id);
	}
		
	object.dom.input.onfocus = function() {
		this.model.dom.style.borderColor = $ui.theme.color;
		$ui.addClass(this.model.dom, 'theme-brand-border-color');
		if (this.model.onfocus) {
			this.model.onfocus();
		}
	}
	
	object.dom.input.onblur = function() {
		$ui.removeClass(this.model.dom, 'theme-brand-border-color');
		if (this.model.onblur) {
			this.model.onblur();
		}
	}
	
	// Assign our pointers
	object.dom.input.model = object;
	object.computePlaceholder();
	
	// tabIndex property
	if (object.tabIndex != undefined) {
		object.dom.input.tabIndex = object.tabIndex;
	}
	object._protected.tabIndex = object.tabIndex;
	Object.defineProperty(object, 'tabIndex', {
		get: function() {return this._protected.tabIndex;},
		set: function() {
			console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','tabIndex'));
		},
		configurable: false}
	);
	
	// Prevent FastClick for dom.input if-and-only-if it's multiline input field if it's Apple Device
	if($ui.isApple === true) {
		if(object.multiLine === true) {
			object.dom.input.addEventListener('touchstart',function(e) {
				e.stopPropagation();
			},false);
			object.dom.input.addEventListener('touchend',function(e) {
				e.stopPropagation();
			},false);
		}
	} else {
		object.dom.input.addEventListener('touchstart',function(e) {
			e.stopPropagation();
		},false);
		object.dom.input.addEventListener('touchend',function(e) {
			e.stopPropagation();
		},false);
	}
	
	// Trap the keyup to trigger the event
	object.dom.input.addEventListener('keyup',function(e) {
		// See if they pressed enter
		if ((e.keyCode == 13) && (this.model.onenterkey)) {
			this.model.onenterkey();
		} 
	},false);
	
	// Trap the keydown to check input types
	object.dom.input.addEventListener('keydown',function(e) {
		// Check our input type
		if (this.model.inputType == $ui.Input.InputType.INTEGER || this.model.inputType == $ui.Input.InputType.FLOAT) {
			if (e.keyCode == 127 || e.keyCode == 8 || e.keyCode == 9 || e.keyCode == 13 || e.keyCode == 46 || e.keyCode == 37 || e.keyCode == 39) return;
			if ((e.keyCode >= 48 && e.keyCode <= 57) || (e.keyCode >= 96 && e.keyCode <= 105)) return;
			if ((e.keyCode == 110 || e.keyCode == 190) && this.model.inputType == $ui.Input.InputType.FLOAT) {
				return;
			}
			e.preventDefault();
		}
	},false);
	
	object.dom.input.addEventListener('input',function(e) {
		this.model._raiseInteractionEvent('data-interaction-input');
		this.model._protected.text = this.value;
		// Adjust our multi-line size by adjusting the outer div height
		if (this.model.multiLine == true) {
			this.model.dom.textAreaSize.innerHTML = this.value.replace(new RegExp('\n', 'g'), '<br>&nbsp;');//this.value;
		} 
		// Calculate our placeholder position and update the data provider
		this.model.computePlaceholder();
		this.model._updateData(this.model.text);
		// Fire our onchange event
		if (this.model.onchange) {
			this.model.onchange();
		}
	},false);
	
	
	// Text Property
	object._protected.text = object.text;
	Object.defineProperty(object, 'text', {
		get: function() {return this._protected.text;},
		set: function(value) {
			if (value == this._protected.text) return;
			this._setText(value);
			this._updateData(this.text);
		},
		configurable: false}
	);
	
	/**
	* This function will set focus to the input control
	* @function setFocus
	* @memberof $ui.Input
	*/
	object.setFocus = function(value) {
		this.dom.input.focus();
	}.$bind(object);
	
	// Private function to set the text
	object._setText = function(value) {
		if (value == undefined) {
			value = '';
		}
		this._protected.warning = false;
		$ui.removeClass(this.dom.input, 'theme-warning-text-color');
		$ui.removeClass(this.dom.placeholder, 'theme-warning-text-color');
		this._protected.text = value;
		if (this.multiLine == true) {
			$ui.removeClass(this.dom.input, 'placeholder');
			this.dom.input.value = value;
			this.dom.textAreaSize.innerHTML = value;
			this.dom.input.onblur();
		} else {
			this.dom.input.value = this._protected.text;
		}
		this.computePlaceholder();
	}.$bind(object);
	
	// Hint Property
	if (object.hint == undefined) {
		object.hint = '';
	}
	object.dom.placeholder.textContent = object.hint;
	object._protected.hint = object.hint;
	Object.defineProperty(object, 'hint', {
		get: function() {return this._protected.hint;},
		set: function(value) {
			if (value == undefined) value = '';
			if (value == this._protected.hint) return;
			this._protected.hint = value;
			this.dom.placeholder.textContent = value;
			this.computePlaceholder();
		},
		configurable: false}
	);
	
	/**
	* This function will validate the contents of the input control and return <b>false</b> if the contents are not valid
	* @function validate
	* @returns {boolean}
	* @memberof $ui.Input
	*/
	object.validate = function() {
		// Check for custom validation
		if (this.onvalidate) {
			if (this.onvalidate() == false) {
				this._protected.warning = true;
			}
		}
		if (this._protected.warning == true) {
			$ui.addClass(this.dom.input,'theme-warning-text-color');
			$ui.addClass(this.dom.placeholder, 'theme-warning-text-color');
		} else {
			$ui.removeClass(this.dom.input,'theme-warning-text-color');
			$ui.removeClass(this.dom.placeholder, 'theme-warning-text-color');
			if (this._protected.hadNoHint == true) {
				this.hint = undefined;
			} else {
				this.dom.placeholder.textContent = this.hint;
			}
		}
		return !this._protected.warning;
	}.$bind(object);
	
	// Private function to handle provider updates
	object._providerUpdate = function(value) {
		this._setText(value);
	}.$bind(object);
	
	return object.dom;
}



/**
 * This object defines the type of background to be shown on the screen.<br><br>
 * <b>Sample Code:</b><br>
 * <pre>
 * {
 *   img: 'img/background.png', 
 *   repeat: true, 
 *}
 * </pre>
 * @class ScreenBackground
 * @param {string} img - Path to the background image
 * @param {boolean} [repeat=false] - Whether or not you want the background repeated/tiled
 */
function ScreenBackground(img, repeat) {
	/** 
	 * Path to the background image
	 * @member {string} img
	 * @memberOf ScreenBackground
	 */
	if (img == null) throw new Error('ScreenBackground: img cannot be null');
	if (img == undefined) throw new Error('ScreenBackground: img cannot be undefined');
	this.img = img;
	/** 
	 * Whether or not you want the background repeated/tiled
	 * @member {boolean} [repeat=false]
	 * @memberOf ScreenBackground
	 */
	if (repeat == undefined || repeat == null) {
		this.repeat = false;
	}
}
/**
 * The segmented control provides an actionable item for the user to choose between multiple options.
 * A segmented control's width will fill the width of the container in which it is a member.<br><br>
 * <b>Sample Declaration</b><br>
 * <pre>
 * {
 *   component: $ui.SegmentedControl,
 *   selectedIndex: 0,
 *   options: ['One', 'Two', 'Three'],
 *   onclick: function() {
 *      alert('You clicked: ' + this.options[this.selectedIndex]);
 *   }
 *}
 * @namespace SegmentedControl
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {number} [selectedIndex=0] - Represents the index of the option you want to be selected. This property will also be updated whenever a user selects an option from the control. 
 * @property {string[]} options - This property represents the options provided by the control. It is an array of string values that will be displayed
 * @property {GenericEvent} [onclick] - The onclick event will fire when the user selects/clicks an option in the control. You can retrieve which option was selected by inspecting the <b>selectedIndex</b> property.
 */
function $ui_SegmentedControl(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom,'ui-segmented-control theme-segmented-control');
	if ($ui.theme.inHeadUnit == true) {
		$ui.addClass(object.dom, 'in-head-unit');
	}
	object.domOptions = [];
	
	/** 
	 * You can set the selected index for the control by using this function. This function will also raise the <i>onclick</i> event as though a user just clicked the control.
	 * @function setSelectedIndex
	 * @memberof $ui.SegmentedControl
	 * @param {number} index - Item to be added to the menu
	 */
	object.setSelectedIndex = function(index) {
		if (this.selectedIndex != index) {
			this.selectedIndex = index;
			// Trigger the onclick
			if (this.onclick) {
				this.onclick(); 
			}
		} 
		this._setSelectedIndex(index);
	}.$bind(object);
	
	// Private function to set the selected index for the control
	object._setSelectedIndex = function(index) {
		if (this.options) {
			var i,
				option;
			for (i = 0; i < this.domOptions.length; i++) {
				option = this.domOptions[i];
				if (i == index) {
					option._setSelected(true);
				} else {
					option._setSelected(false);
				}
			}
		}
	}.$bind(object);
	
	// Go through our options
	if (object.options) {
		var i,
			option, 
			percentage = 100/object.options.length;
		
		for (i = 0; i < object.options.length; i++) {
			option = document.createElement('div');
			$ui.addClass(option,'button');
			if (i == 0) {
				$ui.addClass(option,'left');
			} else if (i == object.options.length -1) {
				$ui.addClass(option,'right');
			}
			option.model = object;
			option.index = i;
			option.selected = false;
			option.style.width = percentage + '%';
			option.style.left = (i * percentage) + '%';
			option.textContent = object.options[i];
			object.domOptions.push(option);
			object.dom.appendChild(option);
			
			// Pass the onclick back to the list
			option.addEventListener('click', function() {
				if (this.model.enabled == false) return;
				if (this.selected) return;
				this.model.setSelectedIndex(this.index);
			},false);
			
			// Change the selected state for the button
			option._setSelected = function(value) {
				this.selected = value;
				if (value == true) {
					$ui.addClass(this,'selected');
					$ui.addClass(this,'theme-brand-background-color');
					$ui.addClass(this,'theme-highlight-text-color');
				} else {
					$ui.removeClass(this,'selected');
					$ui.removeClass(this,'theme-brand-background-color');
					$ui.removeClass(this,'theme-highlight-text-color');
				}
			}.$bind(option);
		}
	}
	// Set our selected index
	if (object.selectedIndex) {
		object._setSelectedIndex(object.selectedIndex);
	} else {
		object.selectedIndex = 0;
		object._setSelectedIndex(0);
	}
	
	return object.dom;
}

/**
 * The SplitView object represents two vertical columns for layout components. The SplitView will size itself to all the available space provided by its parent control.
 * <br><br><b>Sample Declaration</b>
 * <pre>
 * {
 *    component: $ui.SplitView,
 *    left: [
 *        {
 *            component: $ui.SegmentedControl
 *        }
 *    ],
 *    right: [
 *        {
 *            component: $ui.Spinner
 *        }
 *    ]
 * }
 * </pre>
 * @namespace SplitView
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {$ui.CoreComponent[]} left - This array holds all of the component definitions for the left side of the split view
 * @property {$ui.CoreComponent[]} right - This array holds all of the component definitions for the right side of the split view
 */
function $ui_SplitView(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom,'ui-split-view');
	
	var i,
		control,
		controlDom;
	
	// Create our left column
	object.dom.leftCol = document.createElement('div');
	$ui.addClass(object.dom.leftCol, 'col');
	$ui.addClass(object.dom.leftCol, 'left theme-brand-border-color');
	object.dom.appendChild(object.dom.leftCol);
	
	// Load our left column
	if (object.left) {
		for (i = 0; i < object.left.length; i++) {
			control = object.left[i];
			controlDom = $ui.createControl(control, screen);
			if (controlDom) {
				object.dom.leftCol.appendChild(controlDom);
			}
		}
	}
	
	// Create our right column
	object.dom.rightCol = document.createElement('div');
	$ui.addClass(object.dom.rightCol, 'col');
	$ui.addClass(object.dom.rightCol, 'right');
	object.dom.appendChild(object.dom.rightCol);
	
	// Load our right column
	if (object.right) {
		for (i = 0; i < object.right.length; i++) {
			control = object.right[i];
			controlDom = $ui.createControl(control, screen);
			if (controlDom) {
				object.dom.rightCol.appendChild(controlDom);
			}
		}
	}
	
	return object.dom;
}
/**
 * The Tab object represents a tab within a {@link $ui.TabbedPane}.  A tab represents a container of multiple other controls
 * <br><br><b>Sample Declaration</b>
 * <pre>
 * {
 *    component: $ui.Tab,
 *    content: [
 *        {
 *            component: $ui.Spinner
 *        }
 *    ]
 * }
 * </pre>
 * @namespace Tab
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {$ui.CoreComponent[]} content - This array holds all of the component definitions to be displayed in the tab
 * @property {boolean} [selected=false] - This property, when set to <i>true</i> will specify that the tab should be the default selected tab in the [Tabbed Pane]{@link $ui.TabbedPane}.  The Tabbed Pane will select only the first tab it encounters with selected set to <i>true</i> as the selected tab.
 */
function $ui_Tab(object, screen) {
	// All tabs are invisible by default
	object.visible = false;
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom,'ui-tab');
	// Set our default
	if (object.selected != true) {
		object.selected = false;
	}
	
	var i,
		control,
		controlDom;
	// Load our contents
	if (object.content) {
		for (i = 0; i < object.content.length; i++) {
			control = object.content[i];
			controlDom = $ui.createControl(control, screen);
			if (controlDom) {
				object.dom.appendChild(controlDom);
			}
		}
	}
	
	return object.dom;
}
/**
 * The TabbedPane object represents a container that has one or more {@link $ui.Tab} objects.<br><br>
 * A Tabbed Pane will cover the entire area of the control it is contained by. The control will cycle through all of the defined Tabs and see which one has been specified as the first selected tab. If no tabs are found with the specified <b>selected:true</b> property, it will select the first tab in the list.
 * <br><br><b>Sample Declaration</b>
 * <pre>
 * {
 *    component: $ui.TabbedPane,
 *    tabs: [
 *        {
 *            component: $ui.Tab,
 *            selected: true
 *        }
 *    ]
 * }
 * </pre>
 * @namespace TabbedPane
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {$ui.Tab[]} content - This array holds all of the {@link $ui.Tab} objects that are to be controlled by the tabbed pane
*/
function $ui_TabbedPane(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom,'ui-tabbed-pane');
	// Set our default selected tab
	object._selectedTab = undefined;
	
	var i,
		control,
		controlDom,
		selectedTab;
	// Load our tabs
	if (object.tabs) {
		for (i = 0; i < object.tabs.length; i++) {
			control = object.tabs[i];
			if (control.component != $ui.Tab) continue;
			control.parent = object;
			controlDom = $ui.createControl(control, screen);
			if (controlDom) {
				object.dom.appendChild(controlDom);
			}
			// See if it is the selected tab
			if ((control.selected === true) && (object._selectedTab == undefined)) {
				object._selectedTab = control;
			}
		}
	}
	
	/** 
	 * This function will set the selected tab to the value passed in as a parameter
	 * @function selectTab
	 * @memberof $ui.TabbedPane
	 * @param {$ui.Tab} tab - Tab to select
	 */
	object.selectTab = function(tab) {
		if (tab == undefined) return;
		if (tab.component != $ui.Tab) return;
		if (tab === this._selectedTab) return;
		// Unselect all tabs
		var i,
			item;
		for (i = 0; i < this.tabs.length; i++) {
			item = this.tabs[i];
			item.selected = false;
			item.visible = false;
		}
		// Now select the desired tab
		this._selectTab(tab);
	}.$bind(object);
	
	// Private function to select a tab
	object._selectTab = function(tab) {
		if (tab == undefined) return;
		if (tab.component != $ui.Tab) return;
		object._selectedTab = tab;
		tab.selected = true;
		tab.visible = true;
	}.$bind(object);
	
	// Set our selected tab
	if ((object._selectedTab == undefined) && (object.tabs.length > 0)){
		object._selectedTab = object.tabs[0];
	}
	if (object._selectedTab != undefined) {
		object._selectTab(object._selectedTab);
	}
	
	return object.dom;
}
/**
 * The Tile Group object represents a container that holds one or more tiles that inherit from {@link $ui.CoreTile}.
 * <br><br><b>Sample Declaration</b>
 * <pre>
 * {
 *    component: $ui.TileGroup,
 *    tiles: [
 *        {
 *            component: $ui.TileCool,
 *            value: 70
 *        {
 *    ]
 * }
 * </pre>
 * @namespace TileGroup
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {$ui.CoreTile[]} tiles - This array holds all of the Tiles which are to be displayed
 */
function $ui_TileGroup(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom,'ui-tile-group');
	if ($ui.theme.inHeadUnit == true) {
		$ui.addClass(object.dom,'in-head-unit');
	}
	
	// Set our default tile size
	object._tileSize = 256;
	object._thresholdWidth = 1024;
	
	// Create the inner area for the tiles
	object.dom.inner = document.createElement('div');
	$ui.addClass(object.dom.inner, 'group-inner');
	object.dom.appendChild(object.dom.inner);
	
	// Create a matrix for keeping track of open slots
	object.matrix = [];

	// From the row and column number set the top left of the tile
	object._setTileTopLeft = function(tile, rowNum, colNum) {
		tile.dom.style.top = ((rowNum  * this._tileSize) + 'px');
		tile.dom.style.left = ((colNum * this._tileSize) + 'px');
	}.$bind(object);
	
	// Best position the tile in the group
	object._positionTile = function(tile) {
		var row,
			colNum,
			rowNum,
			found = false;
		
		if (tile._size == undefined) { 
			// Will fit in a 1x1 slot..find first slot and insert
			for (rowNum = 0; rowNum < this.matrix.length; rowNum++) {
				row = this.matrix[rowNum];
				for (colNum = 0; colNum < row.length; colNum++) {
					if (row[colNum] === 0) {
						// This space is empty. Now mark it as taken
						row[colNum] = 1;
						this._setTileTopLeft(tile,rowNum,colNum);
						found = true;
						break;
					}
				}
				if (found == true) break;
			}
		} else if (tile._size == $ui.TileSize.WIDE) { 
			// Will fit in a 1x2 slot..find first slot and insert
			for (rowNum = 0; rowNum < this.matrix.length; rowNum++) {
				row = this.matrix[rowNum];
				for (colNum = 0; colNum < row.length; colNum++) {
					if (row[colNum] === 0) {
						if ((colNum+1 <= row.length) && (row[colNum+1] === 0)){
							// This space is empty. Now mark it as taken
							row[colNum] = 1;
							row[colNum+1] = 1;
							this._setTileTopLeft(tile,rowNum,colNum);
							found = true;
							break;
						}
					}
				}
				if (found == true) break;
			}
		} else if (tile._size == $ui.TileSize.TALL) { 
			// Will fit in a 2x1 slot..find first slot and insert
			for (rowNum = 0; rowNum < this.matrix.length; rowNum++) {
				row = this.matrix[rowNum];
				for (colNum = 0; colNum < row.length; colNum++) {
					if (row[colNum] === 0) {
						if ((rowNum+1 < this.matrix.length) && (this.matrix[rowNum+1][colNum] === 0)){
							// This space is empty. Now mark it as taken
							row[colNum] = 1;
							this.matrix[rowNum+1][colNum] = 1;
							this._setTileTopLeft(tile,rowNum,colNum);
							found = true;
							break;
						}
					}
				}
				if (found == true) break;
			}
		} else if (tile._size == $ui.TileSize.SQUARE) { 
			// Will fit in a 2x2 slot..find first slot and insert
			for (rowNum = 0; rowNum < this.matrix.length; rowNum++) {
				row = this.matrix[rowNum];
				for (colNum = 0; colNum < row.length; colNum++) {
					if (row[colNum] === 0) {
						if ((rowNum+1 < this.matrix.length) && (this.matrix[rowNum+1][colNum] === 0) &&
							(colNum+1 < row.length) && (this.matrix[rowNum+1][colNum+1] === 0)){
							// This space is empty. Now mark it as taken
							row[colNum] = 1;
							row[colNum+1] = 1;
							this.matrix[rowNum+1][colNum] = 1;
							this.matrix[rowNum+1][colNum+1] = 1;
							this._setTileTopLeft(tile,rowNum,colNum);
							found = true;
							break;
						}
					}
				}
				if (found == true) break;
			}
		}
		
		// See if no open slot was found
		if (found == false) {
			if (tile._size == undefined) {
				// Add one row and take the first slot
				if (object._is3Columns == true) {
					this.matrix.push([1,0,0]);
				} else {
					this.matrix.push([1,0,0,0]);
				}
				this._setTileTopLeft(tile,this.matrix.length-1,0);
			} else if (tile._size == $ui.TileSize.WIDE) {
				// Add one row and take the first two slots
				if (object._is3Columns == true) {
					this.matrix.push([1,1,0]);
				} else {
					this.matrix.push([1,1,0,0]);
				}
				this._setTileTopLeft(tile,this.matrix.length-1,0);
			} else {
				// Add one row and try again
				if (object._is3Columns == true) {
					this.matrix.push([0,0,0]);
				} else {
					this.matrix.push([0,0,0,0]);
				}
				this._positionTile(tile);
			}
		}
	}.$bind(object);
	
	// Figure out our height based on the matrix
	object._recalculateHeight = function() {
		this.dom.inner.style.height = ((this.matrix.length * this._tileSize) + 'px');
	}.$bind(object);
	
	// Cycle through content
	if (object.tiles) {
		var i,
			control,
			controlDom;
		for (i = 0; i < object.tiles.length; i++) {
			control = object.tiles[i];
			controlDom = $ui.createControl(control, screen);
			if (controlDom) {
				object.dom.inner.appendChild(controlDom);
			}
		}
		object._recalculateHeight();
	}
	
	// Layout all the tiles
	object._layoutTiles = function() {
		var i;
		if (this._is3Columns == false) {
			this.matrix = [];
			this.matrix.push([0,0,0,0]);
		} else {
			this.matrix = [];
			this.matrix.push([0,0,0]);
		}
		// Cycle through our tiles and position them
		for (i = 0; i < this.tiles.length; i++) {
			this._positionTile(this.tiles[i]);
		}
		this._recalculateHeight();
	}.$bind(object);
	
	// Handle resize of screen
	object._onresize = function() {
		if ($ui.options.isClientDevice != true) {
			if ((this._is3Columns == true) && (this.dom.offsetWidth >= this._thresholdWidth)) {
				this._layoutTiles();
			} else if ((this._is3Columns == false) && (this.dom.offsetWidth < this._thresholdWidth)){
				this._layoutTiles();
			}
		}
	}.$bind(object);
	
	// Properly layout the control once animation ends
	object._onshow = function() {
		if ($ui.options.isClientDevice != true) {
			this._is3Columns = (this.dom.offsetWidth < this._thresholdWidth);
			this._layoutTiles();
		}
		this.dom.style.visibility = 'visible';
	}.$bind(object);
	
	return object.dom;
}
/**
 * The Toggle allows a user to move something from a checked/unchecked state typically denoting off/on.
 * <br><br><b>Sample Declaration</b>
 * <pre>
 * {
 *    component: $ui.Toggle,
 *    style: $ui.Toggle.Style.OnOff,
 *    position: 1
 * }
 * </pre>
 * @namespace Toggle
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {number} [position=0] - Represents the position of the switch. 0 represents <b>off</b>, 1 represents <b>on</b> and -1 represents <b>on</b> in reverse direction
 * @property {string} [align=left] - Optionally specify the alignment of the caption as "left", "right" or "center"
 * @property {string} [caption] - Caption to appear with the toggle
 * @property {string} [negativeLabel] - Optional label for the Negative position of an On-Off-On style toggle
 * @property {string} [positiveLabel] - Optional label for the Positive position of an On-Off-On style toggle
 * @property {number} [duration=0] - How long the switch should stay in the <b>on</b> position in milliseconds. A value of 0 means no duration.
 * @property {GenericEvent} [onclick] - Fires when a user clicks the control or changes its state
 */
function $ui_Toggle(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom,'ui-toggle');
		
	if ($ui.theme.inHeadUnit == true) {
		$ui.addClass(object.dom, 'in-head-unit');
	}
	
	// Create our bottom border
	object.dom.bottomBorder = document.createElement('div');
	$ui.addClass(object.dom.bottomBorder, 'bottom-border theme-dark-background-color');
	object.dom.appendChild(object.dom.bottomBorder);
	
	// Create our caption area
	object.dom.caption = document.createElement('span');
	$ui.addClass(object.dom.caption,'caption theme-text-color');
	object.dom.appendChild(object.dom.caption);
	
	// Create our duration area
	object.dom.duration = document.createElement('div');
	$ui.addClass(object.dom.duration, 'duration');
	object.dom.appendChild(object.dom.duration);
	// Bottom
	object.dom.duration.bottomDiv = document.createElement('div');
	$ui.addClass(object.dom.duration.bottomDiv, 'bottom');
	object.dom.duration.appendChild(object.dom.duration.bottomDiv);
	// Number
	object.dom.duration.number = document.createElement('div');
	$ui.addClass(object.dom.duration.number, 'number theme-highlight-text-color');
	object.dom.duration.bottomDiv.appendChild(object.dom.duration.number);
	// Bar
	object.dom.duration.bar = document.createElement('div');
	$ui.addClass(object.dom.duration.bar, 'bar theme-brand-background-color');
	object.dom.duration.bottomDiv.appendChild(object.dom.duration.bar);
	
	// style property
	if (object.style == undefined) {
		object.style = $ui.Toggle.Style.OnOff;
	}
	$ui.addClass(object.dom, object.style);
	object._protected.style = object.style;
	Object.defineProperty(object, 'style', {
		get: function() {return this._protected.style;},
		set: function(value) {
			if (value == undefined) value = $ui.Toggle.Style.OnOff;
			if (value == this._protected.style) return;
			$ui.removeClass(this.dom, this._protected.style);
			if (this._protected.style == $ui.Toggle.Style.OnOff) {
				this.dom.removeChild(this.dom.innerToggle);
			} else if (this._protected.style == $ui.Toggle.Style.Momentary) {
				this.dom.removeChild(this.dom.momentary);
			} else if (this._protected.style == $ui.Toggle.Style.OnOffOn) {
				this.dom.removeChild(this.dom.innerToggle);
			}
			this._protected.style = value;
			$ui.addClass(this.dom, this._protected.style);
			if (value == $ui.Toggle.Style.OnOff) {
				this._createOnOffStyle();
				this._setPosition(this.position);
			} else if (value == $ui.Toggle.Style.Momentary) {
				this._createMomentaryStyle();
			} else if (value == $ui.Toggle.Style.OnOffOn) {
				this._createOnOffOnStyle();
				this._setPosition(this.position);
			}
		},
		configurable: false}
	);
	
	// Handles creating our on-off style of toggle switch
	object._createOnOffStyle = function() {
		// Create our inner Toggle area
		this.dom.innerToggle = document.createElement('div');
		this.dom.innerToggle.model = this;
		$ui.addClass(this.dom.innerToggle, 'inner-toggle theme-border-color');
		this.dom.appendChild(this.dom.innerToggle);
		// Create our inner slide
		this.dom.slide = document.createElement('div');
		$ui.addClass(this.dom.slide,'slide');
		this.dom.innerToggle.appendChild(this.dom.slide);
		// Create our yes area
		this.dom.left = document.createElement('div');
		$ui.addClass(this.dom.left,'left');
		this.dom.slide.appendChild(this.dom.left);
		// Create our button area
		this.dom.button = document.createElement('div');
		$ui.addClass(this.dom.button,'button theme-border-color');
		this.dom.slide.appendChild(this.dom.button);
		this.dom.button.inner = document.createElement('div');
		$ui.addClass(this.dom.button.inner, 'button-inner theme-brand-border-color');
		this.dom.button.appendChild(this.dom.button.inner);
		// Create our right area
		this.dom.right = document.createElement('div');
		$ui.addClass(this.dom.right,'right');
		this.dom.slide.appendChild(this.dom.right);
		// Fire the onclick
		this.dom.innerToggle.addEventListener('click', function() {
			if (this.model.enabled == false) return;
			if (this.model._protected.isCountingDown == true) return;
			$ui.playTouchSound();
			if (this.model.position == 0) {
				this.model.position = 1;
			} else {
				this.model.position = 0;
			}
			if (this.model.onclick) {
				this.model.onclick(this.model);
			}
		},false);
	}.$bind(object);
	
	// Handles creating our on-off-on style of toggle switch
	object._createOnOffOnStyle = function() {
		// Create our inner Toggle area
		this.dom.innerToggle = document.createElement('div');
		this.dom.innerToggle.model = this;
		$ui.addClass(this.dom.innerToggle, 'inner-toggle theme-border-color');
		this.dom.appendChild(this.dom.innerToggle);
		// Create our inner slide
		this.dom.slide = document.createElement('div');
		$ui.addClass(this.dom.slide,'slide');
		this.dom.innerToggle.appendChild(this.dom.slide);
		// Create our left area
		this.dom.left = document.createElement('div');
		$ui.addClass(this.dom.left,'left');
		this.dom.slide.appendChild(this.dom.left);
		this.dom.left.label = document.createElement('div');
		$ui.addClass(this.dom.left.label, 'label theme-dark-text-color');
		this.dom.left.appendChild(this.dom.left.label);
		if (this.negativeLabel != undefined && this.style == $ui.Toggle.Style.OnOffOn) {
			this.dom.left.label.textContent = this.negativeLabel;
		}	
		// Create our button area
		this.dom.button = document.createElement('div');
		$ui.addClass(this.dom.button,'button theme-border-color');
		this.dom.slide.appendChild(this.dom.button);
		this.dom.button.inner = document.createElement('div');
		$ui.addClass(this.dom.button.inner, 'button-inner theme-brand-border-color');
		this.dom.button.appendChild(this.dom.button.inner);
		// Create our right area
		this.dom.right = document.createElement('div');
		$ui.addClass(this.dom.right,'right');
		this.dom.slide.appendChild(this.dom.right);
		this.dom.right.label = document.createElement('div');
		$ui.addClass(this.dom.right.label, 'label theme-dark-text-color');
		this.dom.right.appendChild(this.dom.right.label);
		if (this.positiveLabel != undefined && this.style == $ui.Toggle.Style.OnOffOn) {
			this.dom.right.label.textContent = this.positiveLabel;
		}	
		// Fire the onclick
		this.dom.innerToggle.onclick = function(event) {
			if (this.model.enabled == false) return;
			if (this.model._protected.isCountingDown == true) return;
			$ui.playTouchSound();
			var rect = this.getBoundingClientRect(),
				third = (rect.right - rect.left)/3;	
			if (event.clientX < (rect.left + third)) {
				this.model.position = -1; // Negative
			} else if (event.clientX > (rect.right - third)) {
				this.model.position = 1; // Positive
			} else {
				this.model.position = 0; // Off
			}
			if (this.model.onclick) {
				this.model.onclick(this.model);
			}
		};
	}.$bind(object);
	
	// Create our DOM for a momentary switch
	object._createMomentaryStyle = function() {
		this.dom.momentary = document.createElement('div');
		this.dom.momentary.model = this;
		$ui.addClass(this.dom.momentary, 'momentary theme-brand-background-color theme-highlight-text-color');
		this.dom.appendChild(this.dom.momentary);
		this.dom.momentary.onclick = function(event) {
			if (this.model._protected.isCountingDown == true) return;
			if (this.model.enabled == false) return;
			$ui.playTouchSound();
			this.model.position = 1;
			if (this.model.onclick) {
				this.model.onclick(this.model);
			}
			if (this.model.duration == undefined || this.model.duration <= 0) {
				var model = this.model;
				window.setTimeout(function() {
					model.position = 0;
				}, 500);
			}
		};
		this.dom.momentary.ontouchstart = function() {
			this.style.opacity = '0.7';
		};
		this.dom.momentary.ontouchend = function() {
			this.style.opacity = '';
		};
		this.dom.momentary.ontouchcancel = this.dom.momentary.ontouchend;
		if (!$ui.isMobileDevice()) {
			this.dom.momentary.onmousedown = this.dom.momentary.ontouchstart;
			this.dom.momentary.onmouseup = this.dom.momentary.ontouchend;
			this.dom.momentary.onmouseleave = this.dom.momentary.ontouchend;
		}
	}.$bind(object);
	
	// This is our standard toggle
	if (object.style == $ui.Toggle.Style.OnOff) {
		object._createOnOffStyle();
	} else if (object.style == $ui.Toggle.Style.Momentary) { // Our momentary switch styling
		object._createMomentaryStyle();
	} else if (object.style == $ui.Toggle.Style.OnOffOn) {
		object._createOnOffOnStyle();
	}
	
	// positiveLabel Property
	object._protected.positiveLabel = object.positiveLabel;
	Object.defineProperty(object, 'positiveLabel', {
		get: function() {return this._protected.positiveLabel;},
		set: function(value) {
			if (value == undefined) value = '';
			if (value == this._protected.positiveLabel) return;
			this._protected.positiveLabel = value;
			if (this.style == $ui.Toggle.Style.OnOffOn) {
				this.dom.right.label.textContent = value;
			}
		},
		configurable: false}
	);
	
	// negativeLabel Property
	object._protected.negativeLabel = object.negativeLabel;
	Object.defineProperty(object, 'negativeLabel', {
		get: function() {return this._protected.negativeLabel;},
		set: function(value) {
			if (value == undefined) value = '';
			if (value == this._protected.negativeLabel) return;
			this._protected.negativeLabel = value;
			if (this.style == $ui.Toggle.Style.OnOffOn) {
				this.dom.left.label.textContent = value;
			}
		},
		configurable: false}
	);
	
	// Caption Property
	if (object.caption != undefined) {
		object.dom.caption.textContent = object.caption;
	}	
	object._protected.caption = object.caption;
	Object.defineProperty(object, 'caption', {
		get: function() {return this._protected.caption;},
		set: function(value) {
			if (value == this._protected.caption) return;
			if (value == undefined) value = '';
			this._protected.caption = value;
			this.dom.caption.textContent = value;
		},
		configurable: false}
	);
	
	// align property
	if (object.align == 'center') {
		$ui.addClass(object.dom.caption,'align-center');
	} else if (object.align == 'right') {
		$ui.addClass(object.dom.caption,'align-right');
	} else {
		object.align = 'left';
		$ui.addClass(object.dom.caption,'align-left');
	}
	object._protected.align = object.align;
	Object.defineProperty(object, 'align', {
		get: function() {return this._protected.align;},
		set: function() {
			console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','align'));
		},
		configurable: false}
	);
	
	// Private function to set the position state
	object._setPosition = function(value) {
		if (value == undefined) {
			value = 0;
		}
		this._protected.position = value;
		if (this.style == $ui.Toggle.Style.OnOff) {
			if (value == 0) {
				$ui.removeClass(this.dom.innerToggle,'yes');
				$ui.removeClass(this.dom.innerToggle, 'theme-brand-background-color');
				$ui.removeClass(this.dom.button.inner,'theme-light-background-color');
				$ui.addClass(this.dom.innerToggle,'no');
			} else {
				$ui.removeClass(this.dom.innerToggle, 'no');
				$ui.addClass(this.dom.innerToggle,'yes theme-brand-background-color');
				$ui.addClass(this.dom.button.inner,'theme-light-background-color');
			}
		} else if (this.style == $ui.Toggle.Style.OnOffOn) {
			$ui.removeClass(this.dom.innerToggle, 'theme-brand-background-color');
			$ui.removeClass(this.dom.button.inner,'theme-light-background-color');
			if (value == 0) {
				$ui.removeClass(this.dom.innerToggle,'positive');
				$ui.removeClass(this.dom.innerToggle,'negative');
				this.dom.right.label.style.display = 'block';
				this.dom.left.label.style.display = 'block';
			} else if (value == 1) {
				$ui.removeClass(this.dom.innerToggle, 'negative');
				$ui.addClass(this.dom.innerToggle,'positive theme-brand-background-color');
				$ui.addClass(this.dom.button.inner,'theme-light-background-color');
				this.dom.right.label.style.display = 'none';
				this.dom.left.label.style.display = 'none';
			} else {
				$ui.removeClass(this.dom.innerToggle, 'positive');
				$ui.addClass(this.dom.innerToggle,'negative theme-brand-background-color');
				$ui.addClass(this.dom.button.inner,'theme-light-background-color');
				this.dom.right.label.style.display = 'none';
				this.dom.left.label.style.display = 'none';
			}
		}
	}.$bind(object);
	
	// duration Property
	if (object.duration == undefined) {
		object.duration = 0;
	}
	if (object.duration > 0) {
		object.dom.duration.style.display = 'block';
	}
	object._protected.duration = object.duration;
	Object.defineProperty(object, 'duration', {
		get: function() {return this._protected.duration;},
		set: function(value) {
			if (value == undefined) value = 0;
			if (value == this._protected.duration) return;
			this._protected.duration = value;
			if (value <= 0) {
				this.dom.duration.style.display = 'none';
			} else {
				this.dom.duration.style.display = 'block';
			}
		},
		configurable: false}
	);
	
	// position Property
	if (object.position == undefined) {
		object.position = 0;
	}
	object._setPosition(object.position);
	object._protected.position = object.position;
	Object.defineProperty(object, 'position', {
		get: function() {return this._protected.position;},
		set: function(value) {
			if (value == this._protected.position) return;
			this._protected.position = value;
			this._setPosition(value);
			this._updateData(value); // update our provider
			if (value == 0) {
				this._protected.isCountingDown = false;
				this.dom.duration.bottomDiv.style.opacity = 0;
				this.dom.duration.style['-webkit-transform'] = 'translate3d(0px, 0px, 0px)';
				if (this.style == $ui.Toggle.Style.OnOff || this.style == $ui.Toggle.Style.OnOffOn) {
					this.dom.innerToggle.style.opacity = 1;
				} else {
					this.dom.momentary.style.opacity = 1;
				}
			} else if ( this.duration && this.duration > 0) {
				this.dom.duration.bottomDiv.style.opacity = 1;
				if ($ui.options.isClientDevice == true) {
					this.dom.duration.style['-webkit-transform'] = 'translate3d(-20px, -10px, 0px)';
				} else {
					this.dom.duration.style['-webkit-transform'] = 'translate3d(-26px, -14px, 0px)';
				}
				this._protected.intervalCount = this.duration;
				this._protected.isCountingDown = true;
				this.dom.duration.bar.style.width = '100%';
				this.dom.duration.number.textContent = (this._protected.intervalCount/1000);
				this._protected.interval = window.setInterval(this._countDownInterval, 1000);
				if (this.style == $ui.Toggle.Style.OnOff || this.style == $ui.Toggle.Style.OnOffOn) {
					this.dom.innerToggle.style.opacity = 0.5;
				} else {
					this.dom.momentary.style.opacity = 0.5;
				}
			}
		},
		configurable: false}
	);
	
	// Handle our count down interval
	object._countDownInterval = function() {
		this._protected.intervalCount = this._protected.intervalCount - 1000;
		var rounded = this._protected.intervalCount / 1000;
		if (rounded < 0) {
			rounded = 0;
		}
		this.dom.duration.number.textContent = rounded;
		this.dom.duration.bar.style.width = (1 - (this._protected.duration - this._protected.intervalCount)/this._protected.duration) *100 + '%';
		if (this._protected.intervalCount <= 0) {
			window.clearInterval(this._protected.interval);
			this.position = 0;
		}
	}.$bind(object);
	
	// Private function to handle provider updates
	object._providerUpdate = function(value) {
		this._setPosition(value);
	}.$bind(object);
	
	object._ondestroy = function() {
		if (this._protected.interval) {
			window.clearInterval(this._protected.interval);
		}
	}.$bind(object);
	
	return object.dom;
}

/**
 * This is the object that represents a window instance in a head unit. It derives from {@link $ui.CoreScreen}. A WindowPane is declared as a JavaScript function and has various different properties. 
 * When a WindowPane is pushed onto the stack a new instance of the screen will be created and rendered.
 * <br><br><b>Sample Declaration</b>
 * <pre>
 * function MyWindowPane() {
 *   this.component = $ui.WindowPane;
 *   this.content = [
 *       {
 *          component: $ui.SegmentedControl,
 *       }
 *   ];
 *
 *   this.onshow = function() {
 *      console.log('I was just shown');
 *   }
 * }
 * </pre>
 * @namespace WindowPane
 * @memberof $ui
 * @extends $ui.CoreScreen
 * @property {ScreenBackground} [background] - This object defines the type of background to be shown on the screen
 * @property {$ui.CoreComponent[]} content - This object array specifies the list of controls that will be rendered in this screen
 * @property {string} [backCaption] - This property defines the text you would like to appear on the title bar with a back button. If this is left <i>undefined</i> then no back button will appear
 * @property {GenericEvent} [onbackclick] - This event fires when the user presses the "Back" button.  It allows you to run logic before the screen is popped off of the stack.  If you wish to block the "Back" action return <b>false</b> from your event handler
 */
function $ui_WindowPane(object, data) {
	$ui_CoreScreen.call(this, object, data);
	if (object) {
		$ui.addClass(object.dom,'ui-window-pane theme-screen-background-color');
		if ($ui.theme.inHeadUnit == true) {
			$ui.addClass(object.dom, 'in-head-unit');
		}
		
		// Set our width to that of our parent
		if (!object.width) {
			object.dom.style.width = window.innerWidth + 'px'; // default
		} else {
			object.dom.style.width = object.width + 'px';
		}
		
		// Create our background image div
		object.dom.backgroundDiv = document.createElement('div');
		$ui.addClass(object.dom.backgroundDiv,'background theme-screen-background-color');
		object.dom.appendChild(object.dom.backgroundDiv);
		
		if (object.backCaption) {
			object.dom.backBar = document.createElement('div');
			$ui.addClass(object.dom.backBar,'back-bar theme-screen-background-color theme-brand-border-color');
			$ui.addClass(object.dom,'has-back');
			object.dom.appendChild(object.dom.backBar);
			object.dom.backCaption = document.createElement('span');
			object.dom.backCaption.textContent = object.backCaption;
			object.dom.backCaption.model = object;
			$ui.addClass(object.dom.backCaption,'caption theme-text-color');
			object.dom.backBar.appendChild(object.dom.backCaption);
			object.dom.backCaption.onclick = function() {
				$ui.playTouchSound();
				if (this.model.onbackclick) {
					var allow = this.model.onbackclick();
					if (allow != false) {
						$ui.pop();
					}
				} else {
					$ui.pop();
				}
			};
			try {
				Object.defineProperty(object,"backCaption",{
					get:function() {
						return object.dom.backCaption.textContent;
					},set:function(newCaption) {
						console.log("RPW: setting caption to " + newCaption);
						object.dom.backCaption.textContent = newCaption;
					}
				});
			} catch (toIgnore) {
				console.log("RPW: ignoring " + toIgnore);
			}
		}

		/** 
		 * Set the background for the screen
		 * @function setBackground
		 * @memberof $ui.WindowPane
		 * @param {ScreenBackground} screenBackground - The background object to use for the screen.
		 */
		object.setBackground = function(screenBackground) {
			// Clear existing background
			if (this.background) {
				this.dom.backgroundDiv.style.opacity = '0';
			} 
			// Load new background
			if (screenBackground != undefined) {
				this.background = screenBackground;
				// Check for repeat
				if (this.background.repeat === true) {
					this.dom.backgroundDiv.style.backgroundRepeat = 'repeat';
				} else {
					this.dom.backgroundDiv.style.backgroundSize = 'cover';
				}
				// Load our image
				if (this.background.img) {
					this._loader = new Image();
					this._loader.model = this;
					this._loader.onload = function() {
						this.model.dom.backgroundDiv.style.backgroundImage = 'url("'+this.model.background.img+'")';
						this.model.dom.backgroundDiv.style.opacity = '1';
						this.model._loader = null;
					}
					this._loader.src = this.background.img;
				}
			}
		}.$bind(object);
				
		// Create our content div for the controls
		object.dom.contentDiv = document.createElement('div');
		$ui.addClass(object.dom.contentDiv, 'inner');
		object.dom.appendChild(object.dom.contentDiv);
		
		// content Property
		object._protected.content = object.content;
		Object.defineProperty(object, 'content', {
			get: function() {return this._protected.content;},
			set: function() {
				console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','content'));
			},
			configurable: false} 
		);
		
		// Implementing CoreContainerComponent Interface
		object._getControlListProperty = function() {
			return this.content;
		}.$bind(object);
		
		// Implementing CoreContainerComponent Interface
		object._getControlListDom = function() {
			return this.dom.contentDiv;
		}.$bind(object);
		
		// Create all the content
		if (object.content) {
			for (var i = 0; i < object.content.length; i++) {
				object._addComponent(object.content[i]);
			}
		}
		
		// Handle window pane resizes
		object._onwindowpaneresize = function() {
			// Set our width to that of our parent
			this.dom.style.width = '';
			this.dom.style.right = '0px';
		}.$bind(object);
		
		// Clean-up any listeners
		object._onbeforepop = function() {
			if (this.animated == true) {
				this.dom.style['-webkit-animation-delay'] = '';
				this.dom.style['-webkit-animation-name'] = 'ui-pane-slide-right';
			}
		}.$bind(object);
		
		// Initialize the screen
		object._initialize = function() {
			// Load the background if needed
			if (this.background) {
				this.setBackground(this.background);
			}
		}.$bind(object);
		
		return object.dom;
	}
}
/**
 * The Browser control represents the browser window including both the chrome and the viewer.<br><br>
 * This object will create an iframe area while in demo mode. But when in PhoneGap it will create a child browser window that it will overlay on the screen.<br><br>
 * <b>Sample Declaration</b><br>
 * <pre>
 * {
 *    component: $ui.Browser,
 *    src: 'http://workshoptwelve.com'
 * }
 * @namespace Browser
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {string} [src] - The url path of the browser
 * @property {GenericEvent} [onfavoriteclick] - Fired when the user selects to add a favorite
 * @property {GenericEvent} [onbookmarksclick] - Fired when a user wants to see their bookmarks
*/
function $ui_Browser(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom,'ui-browser');
	// Check to see if we are in the emulator
	if (window.$system && ($system.config.isEmulator == true)) {
		object._protected.isIFrame = false;
	} else {
		object._protected.isIFrame = true;
	}
	
	// Create our chrome
	object.dom.chrome = document.createElement('div');
	$ui.addClass(object.dom.chrome,'chrome theme-brand-border-color');
	object.dom.appendChild(object.dom.chrome);
	
	// URL input
	object.dom.inputDiv = document.createElement('div');
	$ui.addClass(object.dom.inputDiv,'inputDiv theme-light-background-color theme-brand-border-color');
	object.dom.chrome.appendChild(object.dom.inputDiv);
	object.dom.input = document.createElement('input');
	object.dom.input.model = object;
	object.dom.input.setAttribute('spellcheck','false');
	object.dom.inputDiv.appendChild(object.dom.input);
	// Handle focus and clearing
	object.dom.input.onclick = function(e) {
		if ((this.offsetWidth - e.offsetX) <= 30) {
			this.value = '';
		}
	}
	// Handle enter key
	object.dom.input.onkeyup = function(e) {
		if (e.keyCode == 13) {
			this.model.src = this.value;
		}
	}

	// Create our icon/spinner area
	object.dom.icon = document.createElement('div');
	$ui.addClass(object.dom.icon,'icon');
	object.dom.inputDiv.appendChild(object.dom.icon);
	object.dom.spinner = new $ui_Spinner({component: $ui.Spinner, size: $ui.Size.TINY, forceColor:'dark'},screen);
	object.dom.spinner.style.display = 'none';
	object.dom.icon.appendChild(object.dom.spinner);
	
	// Back button
	object._backBtn = {style: 'back',parent: object};
	new $ui_BrowserButton(object._backBtn,screen);
	object.dom.chrome.appendChild(object._backBtn.dom);
	object._backBtn.dom.onclick = function() {
		if (this.model.parent._protected.isIFrame == false) {
			var webview = this.model.parent.dom.contentWindow;
			if (webview.canGoBack() == true) {
				webview.back();	
			}
		}
	}
	
	// Next button
	object._nextBtn = {style: 'next',parent: object};
	new $ui_BrowserButton(object._nextBtn,screen);
	object.dom.chrome.appendChild(object._nextBtn.dom);
	object._nextBtn.dom.onclick = function() {
		if (this.model.parent._protected.isIFrame == false) {
			var webview = this.model.parent.dom.contentWindow;
			if (webview.canGoForward() == true) {
				webview.forward();	
			}
		}
	}
	
	// Stop/Refresh button
	object._refreshBtn = {style: 'stop',parent: object};
	new $ui_BrowserButton(object._refreshBtn,screen);
	object.dom.chrome.appendChild(object._refreshBtn.dom);
	object._refreshBtn.dom.onclick = function() {
		if (this.model.parent._protected.isIFrame == false) {
			var webview = this.model.parent.dom.contentWindow;
			if (this.model.style == 'stop') {
				webview.stop();
			} else {
				webview.reload();
			}
		}
	}
	
	// New Tab button
	object._newTabBtn = {style: 'new-tab',parent: object};
	new $ui_BrowserButton(object._newTabBtn,screen);
	object.dom.chrome.appendChild(object._newTabBtn.dom);
	object._newTabBtn.dom.onclick = function() {
		if (this.model.parent._protected.isIFrame == false) {
			$ui.toast('Sorry! Tabs aren\'t enabled yet in the emulator');
		}
	}
	
	// Favorite Button
	object._favoriteBtn = {style: 'favorite',parent: object};
	new $ui_BrowserButton(object._favoriteBtn,screen);
	object.dom.chrome.appendChild(object._favoriteBtn.dom);
	object._favoriteBtn.dom.onclick = function() {
		if (this.model.parent._protected.isIFrame == false) {
			if (this.model.parent.onfavoriteclick) {
				this.model.parent.onfavoriteclick();
			}
		}
	}
	
	// Bookmarks Button
	object._bookmarksBtn = {style: 'bookmarks',parent: object};
	new $ui_BrowserButton(object._bookmarksBtn,screen);
	object.dom.chrome.appendChild(object._bookmarksBtn.dom);
	object._bookmarksBtn.dom.onclick = function() {
		if (this.model.parent._protected.isIFrame == false) {
			if (this.model.parent.onbookmarksclick) {
				this.model.parent.onbookmarksclick();
			}
		}
	};
	
	// Create our Browser display area
	object.dom.browserDiv = document.createElement('div');
	$ui.addClass(object.dom.browserDiv,'browserDiv');
	object.dom.appendChild(object.dom.browserDiv);
	object.dom.browserDiv.model = object;
	
	// If we are displaying in an iframe for demo purposes
	if (object._protected.isIFrame === true) {
		object.dom.contentWindow = document.createElement('iframe');
	} else {
		object.dom.contentWindow = document.createElement('webview');
	}
	$ui.addClass(object.dom.contentWindow, 'window');
	object.dom.browserDiv.appendChild(object.dom.contentWindow);
	
	// Src Property
	object._protected.src = object.src;
	Object.defineProperty(object, 'src', {
		get: function() {return this._protected.src;},
		set: function(value) {
			if (value == this._protected.src) return;
			this._protected.src = value;
			this._setSrc(value);
		},
		configurable: false}
	);
	
	// Internal function to set the url
	object._setSrc = function(value) {
		this.dom.input.value = value;
		this._onstartload();
		this.dom.contentWindow.src = value;
	}.$bind(object);
	
	// Triggered when content is starting to load
	object._onstartload = function() {
		this.dom.spinner.style.display = '';
		this._refreshBtn.setStyle('stop');
		$ui.removeClass(this.dom.icon,'page');	
		if (this._protected.isIFrame == false) {
			if (event != undefined && event.isTopLevel == true) {
				this.dom.input.value = event.url;
				this._protected.src = event.url;
			}
		}
	}.$bind(object);
	
	// Triggered when content is fully loaded
	object._onload = function() {
		this.dom.spinner.style.display = 'none';
		$ui.addClass(this.dom.icon,'page');
		this._refreshBtn.setStyle('refresh');	
	}.$bind(object);
	
	// Handle clearing the UI before the pop animation
	object._onbeforepop = function() {
		this.dom.contentWindow.style.display = 'none';
	}.$bind(object);
	
	// Handle loading on show
	object._onshow = function() {
		// Wait for show to load the URL
		if (this.src) {
			this._setSrc(this.src);
		}
		this.dom.contentWindow.style.visibility = 'visible';
		// Need to add detection here. If added to the iframe before inserted into
		// the DOM, it will fire twice
		if (this._protected.isIFrame === true) {
			this.dom.contentWindow.onload = object._onload;
		} else {
			this.dom.contentWindow.addEventListener("loadstart", this._onstartload);
       		this.dom.contentWindow.addEventListener("loadstop", this._onload);
			// Hack for scaling webviews in a Chrome App.. Scaling issue
			this.dom.contentWindow.style.width = this.dom.browserDiv.offsetWidth + 'px';
			this.dom.contentWindow.style.height = this.dom.browserDiv.offsetHeight + 'px';
		}
	}.$bind(object);

	// Private function to do cleanup
	object._ondestroy = function() {
		if (this._protected.isIFrame == false) {
			this.dom.contentWindow.removeEventListener("loadstart", this._onstartload);
       		this.dom.contentWindow.removeEventListener("loadstop", this._onload);
		}
 	}.$bind(object);
	
	// Handle the sizing of the screen for the <webview>
	object._onresize = function() {
		// Hack for webviews in Chrome App... Scaling issue
		if (this._protected.isIFrame == false) {
			var webview = this.dom.contentWindow;
			webview.style.display = 'none';
			setTimeout(function() {webview.style.display = 'block';},500);
		}
	}.$bind(object);
	
	return object.dom;
}
function $ui_BrowserButton(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom,'button');
	
	// Set our style
	if (object.style) {
		$ui.addClass(object.dom, object.style);
	}
	
	// Handle the click
	object.dom.onclick = function() {
		if (this.model.enabled === false) return;
		$ui.playTouchSound();
		if (this.model.onclick) {
			this.model.onclick();
		}
	}
	object.dom.ontouchstart = function() {
		if (this.model.enabled === false) return;
		$ui.addClass(this,'theme-brand-background-color');
	}
	object.dom.ontouchend = function() {
		if (this.model.enabled === false) return;
		$ui.removeClass(this,'theme-brand-background-color');
	}
	object.dom.ontouchcancel = object.dom.ontouchend;
	if (!$ui.isMobileDevice()) {
		object.dom.onmousedown = object.dom.ontouchstart;
		object.dom.onmouseup = object.dom.ontouchend;
	}

	// Public function to set the style of the button
	object.setStyle = function(value) {
		if (value == this.style) return;
		if (this.style != undefined) {
			$ui.removeClass(this.dom,this.style);
		}
		$ui.addClass(this.dom, value);
		this.style = value;
	}.$bind(object);
	
	return object.dom;
}
/**
 * The color list item type is used with the {@link $ui.List} component.  
 * <br><br><b>Sample Declaration</b>
 * <pre>
 * {
 *   color: '#FFFFFF',
 *}
 * </pre>
 * @namespace ColorListItem
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {string} color - A valid CSS color value
 * @property {boolean} [selected=false] - Whether or not this is a selected color
 */
function $ui_ColorListItem(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom, 'ui-color-list-item');
	
	// color Property
	if (object.color != undefined) {
		object.dom.style.backgroundColor = object.color;	
	} 
	object._protected.color = object.color;
	Object.defineProperty(object, 'color', {
		get: function() {return this._protected.color;},
		set: function(value) {
			if (value == this._protected.color) return;
			this._protected.color = value;
			if (color == undefined) {
				this.dom.style.backgroundColor = '';
			} else {
				this.dom.style.backgroundColor = value;
			}
		},
		configurable: false}
	);
	
	// selected Property
	if (object.selected == true) {
		$ui.addClass(object.dom,'selected');
	} else {
		object.selected = false;
	}
	object._protected.selected = object.selected;
	Object.defineProperty(object, 'selected', {
		get: function() {return this._protected.selected;},
		set: function(value) {
			if (value == this._protected.selected) return;
			if (value == undefined) value = false;
			this._protected.selected = value;
			if (value == false) {
				$ui.removeClass(object.dom,'selected');
			} else {
				$ui.addClass(object.dom,'selected');
			}
		},
		configurable: false}
	);

	// Pass the onclick back to the list
	object.dom.addEventListener('click', function() {
		var i,
			item;
		for (i= 0; i< this.model.parent.items.length; i++) {
			item = this.model.parent.items[i];
			if (item != this.model) {
				item.selected = false;
			}
		}
		this.model.selected = true;
		if (this.model.parent.onaction) {
			var event = new ListEvent(this.model, $ui.ColorListItem.ColorListEvent.ONCLICK);
			this.model.parent._onaction(this.model, event);
		}
		$ui.playTouchSound();
	},false);

	return object.dom;
}
/**
 * The DialPad object a phone dialer keypad component<br><br>
 * <b>Sample Declaration</b><br>
 * <pre>
 * {
 *    component: $ui.DialPad,
 *    onkeypadpress: function(key) {
 *       console.log(key);
 *    }
 * }
 * @namespace DialPad
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {KeyPadPressEvent} [onkeypadpress] - The event which will fire when a button on the keypad is pressed
 * @property {$ui.DialPadNumber} number - Class holding the number which has been entered into the keypad.
 */
function $ui_DialPad(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom, 'ui-dial-pad');

	if (!object.number) {
		object.number = {};
	}

	object.dom.number = new $ui_DialPadNumber(object.number, screen);
	object.dom.appendChild(object.dom.number);

	object._buttons = [{
		caption: '1',
	}, {
		caption: '2',
		letters: 'ABC'
	}, {
		caption: '3',
		letters: 'DEF'
	}, {
		caption: '4',
		letters: 'GHI'
	}, {
		caption: '5',
		letters: 'JKL'
	}, {
		caption: '6',
		letters: 'MNO'
	}, {
		caption: '7',
		letters: 'PQRS'
	}, {
		caption: '8',
		letters: 'TUV'
	}, {
		caption: '9',
		letters: 'WXYZ'
	}, {
		caption: '*',
		center: true
	}, {
		caption: '0',
		letters: '+'
	}, {
		caption: '#',
		center: true
	}];

	var i,
		button;
	for (i = 0; i < object._buttons.length; i++) {
		button = object._buttons[i];
		button.parent = object;
		dom = new $ui_DialPadButton(button, screen);
		object.dom.appendChild(dom);
	}
	
	// Create the dial button
	object.dom.dialButton = new $ui_DialPadButton({
			parent: object,
			letters: 'Call',
			dial: true
		}, screen);
	object.dom.appendChild(object.dom.dialButton);

	return object.dom;
}

/**
 * @namespace DialPadKey
 * @memberof $ui
 * @property {string} caption - The number or letter on the button
 * @property {string} [letters] - Optional secondary letters for the button such as "ABC"
 */

/**
 * The {@link $ui.DialPad} <b>onkeypadpress</b> event will fire when the user clicks a keypad button
 * @callback KeyPadPressEvent
 * @param {$ui.DialPadKey} key - The key which was pressed
 */
/**
 * A button that will appear in the phone dialer.
 * @namespace DialPadButton
 * @memberof $ui
 * @property {string} caption - The main caption to display for the button.
 * @property {string} letters - The letter equivalents of the button.
 * @property {boolean} [center] - Flag indicating if the control should be centered.
 * @property {boolean} [dial] - Flag indicating if this is a dial button - it will appear differently.
 */
function $ui_DialPadButton(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom, 'button theme-text-color');
	object._private = {};

	object._private.playTouchSound = function() {
		switch (this.caption) {
			case '0':
				$system.audio.playSoundEffect($system.SoundEffect.TONE0);
				break;
			case '1':
				$system.audio.playSoundEffect($system.SoundEffect.TONE1);
				break;
			case '2':
				$system.audio.playSoundEffect($system.SoundEffect.TONE2);
				break;
			case '3':
				$system.audio.playSoundEffect($system.SoundEffect.TONE3);
				break;
			case '4':
				$system.audio.playSoundEffect($system.SoundEffect.TONE4);
				break;
			case '5':
				$system.audio.playSoundEffect($system.SoundEffect.TONE5);
				break;
			case '6':
				$system.audio.playSoundEffect($system.SoundEffect.TONE6);
				break;
			case '7':
				$system.audio.playSoundEffect($system.SoundEffect.TONE7);
				break;
			case '8':
				$system.audio.playSoundEffect($system.SoundEffect.TONE8);
				break;
			case '9':
				$system.audio.playSoundEffect($system.SoundEffect.TONE9);
				break;
			case '#':
				$system.audio.playSoundEffect($system.SoundEffect.TONE_POUND);
				break;
			case '*':
				$system.audio.playSoundEffect($system.SoundEffect.TONE_ASTERIK);
				break;
		}
	}.$bind(object);

	// Create the number
	if (!object.dial) {
		object.dom.captionDiv = document.createElement('div');
		$ui.addClass(object.dom.captionDiv, 'caption');
		object.dom.captionDiv.textContent = object.caption;
		object.dom.appendChild(object.dom.captionDiv);

		// See if we need to center the number
		if (object.center === true) {
			$ui.addClass(object.dom.captionDiv, 'centered');
		}

		// Create extra letters
		object.dom.letters = document.createElement('div');
		$ui.addClass(object.dom.letters, 'letters');
		object.dom.appendChild(object.dom.letters);
		if (object.letters) {
			object.dom.letters.textContent = object.letters;
		}
		object.dom.ontouchstart = function() {
			$ui.addClass(this,'theme-brand-background-color');
			$ui.addClass(this, 'theme-highlight-text-color');
			this._private.playTouchSound();
		}.$bind(object);
		object.dom.ontouchend = function() {
			$ui.removeClass(this,'theme-brand-background-color');
			$ui.removeClass(this, 'theme-highlight-text-color');
		}
	} else {
		// Create extra letters
		object.dom.letters = document.createElement('div');
		$ui.addClass(object.dom.letters, 'letters');
		object.dom.appendChild(object.dom.letters);
		object.dom.letters.textContent = object.letters;
		
		// This is a dial button.
		$ui.addClass(object.dom, 'dial theme-call-button');
		object.dom.ontouchstart = function() {
			this.style.opacity = 0.7;
		};
		object.dom.ontouchend = function() {
			this.style.opacity = 1;
		};
	}
	// Set our touch interaction
	object.dom.ontouchcancel = object.dom.ontouchend;
	if (!$ui.isMobileDevice()) {
		object.dom.onmousedown = object.dom.ontouchstart;
		object.dom.onmouseup = object.dom.ontouchend;
		object.dom.onmouseleave = object.dom.ontouchend;
	}

	// Handle the click event
	object.dom.onclick = function() {
		var key = {
			caption: this.model.caption,
			letters: this.model.letters,
			dial: this.model.dial
		};
		if ((this.model.parent != undefined) && (this.model.parent.onkeypadpress)) {
			this.model.parent.onkeypadpress(key);
		}
	}

	return object.dom;
}
/**
 * This class holds the number being dialled by the user. It can also create a pretty version of it.
 * @namespace DialPadNumber
 * @memberof $ui
 * @property {string} number - The number that has been entered into the pad.
 * @property {string} prettyNumber - A US+Canada friendly formatting of the number.
 * @property {$ui.DialPadNumber.DialPadNumberChangedEvent} onnumberchanged - Event triggered when the number is changed.
 */
/**
 * This callback is used to see when the user as changed their number.
 * @callback DialPadNumberChangedEvent
 * @memberof $ui.DialPadNumber
 * @property {string} number - The number that has been entered.
 * @property {string} prettyNumber - A pretty version of the same number.
 */
function $ui_DialPadNumber(object, screen) {
    $ui_CoreComponent.call(this, object, screen);
    $ui.addClass(object.dom, 'ui-dial-pad-number theme-dark-background-color');

    function pretty(number) {
        if (number.length > 13) {
            return "... " + number.substring(number.length - 13);
        }
        if (number.length == 11) {
            return number.substring(0, 1) + " " + pretty(number.substring(1));
        }
        if (number.length == 10) {
            return "(" + number.substring(0, 3) + ") " + pretty(number.substring(3));
        }
        if (number.length == 7) {
            return number.substring(0, 3) + "-" + number.substring(3);
        }
        return number;
    }

    var touchStart = function() {
        this.dom.del.style.opacity = "0.7";
    }.$bind(object);

    var touchEnd = function() {
        if (this.number.length > 0) {
            this.dom.del.style.opacity = "1";
        } else {
            this.dom.del.style.opacity = "0.7";
        }
    }.$bind(object);

    function setEvents(o) {
        o.ontouchstart = touchStart;
        o.ontouchend = touchEnd;
        o.ontouchcancel = touchEnd;
        if (!$ui.isMobileDevice()) {
            o.onmousedown = touchStart;
            o.onmouseup = touchEnd;
            o.onmouseleave = touchEnd;
        }
    }

    object._private = {};
    object._private.number = "";
    object._private.prettyNumber = "";

    object.dom.del = document.createElement("div");
    $ui.addClass(object.dom.del, 'delete');
    object.dom.appendChild(object.dom.del);

    object.dom.number = document.createElement("div");
    $ui.addClass(object.dom.number, 'number theme-highlight-text-color');
    object.dom.appendChild(object.dom.number);

    setEvents(object.dom.del);

    object.dom.del.onclick = function(event) {
        if (this.number.length != 0 && this.ondeleteclick) {
            this.ondeleteclick(event);
        }
    }.$bind(object);

    Object.defineProperty(object, "number", {
        get: function() {
            return this._private.number;
        }.$bind(object),
        set: function(number) {
            var length = number.length;
            if (length == 0) {
                this.dom.del.style.opacity = 0.7;
            } else {
                this.dom.del.style.opacity = 1;
            }
            this._private.prettyNumber = pretty(number);
            this.dom.number.textContent = this._private.prettyNumber;
            this._private.number = number;
            if (this._private.lastNumber != number) {
                this._private.lastNumber = number;
                if (this.onnumberchanged) {
                    this.onnumberchanged({ number: number, prettyNumber: this._private.prettyNumber });
                }
            }
        }.$bind(object)
    });

    Object.defineProperty(object, "prettyNumber", {
        get: function() {
            return this._private.prettyNumber;
        }
    });

    /**
     * Append a digit (or any string really) to the number.
     * @function appendToNumber
     * @memberof $ui.DialPadNumber#
     * @param {string} digit - The digit (or any string) to append.
     */
    object.appendToNumber = function(digit) {
        this.number = this._private.number + digit;
    }.$bind(object);

    /**
     * Delete the rightmost character from the number. Note that calling
     * delete from within 200ms of the last call will delete the whole number.
     * @function deleteFromNumber
     * @memberof $ui.DialPadNumber#
     */
    object.deleteFromNumber = function() {
        var now = new Date().getTime();
        if (this._private.lastDelete && now - this._private.lastDelete < 200) {
            this.number = "";
        } else {
            var current = this.number;
            if (current && current.length > 0) {
                this.number = current.substring(0, current.length - 1);
            }
        }
        this._private.lastDelete = now;
    }.$bind(object);

    return object.dom;
}
/**
 * The Map control represents the map window including both the chrome and the viewer.<br><br>
 * This object will create an iframe area while in demo mode. But when in PhoneGap it will create a child map view window that it will overlay on the screen<br><br>
 * <b>Sample Declaration</b><br>
 * <pre>
 * {
 *    component: $ui.Map,
 *    src: 'https://www.google.com/maps/embed?pb=!1m14!1m1'
 * }
 * @namespace Map
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {string} src - Populates the Google Maps URL for the control
 */
function $ui_Map(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom,'ui-map');
	
	// Check to see if we are in the emulator
	if ($system && (($system.config.isEmulator == true))) {
		object._protected.isIFrame = false;
	} else {
		object._protected.isIFrame = true;
	}
	
	// Create our map display area
	object.dom.mapDiv = document.createElement('div');
	$ui.addClass(object.dom.mapDiv,'mapDiv theme-screen-background-color');
	object.dom.appendChild(object.dom.mapDiv);
	
	// Create the contentWindow
	if (object._protected.isIFrame == true) {
		object.dom.contentWindow = document.createElement('iframe');
		$ui.addClass(object.dom.contentWindow, 'window');
	} else {
		object.dom.contentWindow = document.createElement('webview');
		$ui.addClass(object.dom.contentWindow, 'webview');
	}
	object.dom.mapDiv.appendChild(object.dom.contentWindow);
	
	// Handle loading on show
	object._onshow = function() {
		// Wait for show to load the URL
		if (this.src) {
			this.dom.contentWindow.src = this.src;
		}
		this.dom.contentWindow.style.display = 'block';
		// Hack for scaling webviews in a Chrome App.. Scaling issue
		if (this._protected.isIFrame == false) {
			this.dom.contentWindow.style.width = this.dom.mapDiv.offsetWidth + 'px';
			this.dom.contentWindow.style.height = (this.dom.mapDiv.offsetHeight + 7) + 'px'; // For some reason the calculation is off by 7
		}
	}.$bind(object);

	// Handle the sizing of the screen for the <webview>
	object._onresize = function() {
		// Hack for webviews in Chrome App... Scaling issue
		if (this._protected.isIFrame == false) {
			var webview = this.dom.contentWindow;
			webview.style.display = 'none';
			setTimeout(function() {webview.style.display = 'block';},500);
		}
	}.$bind(object);
	return object.dom;
}
/**
 * The Media Player control provides the user interface to the audio services of Brainiac. This control will fill the entire available space provided by its parent containing control.<br><br>
 * <b>Sample Declaration</b><br>
 * <pre>
 * {
 *    component: $ui.MediaPlayer,
 *    album: 'License To Ill',
 *    song: 'So What Cha Want',
 *    artist: 'Beastie Boys',
 *    coverArt: 'img/foo.png',
 *    duration: 217,
 *    onplay: function() {
 *       // Do something
 *    }
 * }
 * @namespace MediaPlayer
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {string} [album] - The name of the album of the current playing/paused song
 * @property {string} [song] - The name of the current playing/paused song
 * @property {string} [artist] - The name of the artist for the current playing/paused song
 * @property {string} [coverArt] - Path to the cover/album art for the current playing/paused song
 * @property {number} [duration] - The duration of the current playing/paused song in <b>seconds</b>
 * @property {boolean} [paused=false] - Optional property specifying if the player is paused or not
 * @property {GenericEvent} [onplay] - This event will fire when the user presses play
 * @property {GenericEvent} [onpause] - This event will fire when the user presses pause
 * @property {GenericEvent} [onmenuclick] - This event will fire when the user presses the menu
 * @property {GenericEvent} [onskipforward] - This event will fire when the user presses next
 * @property {GenericEvent} [onskipback] - This event will fire when the user presses previous
 */
function $ui_MediaPlayer(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom,'ui-media-player');
	
	if ($ui.theme.inHeadUnit == true) {
		$ui.addClass(object.dom,'in-head-unit');
	}
	
	// Set our initial play state
	if (object.paused == undefined) {
		object.paused = false;
	}
	
	// Create our cover art display area
	object.dom.coverArt = document.createElement('div');
	$ui.addClass(object.dom.coverArt,'cover-art');
	object.dom.appendChild(object.dom.coverArt);
	object.dom.coverArt.loader = new Image();
	object.dom.coverArt.loader.model = object;
	object.dom.coverArt.loader.onload = function() {
		this.model.dom.coverArt.style.backgroundImage = 'url("'+this.model.coverArt+'")';
		this.model.dom.coverArt.style.opacity = '0.3';
	}
	
	// Create our controls area
	object.dom.controls = document.createElement('div');
	$ui.addClass(object.dom.controls, 'controls theme-text-color');
	object.dom.appendChild(object.dom.controls);
	object.dom.artist = document.createElement('div');
	$ui.addClass(object.dom.artist,'artist');
	object.dom.controls.appendChild(object.dom.artist);
	object.dom.song = document.createElement('div');
	$ui.addClass(object.dom.song,'song');
	object.dom.controls.appendChild(object.dom.song);
	object.dom.album = document.createElement('div');
	$ui.addClass(object.dom.album,'album');
	object.dom.controls.appendChild(object.dom.album);
	
	// Create our player buttons
	object.dom.playbox = document.createElement('div');
	$ui.addClass(object.dom.playbox, 'playbox');
	object.dom.controls.appendChild(object.dom.playbox);
	object.dom.skipBack = document.createElement('div');
	object.dom.skipBack.model = object;
	$ui.addClass(object.dom.skipBack,'button');
	$ui.addClass(object.dom.skipBack,'skip-back');
	object.dom.playbox.appendChild(object.dom.skipBack);
	object.dom.skipForward = document.createElement('div');
	object.dom.skipForward.model = object;
	$ui.addClass(object.dom.skipForward,'button');
	$ui.addClass(object.dom.skipForward,'skip-forward');
	object.dom.playbox.appendChild(object.dom.skipForward);
	object.dom.play = document.createElement('div');
	object.dom.play.model = object;
	$ui.addClass(object.dom.play,'button');
	$ui.addClass(object.dom.play,'play');
	object.dom.playbox.appendChild(object.dom.play);
	object.dom.play.onclick = function() {
		$ui.playTouchSound();
		if (this.model.paused == true) {
			this.model.play();
		} else {
			this.model.pause();
		}
	}
	object.dom.play.ontouchstart = function() {
		this.style.opacity = '0.7';
	}
	object.dom.play.ontouchend = function() {
		this.style.opacity = '1.0';
	}
	object.dom.play.ontouchcancel = object.dom.ontouchend;

	object.dom.skipBack.ontouchstart = object.dom.play.ontouchstart;
	object.dom.skipBack.ontouchend = object.dom.play.ontouchend;
	object.dom.skipBack.ontouchcancel = object.dom.play.ontouchend;
	object.dom.skipBack.onclick = function() {
		$ui.playTouchSound();
		this.model.skipBack();
	}

	object.dom.skipForward.ontouchstart = object.dom.play.ontouchstart;
	object.dom.skipForward.ontouchend = object.dom.play.ontouchend;
	object.dom.skipForward.ontouchcancel = object.dom.play.ontouchend;
	object.dom.skipForward.onclick = function() {
		$ui.playTouchSound();
		this.model.skipForward();
	}
	
	if (!$ui.isMobileDevice()) {
		object.dom.play.onmousedown = object.dom.play.ontouchstart;
		object.dom.play.onmouseup = object.dom.play.ontouchend;
		object.dom.play.onmouseleave = object.dom.play.ontouchend;
	}
	
	// Create our menu
	object.dom.menu = document.createElement('div');
	object.dom.menu.model = object;
	$ui.addClass(object.dom.menu,'menu theme-border-color');
	object.dom.appendChild(object.dom.menu);
	object.dom.menu.onclick = function() {
		$ui.playTouchSound();
		if (this.model.onmenuclick) {
			this.model.onmenuclick();
		}
	}
	object.dom.menu.ontouchstart = function() {
		$ui.addClass(this, 'theme-brand-background-color');
	}
	object.dom.menu.ontouchend = function() {
		$ui.removeClass(this, 'theme-brand-background-color');
	}
	object.dom.menu.ontouchcancel = object.dom.ontouchend;
	if (!$ui.isMobileDevice()) {
		object.dom.menu.onmousedown = object.dom.menu.ontouchstart;
		object.dom.menu.onmouseup = object.dom.menu.ontouchend;
		object.dom.menu.onmouseleave = object.dom.menu.ontouchend;
	}
	
	// Create our text buttons
	object.dom.textButtonBox = document.createElement('div');
	$ui.addClass(object.dom.textButtonBox, 'textButtonBox');
	object.dom.appendChild(object.dom.textButtonBox);
	object.dom.buttonRepeat = document.createElement('div');
	object.dom.buttonRepeat.model = object;
	$ui.addClass(object.dom.buttonRepeat, 'text-button theme-text-color');
	$ui.addClass(object.dom.buttonRepeat, 'left');
	object.dom.buttonRepeat.textContent = 'Repeat Off';
	object.dom.textButtonBox.appendChild(object.dom.buttonRepeat);
	object.dom.buttonSource = document.createElement('div');
	$ui.addClass(object.dom.buttonSource, 'text-button theme-text-color');
	$ui.addClass(object.dom.buttonSource, 'center');
	object.dom.buttonSource.textContent = 'Source';
	object.dom.textButtonBox.appendChild(object.dom.buttonSource);
	object.dom.buttonShuffle = document.createElement('div');
	object.dom.buttonShuffle.model = object;
	$ui.addClass(object.dom.buttonShuffle, 'text-button theme-text-color');
	$ui.addClass(object.dom.buttonShuffle, 'right');
	object.dom.buttonShuffle.textContent = 'Shuffle Off';
	object.dom.textButtonBox.appendChild(object.dom.buttonShuffle);
	
	object.dom.buttonShuffle.ontouchstart = object.dom.play.ontouchstart;
	object.dom.buttonShuffle.ontouchend = object.dom.play.ontouchend;
	object.dom.buttonShuffle.ontouchcancel = object.dom.play.ontouchcancel;
	object.dom.buttonShuffle.onclick = function() {
		$ui.playTouchSound();
		this.model.toggleShuffle();
	};
	
	object.dom.buttonRepeat.ontouchstart = object.dom.play.ontouchstart;
	object.dom.buttonRepeat.ontouchend = object.dom.play.ontouchend;
	object.dom.buttonRepeat.ontouchcancel = object.dom.play.ontouchcancel;
	object.dom.buttonRepeat.onclick = function() {
		$ui.playTouchSound();
		this.model.toggleRepeat();
	};

	/**
	 * Sets the <b>repeat</b> property of the control.
	 */
	object.setRepeat = function(repeat) {
		if (repeat==0) {
			this.dom.buttonRepeat.textContent = 'Repeat Off';
		} else if (repeat == 1) {
			this.dom.buttonRepeat.textContent = 'Repeat One';
		} else if (repeat == 2) {
			this.dom.buttonRepeat.textContent = 'Repeat All';
		}
	}.$bind(object);
	
	/**
	 * Sets the shuffle property of the control.
	 */
	object.setShuffle = function(shuffle) {
		this.dom.buttonShuffle.textContent = shuffle ? "Shuffle On" : "Shuffle Off";
	}.$bind(object);
	
	/**
	* Sets the <b>album</b> property of the control
	* @function setAlbum
	* @memberof $ui.MediaPlayer
	* @param {string} value - The new property value
	*/
	object.setAlbum = function(value) {
		this.album = value;
		// Now load the new image
		if (value != undefined) {
			this.dom.album.textContent = value;
		} else {
			this.dom.album.textContent = '';
		}
	}.$bind(object);
	
	/**
	* Sets the <b>song</b> property of the control
	* @function setSong
	* @memberof $ui.MediaPlayer
	* @param {string} value - The new property value
	*/
	object.setSong = function(value) {
		this.song = value;
		// Now load the new image
		if (value != undefined) {
			this.dom.song.textContent = value;
		} else {
			this.dom.song.textContent = '';
		}
	}.$bind(object);
	
	/**
	* Sets the <b>artist</b> property of the control
	* @function setArtist
	* @memberof $ui.MediaPlayer
	* @param {string} value - The new property value
	*/
	object.setArtist = function(value) {
		this.artist = value;
		// Now load the new image
		if (value != undefined) {
			this.dom.artist.textContent = value;
		} else {
			this.dom.artist.textContent = '';
		}
	}.$bind(object);
	
	/**
	* Sets the <b>coverArt</b> property of the control
	* @function setCoverArt
	* @memberof $ui.MediaPlayer
	* @param {string} value - The new property value
	*/
	object.setCoverArt = function(value) {
		this.coverArt = value;
		this.dom.coverArt.style.opacity = '0';
		// Now load the new image
		if (value != undefined) {
			this.dom.coverArt.loader.src = value;
		}
	}.$bind(object);
	
	/**
	* Sets the <b>duration</b> property of the control
	* @function setDuration
	* @memberof $ui.MediaPlayer
	* @param {number} value - The new property value
	*/
	object.setDuration = function(value) {
		this.duration = value;
		// Now load the new image
		if (value != undefined) {
			// Do something
		}
	}.$bind(object);
	
	// Private function to render the play state of the control
	object._renderPlayState = function(value) {
		if (this.paused == true) {
			$ui.removeClass(this.dom.play,'pause');
		} else {
			$ui.addClass(this.dom.play,'pause');
		}
	}.$bind(object);
	
	/**
	* Play the current song
	* @function play
	* @memberof $ui.MediaPlayer
	*/
	object.play = function(value) {
		if (this.paused == false) return;
		this.paused = false;
		this._renderPlayState();
		if (this.onplay) {
			this.onplay();
		}
	}.$bind(object);

	/**
	 * Attempt to skip back.
	 */
	object.skipBack = function() {
		if (this.onskipback) {
			this.onskipback();
		}
	}.$bind(object);
	
	object.setPaused = function(val) {
		if (this.paused == val) {
			return;
		}
		this.paused = val;
		this._renderPlayState();
		
	}.$bind(object);

	/**
	 * User wants to skip forward.
	 */
	object.skipForward = function() {
		if (this.onskipforward) {
			this.onskipforward();
		}
	}.$bind(object);
	
	object.toggleRepeat = function() {
		if (this.ontogglerepeat) {
			this.ontogglerepeat();
		}
	}.$bind(object);
	
	object.toggleShuffle = function() {
		if (this.ontoggleshuffle) {
			this.ontoggleshuffle();
		}
	}.$bind(object);
	
	/**
	* Pause the current song
	* @function pause
	* @memberof $ui.MediaPlayer
	*/
	object.pause = function(value) {
		if (this.paused == true) return;
		this.paused = true;
		this._renderPlayState();
		if (this.onpause) {
			this.onpause();
		}
	}.$bind(object);
	
	// Private function to handle provider updates
	object._providerUpdate = function(value) {
		if (value == undefined) {
			value = {}
		} 
		this.setCoverArt(value.coverArt);
		this.setArtist(value.artist);
		this.setSong(value.song);
		this.setAlbum(value.album);
		this.paused = value.paused;
		this._renderPlayState();
	}.$bind(object);
	
	// Load our control if no provider is connected
	if (object.provider == undefined) {
		object._providerUpdate(object)
	}
	
	return object.dom;
}

/**
 * The MenuItem control represents a menu option in a menu for a {@link $ui.OnlineScreen}.  It can only be used in a menu and cannot be instantiated on its own.
 * @namespace
 * @name MenuItem
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {string} caption - The Caption to display on this menu item
 * @property {boolean} [selected=false] - Set to <b>true</b> to make this menu item the selected item in the menu.  Only one menu item can be selected at once.  When a menu renders it will select the first menu item that has selected set to true and ignore the rest.
 * @property {GenericEvent} [onclick] - Event that will fire when the user clicks the menu item
 */
function $ui_MenuItem(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	if (object.inMenu != true) {
		console.log('ERROR: A "MenuItem" can only be created as part of a menu in an "OnlineScreen"');
		return;
	}
	$ui.addClass(object.dom,'ui-menu-item');
	
	// Selected property
	if (object.selected == true) {
		$ui.addClass(object.dom,'selected');
	} else {
		object.selected = false;
	}
	object._protected.selected = object.selected;
	Object.defineProperty(object, 'selected', {
		get: function() {return this._protected.selected;},
		set: function(value) {
			if (value == this._protected.selected) return;
			this._protected.selected = value;
			if (value == true) {
				$ui.addClass(object.dom,'selected');
			} else {
				$ui.removeClass(object.dom,'selected');
			}
		},
		configurable: false}
	);
	
	// Caption Property
	if (object.caption) {
		object.dom.textContent = object.caption;
	}
	object._protected.caption = object.caption;
	Object.defineProperty(object, 'caption', {
		get: function() {return this._protected.caption;},
		set: function(value) {
			if (value == this._protected.caption) return;
			this._protected.caption = value;
			this.dom.textContent = value;
		},
		configurable: false}
	);
	
	// Handle the click
	object._doClick = function() {
		if (this.selected == true) return;
		this.selected = true;
		// Un-select the other items
		var i,
			item,
			menu = this.parent.menu;
		for (i = 0; i < menu.length; i++) {
			item = menu[i];
			if (item != this) {
				item.selected = false;
			}
		}
		// Fire our onclick
		if (this.onclick) {
			this.onclick();
		}
	}.$bind(object);
	
	if ($ui.isMobileDevice()) {
		object.dom.ontouchend = object._doClick;
	} else {
		object.dom.onclick = object._doClick;
	}

	
	// Add our mouse handling
	object.dom.onmouseenter = function() {
		this.style.color = '#D94646'; // Hardcoded for our website
	}
	object.dom.onmouseleave = function() {
		this.style.color = '';
	}
	
	return object.dom;
}
/**
 * The OnlineScreen represents a screen that will be hosted on the web site providing both desktop and mobile viewing
 * @namespace OnlineScreen
 * @memberof $ui
 * @extends $ui.CoreScreen
 * @property {$ui.MenuItem[]} [menu] - Optional list of menu items to appear in the screen
 * @property {$ui.CoreComponent[]} [content] - Content to display in the screen
 * @property {GenericEvent} [onlogoclick] - Event that fires when a user clicks the titlebar logo
 */
function $ui_OnlineScreen(object, data) {
	$ui_CoreScreen.call(this, object, data);
	if (object) {
		$ui.addClass(object.dom,'ui-online-screen');

		object._protected.expanded = false;

		// Create our title bar
		object.dom.titleBar = document.createElement('div');
		$ui.addClass(object.dom.titleBar, 'title-bar');
		object.dom.appendChild(object.dom.titleBar);
		
		// Create our menu 
		object.dom.menu = document.createElement('div');
		$ui.addClass(object.dom.menu, 'menu');
		object.dom.titleBar.appendChild(object.dom.menu);
		
		// create our logo click area
		object.dom.logoTarget = document.createElement('div');
		object.dom.logoTarget.model = object;
		$ui.addClass(object.dom.logoTarget, 'logo-target');
		object.dom.menu.appendChild(object.dom.logoTarget);
		object.dom.logoTarget.onclick = function() {
			if (this.model.onlogoclick) {
				this.model.onlogoclick();
			}
		};
		
		// Create our inner menu 
		object.dom.innerMenu = document.createElement('div');
		$ui.addClass(object.dom.innerMenu, 'inner');
		object.dom.menu.appendChild(object.dom.innerMenu);
		
		// Create the hamburger
		object.dom.hamburger = document.createElement('div');
		object.dom.hamburger.model = object;
		$ui.addClass(object.dom.hamburger, 'hamburger');
		object.dom.menu.appendChild(object.dom.hamburger);
		
		// Opens up the hamburger menu
		object._openHamburger = function(event) {
			if (this._protected.expanded == true) return;
			this._protected.expanded = true;
			this.dom.innerMenu.style.display = 'block';
			event.stopPropagation();
			if ($ui.isMobileDevice()) {
				document.addEventListener('touchend',this._cancelOpen);
			} else {
				document.addEventListener('click',this._cancelOpen);
			}
		}.$bind(object);
		
		if ($ui.isMobileDevice()) {
			object.dom.hamburger.ontouchend = object._openHamburger;
		} else {
			object.dom.hamburger.onclick = object._openHamburger;
		}
		
		// Create the login/logout button
		object.dom.login = document.createElement('div');
		$ui.addClass(object.dom.login, 'login');
		object.dom.menu.appendChild(object.dom.login);
		object.dom.login.textContent = 'Log in / Setup';
		object.dom.login.style.backgroundColor = $ui.theme.color;
		
		// Create our content div for the controls
		object.dom.contentDiv = document.createElement('div');
		$ui.addClass(object.dom.contentDiv, 'inner');
		object.dom.appendChild(object.dom.contentDiv);
		
		// Title Bar property
		object._protected.titleBar = object.titleBar;
		Object.defineProperty(object, 'titleBar', {
			get: function() {return this._protected.titleBar;},
			set: function() {
				console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','titleBar'));
			},
			configurable: false}
		);
		
		// Menu property
		if (object.menu == undefined) {
			object.menu = [];
		}
		object._protected.menu = object.menu;
		Object.defineProperty(object, 'menu', {
			get: function() {return this._protected.menu;},
			set: function() {
				console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','menu'));
			},
			configurable: false}
		);
		
		// Content property
		if (object.content == undefined) {
			object.content = [];
		}
		object._protected.content = object.content;
		Object.defineProperty(object, 'content', {
			get: function() {return this._protected.content;},
			set: function() {
				console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','content'));
			},
			configurable: false}
		);
		
		// Cycle through menu
		if (object.menu) {
			var i,
				control,
				controlDom,
				selectedFound = false;
			for (i = 0; i < object.menu.length; i++) {
				control = object.menu[i];
				if (control.component != $ui.MenuItem) continue;
				control.inMenu = true;
				control.parent = object;
				if (control.selected == true) {
					if (selectedFound == true) {
						control.selected = false;
					} else {
						selectedFound = true;
					}
				}
				controlDom = $ui.createControl(control, object);
				if (controlDom) {
					object.dom.innerMenu.appendChild(controlDom);
				}
			}
		}
		
		// Cycle through content
		if (object.content) {
			var i,
				control,
				controlDom;
			for (i = 0; i < object.content.length; i++) {
				control = object.content[i];
				controlDom = $ui.createControl(control, object);
				if (controlDom) {
					object.dom.contentDiv.appendChild(controlDom);
				}
			}
		}
		
		// This will cancel the open of the hamburger menu
		object._cancelOpen = function() {
			this.dom.innerMenu.style.display = 'none';
			this._protected.expanded = false;
			if ($ui.isMobileDevice()) {
				document.removeEventListener('touchend',this._cancelOpen);
			} else {
				document.removeEventListener('click',this._cancelOpen);
			}
		}.$bind(object);
		
		return object.dom;
	}
}
/**
 * The phone log list item type is used with the {@link $ui.List} component and represents a call log entry. 
 * <br><br><b>Sample Declaration</b>
 * <pre>
 * {
 *   title: 'Susan',
 *   caption: '(555) 897-9876',
 *   style: $ui.PhoneLogListItem.PhoneLogStyle.MISSED
 * }
 * </pre>
 * @namespace PhoneLogListItem
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {string} title - Represents the main title to display
 * @property {$ui.PhoneLogListItem.PhoneLogStyle} [style] - The type of call that is in the list
 * @property {string} [caption] - Represents the main text to show in the list item
 */
function $ui_PhoneLogListItem(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom, 'ui-phone-log-list-item theme-screen-background-color theme-text-color theme-dark-border-color');
	if ($ui.theme.inHeadUnit == true) {
		$ui.addClass(object.dom, 'in-head-unit');
	}
	// See if the style is defined
	if (object.style == undefined) {
		object.style = $ui.PhoneLogListItem.INCOMING;
	}
	$ui.addClass(object.dom, object.style);
	
	// Details section
	object.dom.details = document.createElement('div');
	$ui.addClass(object.dom.details,'details');
	object.dom.appendChild(object.dom.details);
	
	// Title
	object.dom.titleArea = document.createElement('div');
	$ui.addClass(object.dom.titleArea,'title');
	object.dom.titleArea.textContent = object.title;
	object.dom.details.appendChild(object.dom.titleArea);
	if (object.style === $ui.PhoneLogListItem.MISSED) {
		$ui.addClass(object.dom.titleArea, 'theme-brand-text-color');
	}

	// Caption
	object.dom.captionDiv = document.createElement('div');
	$ui.addClass(object.dom.captionDiv,'caption theme-brand-text-color');
	object.dom.details.appendChild(object.dom.captionDiv);
	if (object.caption) {
		object.dom.captionDiv.textContent = object.caption;
	} else {
		$ui.addClass(object.dom, 'no-caption');
	}
	
	// Handle our touch events
	object.dom.ontouchstart = function() {
		$ui.removeClass(this, 'theme-screen-background-color');
		$ui.addClass(this, 'theme-brand-background-color');
	}
	object.dom.ontouchend = function() {
		$ui.removeClass(this, 'theme-brand-background-color');
		$ui.addClass(this, 'theme-screen-background-color');
	}
	object.dom.ontouchcancel = object.dom.ontouchend;
	if (!$ui.isMobileDevice()) {
		object.dom.onmousedown = object.dom.ontouchstart;
		object.dom.onmouseup = object.dom.ontouchend;
		object.dom.onmouseleave = object.dom.ontouchend;
	}

	// Pass the onclick back to the list
	object.dom.addEventListener('click', function() {
		if (this.model.parent.onaction == undefined) return;
		var event = new $ui_ListEvent(this.model, $ui.PhoneLogListItem.PhoneLogListEvent.ONCLICK);
		this.model.parent._onaction(this.model, event);
	},false);

	return object.dom;
}
/**
 * The PostListItem is used with {@link $ui.List} component and represents a post on a timeline.
 * <br><br><b>Sample Declaration</b>
 * <pre>
 * {
 *   user: 'brcewane',
 *   avatar: '../img/avatar.png',
 *   img: '../img/postImage.png',
 *   caption: 'This is a cool post',
 *   title: 'My Post',
 *   numLikes: 112,
 *   numComments: 12,
 *   liked: false,
 *   time: 'Thur Jan 17 2013 08:36:53 GMT-0500'
 * }
 * </pre>
 * @namespace PostListItem
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {string} user - The username who made the post
 * @property {string} [avatar] - The avatar to show for the user
 * @property {string} img - The image to view in the post
 * @property {string} [caption] - Represents the main text for the post
 * @property {string} [title] - The optional title for the post
 * @property {number} [numLikes=0] - The number of likes this post has recieved
 * @property {number} [numComments=0] - The number of comments this post has received
 * @property {boolean} [like=false] - Whether or not you have liked this post
 * @property {Date} [time] - The time that this post was made.  Must be a valid string representing a Date Time
 */
function $ui_PostListItem(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom, 'ui-post-list-item theme-post-control');
	
	// User details
	object.dom.user = document.createElement('div');
	$ui.addClass(object.dom.user, 'user-details');
	object.dom.appendChild(object.dom.user);
	
	// User name
	object.dom.userName = document.createElement('div');
	$ui.addClass(object.dom.userName, 'caption');
	object.dom.user.appendChild(object.dom.userName);
	
	// Avatar image
	object.dom.avatar = document.createElement('div');
	$ui.addClass(object.dom.avatar, 'avatar');
	object.dom.user.appendChild(object.dom.avatar);
	
	// Post Time
	object.dom.postTime = document.createElement('div');
	$ui.addClass(object.dom.postTime, 'time');
	object.dom.user.appendChild(object.dom.postTime);
	
	// Picture area
	object.dom.picture = document.createElement('img');
	$ui.addClass(object.dom.picture, 'picture');
	object.dom.appendChild(object.dom.picture);
	object.dom.picture.onload = function() {
		this.style.opacity = 1;
	}
	
	// Title area
	object.dom.titleDiv = document.createElement('div');
	$ui.addClass(object.dom.titleDiv, 'title');
	object.dom.appendChild(object.dom.titleDiv);
	
	// Main content area
	object.dom.contentDiv = document.createElement('div');
	$ui.addClass(object.dom.titleDiv, 'content');
	object.dom.appendChild(object.dom.contentDiv);
	
	// Add our separator
	object.dom.line = document.createElement('div');
	$ui.addClass(object.dom.line, 'line theme-brand-background-color');
	object.dom.appendChild(object.dom.line);
	
	// Add our buttons
	object.dom.buttons = document.createElement('div');
	$ui.addClass(object.dom.buttons, 'buttons');
	object.dom.appendChild(object.dom.buttons);
	
	// Like button
	object.dom.like = document.createElement('div');
	$ui.addClass(object.dom.like, 'button like');
	object.dom.buttons.appendChild(object.dom.like);

	// Comment button
	object.dom.comment = document.createElement('div');
	$ui.addClass(object.dom.comment, 'button comment');
	object.dom.buttons.appendChild(object.dom.comment);


	// img Property
	if (object.img != undefined) {
		object.dom.picture.src = object.img;
	}
	object._protected.img = object.img;
	Object.defineProperty(object, 'img', {
		get: function() {return this._protected.img;},
		set: function(value) {
			if (value == this._protected.img) return;
			this.dom.picture.style.opacity = 0;
			if (value != undefined) {
				this.dom.picture.src = value;
			} 
			this._protected.img = value;
		},
		configurable: false}
	);
	
	// avatar Property
	if (object.avatar != undefined) {
		object.dom.avatar.style.backgroundImage = 'url("'+ object.avatar + '")';
	}
	object._protected.avatar = object.avatar;
	Object.defineProperty(object, 'avatar', {
		get: function() {return this._protected.avatar;},
		set: function(value) {
			if (value == this._protected.avatar) return;
			if (value == undefined) {
				this.dom.avatar.style.backgroundImage = '';
			} else {
				this.dom.avatar.style.backgroundImage = 'url("'+ value + '")';
			}
			this._protected.avatar = value;
		},
		configurable: false}
	);
	
	// time Property
	if (object.time != undefined) {
		object.dom.postTime.textContent = $ui.calculateTimeInPast(new Date(), object.time);
	}
	object._protected.time = object.time;
	Object.defineProperty(object, 'time', {
		get: function() {return this._protected.time;},
		set: function(value) {
			if (value == this._protected.time) return;
			if (value == undefined) {
				this.dom.postTime.textContent = '?';
			} else {
				this.dom.postTime.textContent = $ui.calculateTimeInPast(new Date(), value);
			}
			this._protected.user = value;
		},
		configurable: false}
	);
	
	// user Property
	if (object.user != undefined) {
		object.dom.userName.textContent = object.user;
	}
	object._protected.user = object.user;
	Object.defineProperty(object, 'user', {
		get: function() {return this._protected.user;},
		set: function(value) {
			if (value == this._protected.user) return;
			if (value == undefined) {
				this.dom.userName.textContent = '';
			} else {
				this.dom.userName.textContent = value;
			}
			this._protected.user = value;
		},
		configurable: false}
	);
	
	// numLikes Property
	if (object.numLikes != undefined) {
		object.dom.like.textContent = object.numLikes;
	}
	object._protected.numLikes = object.numLikes;
	Object.defineProperty(object, 'numLikes', {
		get: function() {return this._protected.numLikes;},
		set: function(value) {
			if (value == this._protected.numLikes) return;
			if (value == undefined) {
				this.dom.like.textContent = '';
			} else {
				this.dom.like.textContent = value;
			}
			this._protected.numLikes = value;
		},
		configurable: false}
	);
	
	// numComments Property
	if (object.numLikes != undefined) {
		object.dom.comment.textContent = object.numComments;
	}
	object._protected.numComments = object.numComments;
	Object.defineProperty(object, 'numComments', {
		get: function() {return this._protected.numComments;},
		set: function(value) {
			if (value == this._protected.numComments) return;
			if (value == undefined) {
				this.dom.comment.textContent = '';
			} else {
				this.dom.comment.textContent = value;
			}
			this._protected.numComments = value;
		},
		configurable: false}
	);

	// title Property
	if (object.title != undefined) {
		object.dom.titleDiv.style.display = 'block';
		object.dom.titleDiv.textContent = object.title;
	}
	object._protected.title = object.title;
	Object.defineProperty(object, 'title', {
		get: function() {return this._protected.title;},
		set: function(value) {
			if (value == this._protected.title) return;
			this._protected.title = value;
			if (value == undefined || value == '') {
				this.dom.titleDiv.style.display = 'none';
			} else {
				this.dom.titleDiv.style.display = 'block';
				this.dom.titleDiv.textContent = value;
			}
		},
		configurable: false}
	);

	// caption Property
	if (object.caption != undefined) {
		object.dom.contentDiv.textContent = object.caption;
	}
	object._protected.caption = object.caption;
	Object.defineProperty(object, 'caption', {
		get: function() {return this._protected.caption;},
		set: function(value) {
			if (value == this._protected.caption) return;
			this._protected.caption = value;
			if (value == undefined || value == '') {
				this.dom.contentDiv.textContent = '';
			} else {
				this.dom.contentDiv.textContent = value;
			}
		},
		configurable: false}
	);
	return object.dom;
}
/**
 * The RawContent object represents an area where you can load in HTML from a source to be displayed <br><br>
 * <b>Sample Declaration</b><br>
 * <pre>
 * {
 *   component: $ui.RawContent,
 *    src: 'my/path/file.html'
 *}
 * @namespace RawContent
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {string} [src] - The path to the raw content you wish to load
*/
function $ui_RawContent(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom,'ui-raw-content');
	
	// Create our XHR
	object._protected.xhr = new XMLHttpRequest();
	object._protected.xhr.model = object;
	
	// Handle our state changes
	object._protected.xhr.onreadystatechange = function () {
		/* On readyState is 4, Determine if the request was successful or not. */
		if(this.readyState == 4) {
			if (this.status == 200) {
				this.model.dom.innerHTML = this.responseText;
			} else if(this.status != 0) {
				console.log('ERROR: XHR returned status code: ' + this.status);
			}
		}
	}
	// Src Property
	if (object.src) {
		object._protected.xhr.open('GET', object.src, true);
		object._protected.xhr.send();
	}
	object._protected.src = object.src;
	Object.defineProperty(object, 'src', {
		get: function() {return this._protected.src;},
		set: function(value) {
			if (value == this._protected.src) return;
			this._protected.src = value;
			this._protected.xhr.open('GET', value, true);
			this._protected.xhr.send();
		},
		configurable: false}
	);
	
	return object.dom;
}
/**
 * The ResponsiveLayout object represents a grouping of multiple different controls in a section that will size itself based on the screen in which it is displayed. <br><br>
 * <b>Sample Declaration</b><br>
 * <pre>
 * {
 *   component: $ui.ResponsiveLayout,
 *    id: 'myGrouping',
 *    content: [
 *       {
 *           component: $ui.Header,
 *           caption: 'My Header',
 *       },
 *       {
 *           component: $ui.List,
 *           style: $ui.GenericListItem
 *       }
 *    ]
 *}
 * @namespace ResponsiveLayout
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {$ui.CoreComponent[]} [content] - The content property is an array of control definitions to be displayed in the control
*/
function $ui_ResponsiveLayout(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom,'ui-responsive-layout');
	
	// Create our inner area that holds the content of the layout
	object.dom.inner = document.createElement('div');
	$ui.addClass(object.dom.inner,'inner');
	object.dom.appendChild(object.dom.inner);
	
	// Content property
	if (object.content == undefined) {
		object.content = [];
	}
	object._protected.content = object.content;
	Object.defineProperty(object, 'content', {
		get: function() {return this._protected.content;},
		set: function() {
			console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','content'));			
		},
		configurable: false}
	);
	if (object.content) {
		var i,
			item,
			itemDom;
		for (i = 0; i < object.content.length; i++) {
			item = object.content[i];
			itemDom = $ui.createControl(item, object.screen);
			if (itemDom) {
				object.dom.inner.appendChild(itemDom);
			}
		}
	}	
	
	return object.dom;
}
/**
 * The Suspension control represents an interface for adjusting the air suspension of the vehicle.
 * <br><br><b>Sample Declaration</b>
 * <pre>
 * {
 *    component: $ui.Suspension,
 *    leftFront: 20,
 *    rightFront: 21,
 *    leftRear: 30,
 *    rightRear: 30,
 *    tank: 112
 * }
 * </pre>
 * @namespace Suspension
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {number} [leftFront=0] - Current Pressure of the left front air spring
 * @property {number} [rightFront=0] - Current Pressure of the right front air spring
 * @property {number} [leftRear=0] - Current Pressure of the left rear air spring
 * @property {number} [rightRear=0] - Current Pressure of the right rear air spring
 * @property {number} [tank=0] - Current Pressure of the air suspension tank
 * @property {string} [img] - Image of vehicle to display
 * @property {GenericEvent} [onrightfrontclick] - User clicked the right front pressure setting
 * @property {GenericEvent} [onleftfrontclick] - User clicked the left front pressure setting
 * @property {GenericEvent} [onleftrearclick] - User clicked the left rear pressure setting
 * @property {GenericEvent} [onrightrearclick] - User clicked the right rear pressure setting
 */
function $ui_Suspension(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom,'ui-suspension theme-border-color');
	
	if ($ui.theme.inHeadUnit == true) {
		$ui.addClass(object.dom, 'in-head-unit');
	}

	// Tank area
	object.dom.tank = document.createElement('div');
	$ui.addClass(object.dom.tank,'tank theme-text-color');
	object.dom.appendChild(object.dom.tank);
	object.dom.tank.label = document.createElement('div');
	$ui.addClass(object.dom.tank.label, 'label');
	object.dom.tank.label.textContent = 'TANK';
	object.dom.tank.appendChild(object.dom.tank.label);
	object.dom.tank.pressure = document.createElement('div');
	$ui.addClass(object.dom.tank.pressure, 'pressure');
	object.dom.tank.appendChild(object.dom.tank.pressure);
	object.dom.tank.psiLabel = document.createElement('div');
	$ui.addClass(object.dom.tank.psiLabel, 'psi');
	object.dom.tank.psiLabel.textContent = 'PSI';
	object.dom.tank.appendChild(object.dom.tank.psiLabel);
	
	// Create our pinch grid top row
	object.dom.topLeftGrid = document.createElement('div');
	$ui.addClass(object.dom.topLeftGrid,'grid-cell theme-brand-border-color');
	object.dom.appendChild(object.dom.topLeftGrid);
	object.dom.topLeftGrid.style.left = '0px';
	object.dom.topLeftGrid.style.top = '0px';
	object.dom.topLeftGrid.style.borderRightStyle = 'dashed';
	object.dom.topLeftGrid.style.borderBottomStyle = 'dashed';
	
	// Left Front button
	object._protected.leftFrontButton = {
		parent: object,
		pressure: object.leftFront,
		onclick: function() {
			if (this.parent.onleftfrontclick) {
				this.parent.onleftfrontclick();
			}
		}
	};
	new $ui_PressureButton(object._protected.leftFrontButton, screen);
	object.dom.leftFront = object._protected.leftFrontButton.dom;
	$ui.addClass(object.dom.leftFront, 'top-left');
	object.dom.topLeftGrid.appendChild(object.dom.leftFront);
	
	object.dom.topMiddleGrid = document.createElement('div');
	$ui.addClass(object.dom.topMiddleGrid,'grid-cell theme-brand-border-color');
	object.dom.appendChild(object.dom.topMiddleGrid);
	object.dom.topMiddleGrid.style.left = '33.3%';
	object.dom.topMiddleGrid.style.top = '0px';
	object.dom.topMiddleGrid.style.borderBottomStyle = 'dashed';
	
	object.dom.topRightGrid = document.createElement('div');
	$ui.addClass(object.dom.topRightGrid,'grid-cell theme-brand-border-color');
	object.dom.appendChild(object.dom.topRightGrid);
	object.dom.topRightGrid.style.right = '0px';
	object.dom.topRightGrid.style.top = '0px';
	object.dom.topRightGrid.style.borderBottomStyle = 'dashed';
	object.dom.topRightGrid.style.borderLeftStyle = 'dashed';
	
	// Right Front button
	object._protected.rightFrontButton = {
		pressure: object.rightFront,
		parent: object,
		onclick: function() {
			if (this.parent.onrightfrontclick) {
				this.parent.onrightfrontclick();
			}
		}
	};
	new $ui_PressureButton(object._protected.rightFrontButton, screen);
	object.dom.rightFront = object._protected.rightFrontButton.dom;
	$ui.addClass(object.dom.rightFront, 'top-right');
	object.dom.topRightGrid.appendChild(object.dom.rightFront);
	
	// Create our pinch grid middle row
	object.dom.middleLeftGrid = document.createElement('div');
	$ui.addClass(object.dom.middleLeftGrid,'grid-cell theme-brand-border-color');
	object.dom.appendChild(object.dom.middleLeftGrid);
	object.dom.middleLeftGrid.style.left = '0px';
	object.dom.middleLeftGrid.style.top = '33.3%';
	object.dom.middleLeftGrid.style.borderRightStyle = 'dashed';
	object.dom.middleLeftGrid.style.borderBottomStyle = 'dashed';
	
	object.dom.middleMiddleGrid = document.createElement('div');
	$ui.addClass(object.dom.middleMiddleGrid,'grid-cell theme-brand-border-color');
	object.dom.appendChild(object.dom.middleMiddleGrid);
	object.dom.middleMiddleGrid.style.left = '33.3%';
	object.dom.middleMiddleGrid.style.top = '33.3%';
	object.dom.middleMiddleGrid.style.borderBottomStyle = 'dashed';
	
	object.dom.middleRightGrid = document.createElement('div');
	$ui.addClass(object.dom.middleRightGrid,'grid-cell theme-brand-border-color');
	object.dom.appendChild(object.dom.middleRightGrid);
	object.dom.middleRightGrid.style.right = '0px';
	object.dom.middleRightGrid.style.top = '33.3%';
	object.dom.middleRightGrid.style.borderBottomStyle = 'dashed';
	object.dom.middleRightGrid.style.borderLeftStyle = 'dashed';
	
	// Create our pinch grid bottom row
	object.dom.bottomLeftGrid = document.createElement('div');
	$ui.addClass(object.dom.bottomLeftGrid,'grid-cell theme-brand-border-color');
	object.dom.appendChild(object.dom.bottomLeftGrid);
	object.dom.bottomLeftGrid.style.left = '0px';
	object.dom.bottomLeftGrid.style.bottom = '0px';
	object.dom.bottomLeftGrid.style.borderRightStyle = 'dashed';
	
	// Left Rear button
	object._protected.leftRearButton = {
		pressure: object.leftRear,
		parent: object,
		onclick: function() {
			if (this.parent.onleftrearclick) {
				this.parent.onleftrearclick();
			}
		}
	};
	new $ui_PressureButton(object._protected.leftRearButton, screen);
	object.dom.leftRear = object._protected.leftRearButton.dom;
	$ui.addClass(object.dom.leftRear, 'bottom-left');
	object.dom.bottomLeftGrid.appendChild(object.dom.leftRear);
	
	object.dom.bottomMiddleGrid = document.createElement('div');
	$ui.addClass(object.dom.bottomMiddleGrid,'grid-cell theme-brand-border-color');
	object.dom.appendChild(object.dom.bottomMiddleGrid);
	object.dom.bottomMiddleGrid.style.left = '33.3%';
	object.dom.bottomMiddleGrid.style.bottom = '0px';
	
	object.dom.bottomRightGrid = document.createElement('div');
	$ui.addClass(object.dom.bottomRightGrid,'grid-cell theme-brand-border-color');
	object.dom.appendChild(object.dom.bottomRightGrid);
	object.dom.bottomRightGrid.style.right = '0px';
	object.dom.bottomRightGrid.style.bottom = '0px';
	object.dom.bottomRightGrid.style.borderLeftStyle = 'dashed';
	
	// Right Rear button
	object._protected.rightRearButton = {
		pressure: object.rightRear,
		parent: object,
		onclick: function() {
			if (this.parent.onrightrearclick) {
				this.parent.onrightrearclick();
			}
		}
	};
	new $ui_PressureButton(object._protected.rightRearButton, screen);
	object.dom.rightRear = object._protected.rightRearButton.dom;
	$ui.addClass(object.dom.rightRear, 'bottom-right');
	object.dom.bottomRightGrid.appendChild(object.dom.rightRear);
	
	// leftFront Property
	if (object.leftFront == undefined) {
		object.leftFront = 0;
	}
	object._protected.leftFront = object.leftFront;
	Object.defineProperty(object, 'leftFront', {
		get: function() {return this._protected.leftFront;},
		set: function(value) {
			if (value == undefined) value = 0;
			if (value == this._protected.leftFront) return;
			this._protected.leftFront = value;
			this._protected.leftFrontButton.pressure = value;
		},
		configurable: false}
	);
	
	// rightFront Property
	if (object.rightFront == undefined) {
		object.rightFront = 0;
	}
	object._protected.rightFront = object.rightFront;
	Object.defineProperty(object, 'rightFront', {
		get: function() {return this._protected.rightFront;},
		set: function(value) {
			if (value == undefined) value = 0;
			if (value == this._protected.rightFront) return;
			this._protected.rightFront = value;
			this._protected.rightFrontButton.pressure = value;
		},
		configurable: false}
	);
	
	// rightRear Property
	if (object.rightRear == undefined) {
		object.rightRear = 0;
	}
	object._protected.rightRear = object.rightRear;
	Object.defineProperty(object, 'rightRear', {
		get: function() {return this._protected.rightRear;},
		set: function(value) {
			if (value == undefined) value = 0;
			if (value == this._protected.rightRear) return;
			this._protected.rightRear = value;
			this._protected.rightRearButton.pressure = value;
		},
		configurable: false}
	);
	
	// leftRear Property
	if (object.leftRear == undefined) {
		object.leftRear = 0;
	}
	object._protected.leftRear = object.leftRear;
	Object.defineProperty(object, 'leftRear', {
		get: function() {return this._protected.leftRear;},
		set: function(value) {
			if (value == undefined) value = 0;
			if (value == this._protected.leftRear) return;
			this._protected.leftRear = value;
			this._protected.leftRearButton.pressure = value;
		},
		configurable: false}
	);
	
	// img Property
	if (object.img != undefined) {
		object.dom.style.backgroundImage = 'url("'+object.img+'")';
	}
	object._protected.img = object.img;
	Object.defineProperty(object, 'img', {
		get: function() {return this._protected.img;},
		set: function(value) {
			if (value == this._protected.img) return;
			this._protected.leftFront = value;
			if (value == undefined) {
				this.dom.style.backgroundImage = '';
			} else {
				this.dom.style.backgroundImage = 'url("'+value+'")';
			}
		},
		configurable: false}
	);
	
	// tank Property
	if (object.tank == undefined) {
		object.tank = 0;
	}
	object.dom.tank.pressure.textContent = object.tank;
	object._protected.tank = object.tank;
	Object.defineProperty(object, 'tank', {
		get: function() {return this._protected.tank;},
		set: function(value) {
			if (value == undefined) value = 0;
			if (value == this._protected.tank) return;
			this._protected.tank = value;
			this.dom.tank.pressure.textContent = value;
		},
		configurable: false}
	);
	

	return object.dom;
}

function $ui_PressureButton(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom,'ui-pressure-button theme-brand-text-color');
	object.dom.onclick = function() {
		$ui.playTouchSound();
		if (this.model.onclick) {
			this.model.onclick();
		}
	};	
	object.dom.ontouchstart = function() {
		$ui.removeClass(this,'theme-brand-text-color');
		$ui.addClass(this,'theme-text-color');
	};
	object.dom.ontouchend = function() {
		$ui.removeClass(this,'theme-text-color');
		$ui.addClass(this,'theme-brand-text-color');
	};
	object.dom.ontouchcancel = object.dom.ontouchend;
	if (!$ui.isMobileDevice()) {
		object.dom.onmousedown = object.dom.ontouchstart;
		object.dom.onmouseup = object.dom.ontouchend;
		object.dom.onmouseleave = object.dom.ontouchend;
	}
	
	// Create our displayDiv
	object.dom.displayDiv = document.createElement('div');
	$ui.addClass(object.dom.displayDiv, 'pressure');
	object.dom.appendChild(object.dom.displayDiv);
	
	// Create our PSI Label
	object.dom.psiLabel = document.createElement('div');
	$ui.addClass(object.dom.psiLabel, 'psi');
	object.dom.appendChild(object.dom.psiLabel);
	object.dom.psiLabel.textContent = 'PSI';
	
	// pressure Property
	if (object.pressure == undefined) {
		object.pressure = 0;
	} 
	object.dom.displayDiv.textContent = object.pressure;
	object._protected.pressure = object.pressure;
	Object.defineProperty(object, 'pressure', {
		get: function() {return this._protected.pressure;},
		set: function(value) {
			if (value == undefined) value = 0;
			if (value == this._protected.pressure) return;
			this._protected.pressure = value;
			this.dom.displayDiv.textContent = value;
		},
		configurable: false}
	);

	return object.dom;
}

/**
 * The suspension list item type is used with the {@link $ui.List} component and represents a suspension pre-set entry. 
 * <br><br><b>Sample Declaration</b>
 * <pre>
 * {
 *   caption: '(555) 897-9876',
 *   accent: 'LF:21 RF:25 LR:30 RR:30'
 * }
 * </pre>
 * @namespace SuspensionListItem
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {string} caption - Represents the main text to show in the list item
 * @property {string} [style=fixed] - Represents the style of preset. The available values are "fixed" which is a height based on no conditions, "speed" which is a height based on a speed condition or "location" which is a height based on GPS location 
 */
function $ui_SuspensionListItem(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom, 'ui-suspension-list-item theme-screen-background-color theme-text-color theme-dark-border-color');
	if ($ui.theme.inHeadUnit == true) {
		$ui.addClass(object.dom, 'in-head-unit');
	}

	// Caption
	object.dom.captionDiv = document.createElement('div');
	$ui.addClass(object.dom.captionDiv,'caption theme-text-color');
	object.dom.appendChild(object.dom.captionDiv);
	
	// style property
	if (object.style == undefined) {
		object.style = 'fixed';
	}
	$ui.addClass(object.dom, object.style);
	object._protected.style = object.style;
	Object.defineProperty(object, 'style', {
		get: function() {return this._protected.style;},
		set: function(value) {
			if (value == undefined) value = 'fixed';
			if (value == this._protected.style) return;
			$ui.removeClass(this.dom, this._protected.style);
			$ui.addClass(this.dom, value);
			this._protected.style = value;
		},
		configurable: false}
	);
	
	// caption property
	if (object.caption == undefined) {
		object.caption = '';
	}
	object.dom.captionDiv.textContent = object.caption;
	object._protected.caption = object.caption;
	Object.defineProperty(object, 'caption', {
		get: function() {return this._protected.caption;},
		set: function(value) {
			if (value == undefined) value = '';
			if (value == this._protected.caption) return;
			this._protected.caption = value;
			this.dom.captionDiv.textContent = value;
		},
		configurable: false}
	);
	
	
	// Handle our touch events
	object.dom.ontouchstart = function() {
		$ui.removeClass(this, 'theme-screen-background-color');
		$ui.addClass(this, 'theme-brand-background-color');
	}
	object.dom.ontouchend = function() {
		$ui.removeClass(this, 'theme-brand-background-color');
		$ui.addClass(this, 'theme-screen-background-color');
	}
	object.dom.ontouchcancel = object.dom.ontouchend;
	if (!$ui.isMobileDevice()) {
		object.dom.onmousedown = object.dom.ontouchstart;
		object.dom.onmouseup = object.dom.ontouchend;
		object.dom.onmouseleave = object.dom.ontouchend;
	}

	// Pass the onclick back to the list
	object.dom.onclick = function() {
		if (this.model.parent.onaction == undefined) return;
		var event = new ListEvent(this.model, $ui.GenericListItem.GenericListEvent.ONCLICK);
		this.model.parent._onaction(this.model, event);
		$ui.playTouchSound();
	};

	return object.dom;
}
/**
 * The TileAcceleration represents the tile that shows Acceleration in G-forces..
 * <br><br><b>Sample Declaration</b>
 * <pre>
 * {
 *    component: $ui.TileAcceleration,
 *    min: 0,
 *    max: 1.5,
 *    value: 1
 * }
 * </pre>
 * @namespace TileAcceleration
 * @memberof $ui
 * @extends $ui.CoreTileGauge
 */
function $ui_TileAcceleration(object, screen) {
	$ui_CoreTileGauge.call(this, object, screen);
	$ui.addClass(object.dom,'ui-tile-acceleration');
	
	object._setTitle('Acceleration');
	object._setAccent('Average G-Forces');
	
	// Private function to handle provider updates
	object._providerUpdate = function(value) {
		if (value != undefined) {
			this.min = value.min;
			this.max = value.max;
			this.value = value.value;
			this._populateData();
		} else {
			this.min =0;
			this.max = 1;
			this.value = 0;
		}
		this.showContent(true);
	}.$bind(object);	
	
	// Handle theme changes
	object._onthemechange = function() {
		// Repaint the control
		this._providerUpdate(this);
	}.$bind(object);
	
	// Load our control if no provider is connected
	if (object.provider == undefined) {
		object._providerUpdate({min: object.min, max: object.max, value: object.value })
	}
	
	return object.dom;
}
/**
 * The Badge tile displays the different badges that the user has been awarded. 
 * <br><br><b>Sample Declaration</b>
 * <pre>
 * {
 *    component: $ui.TileBadge
 *    img: 'img/badge.png',
 *    caption: 'This is <large>my</large> caption',
 *    accent:  'Smaller text'
 * }
 * </pre>
 * @namespace TileBadge
 * @memberof $ui
 * @extends $ui.CoreTile
 * @property {string} [img] - Represents the path to the image representing the badge
 * @property {string} [accent] - Represents the accent text to go along with the caption
 * @property {string} [caption] - This is the text to appear on the badge. The caption value can also have opening and closing <b>&lt;large&gt;</b> elements to signify which parts of the text should be large-sized.
 */
function $ui_TileBadge(object, screen) {
	// This tile is 1 x 1
	object._size = undefined;
	$ui_CoreTile.call(this, object, screen);
	$ui.addClass(object.dom,'ui-tile-badge');
	
	// Create the caption area
	object.dom.caption = document.createElement('div');
	$ui.addClass(object.dom.caption,'caption');
	object.dom.contentDiv.appendChild(object.dom.caption);
	
	// Create our Next Button
	object.dom.next = document.createElement('div');
	$ui.addClass(object.dom.next, 'button');
	$ui.addClass(object.dom.next, 'next');
	object.dom.contentDiv.appendChild(object.dom.next);
	
	// Create our Previous Button
	object.dom.prev = document.createElement('div');
	$ui.addClass(object.dom.prev, 'button');
	$ui.addClass(object.dom.prev, 'prev');
	object.dom.contentDiv.appendChild(object.dom.prev);

	// Create our accent area
	object.dom.accent = document.createElement('div');
	$ui.addClass(object.dom.accent, 'accent');
	object.dom.contentDiv.appendChild(object.dom.accent);
	
	// Private function to handle provider updates
	object._providerUpdate = function(value) {
		if (value != undefined) {
			this.img = value.img;
			this.caption = value.caption;
			this.accent = value.accent;
		} else {
			this.img = undefined;
			this.caption = undefined;
			this.accent = undefined;
		}
		// Set our image
		this.dom.contentDiv.style.backgroundImage = 'url("'+ this.img + '")';
		// Set our caption
		if (this.caption) {
			var str = this.caption.replace(new RegExp('<large>', 'g'), '<span class="tall">');
			str = str.replace(new RegExp('</large>', 'g'),'</span>');
			this.dom.caption.innerHTML = str;
		}
		// Set our accent
		if (this.accent) {
			this.dom.accent.textContent = this.accent;
		}
		this.showContent(true);
	}.$bind(object);	
	
	// Load our control if no provider is connected
	if (object.provider == undefined) {
		object._providerUpdate({img: object.img, caption: object.caption, accent: object.accent })
	}
	
	return object.dom;
}
/**
 * The Braking Tile represents the tile which shows Braking in G-forces.
 * <br><br><b>Sample Declaration</b>
 * <pre>
 * {
 *    component: $ui.TileBraking,
 *    min: 0,
 *    max: 1.5,
 *    value: 1
 * }
 * </pre>
 * @namespace TileBraking
 * @memberof $ui
 * @extends $ui.CoreTileGauge
 */
function $ui_TileBraking(object, screen) {
	$ui_CoreTileGauge.call(this, object, screen);
	$ui.addClass(object.dom,'ui-tile-braking');
	
	object._setTitle('Braking');
	object._setAccent('Average G-Forces');
	
	// Private function to handle provider updates
	object._providerUpdate = function(value) {
		if (value != undefined) {
			this.min = value.min;
			this.max = value.max;
			this.value = value.value;
			this._populateData();
		} else {
			this.min =0;
			this.max = 1;
			this.value = 0;
		}
		this.showContent(true);
	}.$bind(object);	
	
	// Handle theme changes
	object._onthemechange = function() {
		// Repaint the control
		this._providerUpdate(this);
	}.$bind(object);
	
	// Load our control if no provider is connected
	if (object.provider == undefined) {
		object._providerUpdate({min: object.min, max: object.max, value: object.value })
	}
	
	return object.dom;
}
/**
 * The Distance tile displays the distance travelled over the last few recorded periods. 
 * <br><br><b>Sample Declaration</b>
 * <pre>
 * {
 *    component: $ui.TileDistance
 *    data: [5,25,8.2],
 *    units:  'miles'
 * }
 * </pre>
 * @namespace TileDistance
 * @memberof $ui
 * @extends $ui.CoreTile
 * @property {number[]} [data] - This array of numbers represents the last few points of distance units recorded. The values in the array are ordered from oldest to newest.
 * @property {string} units - This string value represents the units of measure. Typically miles or km.
 */
function $ui_TileDistance(object, screen) {
	// This tile is 1 x 1
	object._size = undefined;
	$ui_CoreTile.call(this, object, screen);
	$ui.addClass(object.dom,'ui-tile-distance');
	
	// Create our chart area
	object.dom.canvas = document.createElement('canvas');
	$ui.addClass(object.dom.canvas, 'chart');
	object.dom.canvas.height = 180;
	object.dom.contentDiv.appendChild(object.dom.canvas);
	
	// Create the caption area
	object.dom.caption = document.createElement('div');
	$ui.addClass(object.dom.caption,'caption');
	object.dom.contentDiv.appendChild(object.dom.caption);
	
	// Private function to handle provider updates
	object._providerUpdate = function(value) {
		if (this.dom.offsetWidth) {
			this.dom.canvas.width = this.dom.offsetWidth - 24;
			this.dom.ctx = this.dom.canvas.getContext('2d');
			this.dom.chart = new Chart(this.dom.ctx);
		}
		if (this.dom.chart == undefined) return;
		var i,
			_labels = [],
			_transparentData = [],
			_noData = false;
		// Assign our values
		if (value != undefined) {
			this.data = value.data;
			this.units = value.units;
		} else {
			this.data = undefined;
			this.units = 'miles';
		}
		// Make any corrections
		if ((this.data == undefined) || (this.data && this.data.length == 0)) {
			this.data = [0];
			_noData = true;
		} else if (this.data.length == 1) {
			this.data = [0,this.data[0]];
		}
		// Set our latest value
		this._value = this.data[this.data.length -1];
		// Populate our extra chart data
		for (i = 0; i < this.data.length; i++) {
			if (i == this.data.length - 1) {
				// Last item so set our values
				_labels.push('Today');
			} else {
				_labels.push('');
			}
			_transparentData.push(0);
		}
		// Set our caption
		this.dom.caption.innerHTML = '<span class="tall distance">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="tall">'+this._value+'</span> '+this.units;
		// Get our root color
		var RGB = $ui.hexToRgb($ui.theme.chart.color_GREAT);
		// Load our data
		var data = {
			labels: _labels,
			datasets: [
				{
					fillColor: 'rgba('+RGB.R+','+RGB.G+','+RGB.B+',0.2)',
					strokeColor: 'rgba('+RGB.R+','+RGB.G+','+RGB.B+',1)',
					pointColor: 'rgba('+RGB.R+','+RGB.G+','+RGB.B+',1)',
					pointStrokeColor: '#fff',
					pointHighlightFill: '#fff',
					pointHighlightStroke: 'rgba('+RGB.R+','+RGB.G+','+RGB.B+',1)',
					data: this.data
				},
				{
					fillColor: 'transparent',
					strokeColor: 'transparent',
					pointColor: 'transparent',
					pointStrokeColor: 'transparent',
					pointHighlightFill: 'transparent',
					pointHighlightStroke: 'transparent',
					data: _transparentData
				}
			]
		}
		this.dom.chart.Line(data,{scaleShowGridLines: false,showTooltips: false,scaleFontColor: window.getComputedStyle(this.dom).color});
		this.showContent(true);
	}.$bind(object);	
	
	// Handle theme changes
	object._onthemechange = function() {
		// Repaint the control
		this._providerUpdate(this);
	}.$bind(object);
	
	// Load our control if no provider is connected
	object._onshow = function() {
		if (this.provider == undefined) {
			this._providerUpdate({data: this.data, units: this.units})
		}
	}.$bind(object);
	
	return object.dom;
}
/**
 * The Drift Angle tile represents a tile displaying the current angle of the vehicle.
 * <br><br><b>Sample Declaration</b>
 * <pre>
 * {
 *    component: $ui.TileDriftAngle,
 *    angle: 20
 * }
 * </pre>
 * @namespace TileDriftAngle
 * @memberof $ui
 * @extends $ui.CoreTile
 * @property {number} [angle] - This number represents the current angle of the vehicle based on its current heading
 * @property {string} img - Path to the image to display in the tile
 */
function $ui_TileDriftAngle(object, screen) {
	// This tile is 1 x 1
	object._size = $ui.TileSize.SQUARE;
	$ui_CoreTile.call(this, object, screen);
	$ui.addClass(object.dom,'ui-tile-drift-angle');
	
	// Create the dial area
	object.dom.dial = document.createElement('div');
	$ui.addClass(object.dom.dial,'dial');
	object.dom.contentDiv.appendChild(object.dom.dial);
	object.dom.dial.img = new Image();
	object.dom.dial.img.parent = object.dom.dial;
	object.dom.dial.img.onload = function() {
		this.parent.style.opacity = 1;
		this.parent.style.backgroundImage = 'url("'+this.src+'")';
	};
	
	// img Property
	if (object.img != undefined) {
		object.dom.dial.img.src = object.img;
	}
	object._protected.img = object.img;
	Object.defineProperty(object, 'img', {
		get: function() {return this._protected.img;},
		set: function(value) {
			if (value == this._protected.img) return;
			if (value == undefined) value = '';
			this._protected.img = value;
			this.dom.dial.style.opacity = 0;
			this.dom.dial.img.src = value;
		},
		configurable: false}
	);
	
	// angle Property
	if (object.angle != undefined) {
		object.dom.dial.style['-webkit-transform'] = 'rotate('+ object.angle +'deg)';
	}
	object._protected.angle = object.angle;
	Object.defineProperty(object, 'angle', {
		get: function() {return this._protected.angle;},
		set: function(value) {
			if (value == this._protected.angle) return;
			if (value == undefined) value = 0;
			this._protected.angle = value;
			this.dom.dial.style['-webkit-transform'] = 'rotate('+ value +'deg)';
		},
		configurable: false}
	);
	
	// Display the content because we are not waiting for a provider
	object.showContent(true);

	return object.dom;
}

/**
 * The Dyno Chart tile represents horsepower and torque graphing
 * <br><br><b>Sample Declaration</b>
 * <pre>
 * {
 *    component: $ui.TileDynoChart,
 *    caption: 'Max 567HP and 489 TQ',
 *    horsepower: [400, 489, 505],
 *    torque: [360, 402,482]
 * }
 * </pre>
 * @namespace TileDynoChart
 * @memberof $ui
 * @extends $ui.CoreTile
 * @property {number[]} [horsepower] - This array of numbers represents the horsepower rating at 100 RPM intervals
 * @property {number[]} [torque] - This array of numbers represents the torque rating at 100 RPM intervals
 * @property {string} [caption] - This optional string value represents the text caption you wish to include
 */
function $ui_TileDynoChart(object, screen) {
	// This tile is 1 x 2
	object._size = $ui.TileSize.WIDE;
	$ui_CoreTile.call(this, object, screen);
	$ui.addClass(object.dom,'ui-tile-dyno-chart');
	
	// Create the caption area
	object.dom.caption = document.createElement('div');
	$ui.addClass(object.dom.caption,'caption');
	object.dom.contentDiv.appendChild(object.dom.caption);
	
	// RPM Counter
	object.dom.rpm = document.createElement('div');
	$ui.addClass(object.dom.rpm, 'rpm');
	object.dom.contentDiv.appendChild(object.dom.rpm);
	
	// How To display
	object.dom.howTo = document.createElement('div');
	$ui.addClass(object.dom.howTo, 'how-to');
	object.dom.contentDiv.appendChild(object.dom.howTo);
	object.dom.howTo.textContent = 'Start driving below 3000 RPM in 3rd gear, then press START and accelerate to 7000 RPM';
	
	// Create our chart area
	object.dom.canvas = document.createElement('canvas');
	$ui.addClass(object.dom.canvas, 'chart');
	object.dom.canvas.height = 190;
	object.dom.canvas.width = 490;
	object.dom.contentDiv.appendChild(object.dom.canvas);
	object.dom.ctx = object.dom.canvas.getContext('2d');
	object.dom.chart = new Chart(object.dom.ctx);
	
	// horsepower Property
	if (object.horsepower == undefined) {
		object.horsepower = [];
	}
	object._protected.horsepower = object.horsepower;
	Object.defineProperty(object, 'horsepower', {
		get: function() {return this._protected.horsepower;},
		set: function(value) {
			if (value == this._protected.horsepower) return;
			if (value == undefined) value = [];
			this._protected.horsepower = value;
			this._providerUpdate(this);
		},
		configurable: false}
	);
	
	// caption Property
	if (object.caption == undefined) {
		object.caption = '';
	} else {
		object.dom.caption.textContent = object.caption;
	}
	object._protected.caption = object.caption;
	Object.defineProperty(object, 'caption', {
		get: function() {return this._protected.caption;},
		set: function(value) {
			if (value == this._protected.caption) return;
			if (value == undefined) value = '';
			this._protected.caption = value;
			this.dom.caption.textContent = value;
		},
		configurable: false}
	);
		
	// torque Property
	if (object.torque == undefined) {
		object.torque = [];
	}
	object._protected.torque = object.torque;
	Object.defineProperty(object, 'torque', {
		get: function() {return this._protected.torque;},
		set: function(value) {
			if (value == this._protected.torque) return;
			if (value == undefined) value = [];
			this._protected.torque = value;
			this._providerUpdate(this);
		},
		configurable: false}
	);
	
	/** When you set the RPM of the Dyno Chart it will move the control to a new state where just the RPMs are visible
	 * @function setRPM
	 * @memberof $ui.TileDynoChart
	 * @param {number} value - The RPM value to set
	 */
	object.setRPM = function(value) {
		this.dom.rpm.style.display = 'block';
		this.dom.canvas.style.display = 'none';
		this.dom.caption.style.display = 'none';
		this.dom.howTo.style.display = 'none';
		this.dom.rpm.innerHTML = '<span>'+value + '</span><span style="font-size: 50px;"> RPM</span>';
	}.$bind(object);
	
	/** This will reset the dyno chart back to its initial state
	 * @function reset
	 * @memberof $ui.TileDynoChart
	 */
	object.reset = function() {
		this.dom.rpm.style.display = 'none';
		this.dom.howTo.style.display = 'block';
		this.dom.canvas.style.display = 'none';
		this.dom.caption.style.display = 'none';
	}.$bind(object);
	
	// Private function to handle provider updates
	object._providerUpdate = function(value) {
		var i,
			_labels = ['3','','','','','3.5','','','','','4','','','','','4.5','','','','','5','','','','','5.5','','','','','6','','','','','6.5','','','','','7'];
		// Assign our values
		if (value != undefined) {
			this._protected.horsepower = (value.horsepower == undefined) ? [] : value.horsepower;
			this._protected.torque = (value.torque == undefined) ? [] : value.torque;
			this.caption = value.caption;
		} else {
			this.data = undefined;
			this.labels = undefined;
		}
		// Reset our visibility
		this.dom.rpm.style.display = 'none';
		this.dom.canvas.style.display = 'block';
		this.dom.caption.style.display = 'block';
		this.dom.howTo.style.display = 'none';
		// Get our root color
		var RGB = $ui.hexToRgb($ui.theme.chart.color_GREAT),
			RGB2 = $ui.hexToRgb($ui.theme.chart.color);
		// Load our data
		var data = {
			labels: _labels,
			datasets: [
				{
					fillColor: 'rgba('+RGB2.R+','+RGB2.G+','+RGB2.B+',0.5)',
					strokeColor: 'rgba('+RGB2.R+','+RGB2.G+','+RGB2.B+',1)',
					data: this.torque
				},
				{
					fillColor: 'rgba('+RGB.R+','+RGB.G+','+RGB.B+',0.5)',
					strokeColor: 'rgba('+RGB.R+','+RGB.G+','+RGB.B+',1)',
					data: this.horsepower
				}
			]
		}
		this.dom.chart.Line(data,{scaleShowGridLines: true,showTooltips: false,scaleFontColor: '#FFFFFF',pointDot: false});
	}.$bind(object);	
	
	// Handle theme changes
	object._onthemechange = function() {
		// Repaint the control
		this._providerUpdate(this);
	}.$bind(object);
	
	// Load our control if no provider is connected
	if (object.provider == undefined) {
		object._providerUpdate(object);
	}
	object.showContent(true);
	
	return object.dom;
}
/**
 * The Fuel tile displays the fuel used over the last few recorded periods. 
 * <br><br><b>Sample Declaration</b>
 * <pre>
 * {
 *    component: $ui.TileFuel
 *    data: [5,25,8.2],
 *    value: 8.25
 * }
 * </pre>
 * @namespace TileFuel
 * @memberof $ui
 * @extends $ui.CoreTile
 * @property {number[]} [data] - This array of numbers represents the last few points of fuel level values recorded. The values in the array are ordered from oldest to newest.
 * @property {number} value - This number value represents the dollar amount of fuel used for the day
 */
function $ui_TileFuel(object, screen) {
	// This tile is 1 x 1
	object._size = undefined;
	$ui_CoreTile.call(this, object, screen);
	$ui.addClass(object.dom,'ui-tile-fuel');

	// Create our chart area
	object.dom.canvas = document.createElement('canvas');
	$ui.addClass(object.dom.canvas, 'chart');
	object.dom.canvas.height = 180;
	object.dom.contentDiv.appendChild(object.dom.canvas);
	
	// Create our left hand labels
	object.dom.leftLabels = document.createElement('div');
	$ui.addClass(object.dom.leftLabels, 'left-labels theme-screen-background-color');
	object.dom.contentDiv.appendChild(object.dom.leftLabels);
	// Top Label
	object.dom.topLabel = document.createElement('div');
	$ui.addClass(object.dom.topLabel, 'label');
	$ui.addClass(object.dom.topLabel, 'top');
	object.dom.topLabel.textContent = 'F';
	object.dom.leftLabels.appendChild(object.dom.topLabel);
	// Middle Label
	object.dom.middleLabel = document.createElement('div');
	$ui.addClass(object.dom.middleLabel, 'label');
	$ui.addClass(object.dom.middleLabel, 'middle');
	object.dom.middleLabel.innerHTML = '&#189;';
	object.dom.leftLabels.appendChild(object.dom.middleLabel);
	// Bottom Label
	object.dom.bottomLabel = document.createElement('div');
	$ui.addClass(object.dom.bottomLabel, 'label');
	$ui.addClass(object.dom.bottomLabel, 'bottom');
	object.dom.bottomLabel.textContent = 'E';
	object.dom.leftLabels.appendChild(object.dom.bottomLabel);
	
	// Create the caption area
	object.dom.caption = document.createElement('div');
	$ui.addClass(object.dom.caption,'caption');
	object.dom.contentDiv.appendChild(object.dom.caption);

	// Private function to handle provider updates
	object._providerUpdate = function(value) {
		if (this.dom.offsetWidth) {
			this.dom.canvas.width = this.dom.offsetWidth - 20;
			this.dom.ctx = this.dom.canvas.getContext('2d');
			this.dom.chart = new Chart(this.dom.ctx);
		}
		if (this.dom.chart == undefined) return;
		var i,
			_labels = [],
			_transparentData = [],
			_noData = false;
		// Assign our values
		if (value != undefined) {
			this.data = value.data;
			this.value = value.value;
		} else {
			this.data = undefined;
			this.value = 0;
		}
		// Make any corrections
		if (this.value == undefined) this.value = 0;
		if ((this.data == undefined) || (this.data && this.data.length == 0)) {
			this.data = [0];
			_noData = true;
		} else if (this.data.length == 1) {
			this.data = [0,this.data[0]];
		}
		// Populate our extra chart data
		for (i = 0; i < this.data.length; i++) {
			if (i == this.data.length - 1) {
				// Last item so set our values
				_labels.push('Now');
				_transparentData.push(0);
			} else {
				_labels.push('');
				_transparentData.push(100);
			}
		}
		// Set our caption
		this.dom.caption.innerHTML = '<span class="tall">$'+this.value+'</span> of <span class="tall fuel">&nbsp;&nbsp;&nbsp;&nbsp;</span>Today';
		// Get our root color
		var RGB = $ui.hexToRgb($ui.theme.chart.color_RANDOM1);
		
		// Load our data
		var data = {
			labels: _labels,
			datasets: [
				{
					fillColor: 'rgba('+RGB.R+','+RGB.G+','+RGB.B+',0.2)',
					strokeColor: 'rgba('+RGB.R+','+RGB.G+','+RGB.B+',1)',
					pointColor: 'rgba('+RGB.R+','+RGB.G+','+RGB.B+',1)',
					pointStrokeColor: '#fff',
					pointHighlightFill: '#fff',
					pointHighlightStroke: 'rgba('+RGB.R+','+RGB.G+','+RGB.B+',1)',
					data: this.data
				},
				{
					fillColor: 'transparent',
					strokeColor: 'transparent',
					pointColor: 'transparent',
					pointStrokeColor: 'transparent',
					pointHighlightFill: 'transparent',
					pointHighlightStroke: 'transparent',
					data: _transparentData
				}
			]
		}
		this.dom.chart.Line(data,{scaleShowGridLines: false,showTooltips: false, scaleFontColor: window.getComputedStyle(this.dom).color});	
		this.showContent(true);
	}.$bind(object);	
	
	// Handle theme changes
	object._onthemechange = function() {
		// Repaint the control
		this._providerUpdate(this);
	}.$bind(object);
	
	// Load our control if no provider is connected
	object._onshow = function() {
		if (this.provider == undefined) {
			this._providerUpdate({data: this.data, value: this.value})
		}
	}.$bind(object);
	
	return object.dom;
}
/**
 * The Idle tile represents the amount of time the driver spends moving and not sitting in one place.
 * <br><br><b>Sample Declaration</b>
 * <pre>
 * {
 *    component: $ui.TileIdle
 *    value: 70
 * }
 * </pre>
 * @namespace TileIdle
 * @memberof $ui
 * @extends $ui.CoreTile
 * @property {number} value - This number value represents the percentage of time the driver spent moving.
 */
function $ui_TileIdle(object, screen) {
	object._size = undefined;
	$ui_CoreTileDonutChart.call(this, object, screen);
	$ui.addClass(object.dom,'ui-tile-idle-chart');
	
	// Figure out the data array for this chart
	object._calculateData = function() {
		var data;
		if (this.value != undefined) {
			var colorValue;
			// Correct any errors in data
			if (this.value < 0) this.value = 0;
			if (this.value > 100) this.value = 100;
			// Determine color
			switch (true) {
				case (this.value >= 70):
					colorValue = $ui.theme.chart.color_GREAT;
					break;
				case (this.value >= 50):
					colorValue = $ui.theme.chart.color_GOOD;
					break;
				default:
					colorValue = $ui.theme.chart.color_OK;
					break;
			}		
			// Create our chart data object
			data = [
				{
					value: this.value,
					color: colorValue,
				},
				{
					value: (100 - this.value),
					color: $ui.theme.chart.color
				}				
			];	
		} 
		return data;
	}.$bind(object);
	
	// Private function to handle provider updates
	object._providerUpdate = function(value) {
		if (value != undefined) {
			this.value = value.value;
		} else {
			this.value = 0;
		}
		// Populate our chart with data
		var data = this._calculateData();
		if (data != undefined) {
			this._setData(data);
			this._setCaption('<span class="tall">'+this.value + '%</span> spent moving');
		}
		this.showContent(true);
	}.$bind(object);	
	
	// Handle theme changes
	object._onthemechange = function() {
		// Repaint the control
		this._providerUpdate(this);
	}.$bind(object);
	
	// Load our control if no provider is connected
	if (object.provider == undefined) {
		object._providerUpdate({value: object.value });
	}
	
	return object.dom;
}
/**
 * The Idle Details tile represents how much time was spent being stuck in traffic over the last 7 days.
 * <br><br><b>Sample Declaration</b>
 * <pre>
 * {
 *    component: $ui.TileIdleDetails,
 *    labels: ['Sun','Mon','Tue','Wed','Thur','Fri','Today'],
 *    data: [0,35,17,65,0,10,15]
 * }
 * </pre>
 * @namespace TileIdleDetails
 * @memberof $ui
 * @extends $ui.CoreTile
 * @property {number[]} [data] - This array of numbers represents the amount of minutes spent idle over the last 7 days
 * @property {string[]} [labels] - This array of strings represents the labels for the last 7 days
 */
function $ui_TileIdleDetails(object, screen) {
	// This tile is 1 x 1
	object._size = $ui.TileSize.WIDE;
	if (object.animated == undefined) {
		object.animated = true;
	}
	$ui_CoreTile.call(this, object, screen);
	$ui.addClass(object.dom,'ui-tile-idle-details');
	
	// Create the caption area
	object.dom.caption = document.createElement('div');
	$ui.addClass(object.dom.caption,'caption');
	object.dom.contentDiv.appendChild(object.dom.caption);
	object.dom.caption.textContent = 'Time Stuck In Traffic (mins)';
	
	// Create our chart area
	object.dom.canvas = document.createElement('canvas');
	$ui.addClass(object.dom.canvas, 'chart');
	object.dom.canvas.height = 190;
	object.dom.contentDiv.appendChild(object.dom.canvas);
	
	// Private function to handle provider updates
	object._providerUpdate = function(value) {
		if (this.dom.offsetWidth) {
			this.dom.canvas.width = this.dom.offsetWidth - 10;
			this.dom.ctx = this.dom.canvas.getContext('2d');
			this.dom.chart = new Chart(this.dom.ctx);
		}
		if (this.dom.chart == undefined) return;
		if (value != undefined) {
			this.data = value.data;
			this.labels = value.labels;
		} else {
			this.data = undefined;
			this.labels = undefined;
		}
		// Get our root color
		var RGB = $ui.hexToRgb($ui.theme.chart.color_OK);
		// Load our data
		var data = {
			labels: this.labels,
			datasets: [
				{
					fillColor: 'rgba('+RGB.R+','+RGB.G+','+RGB.B+',0.5)',
					strokeColor: 'rgba('+RGB.R+','+RGB.G+','+RGB.B+',1)',
					data: this.data
				}
			]
		}
		this.dom.chart.Bar(data,{scaleShowGridLines: true,showTooltips: false, animation: this.animated, scaleFontColor: window.getComputedStyle(this.dom).color});
		this.showContent(true);
	}.$bind(object);	
	
	// Handle theme changes
	object._onthemechange = function() {
		// Repaint the control
		this._providerUpdate(this);
	}.$bind(object);
	
	// Load our control if no provider is connected
	object._onshow = function() {
		if (this.provider == undefined) {
			this._providerUpdate({data: this.data, labels: this.labels})
		}
	}.$bind(object);
	
	return object.dom;
}
/**
 * The Lateral Gs tile represents information for skid pad testing.
 * <br><br><b>Sample Declaration</b>
 * <pre>
 * {
 *    component: $ui.TileLateralGs,
 *    rotation: 20
 * }
 * </pre>
 * @namespace TileLateralGs
 * @memberof $ui
 * @extends $ui.CoreTile
 * @property {number} [rotation] - This number represents the percentage in rotation around the skidpad. 50 would represent 1/2 a rotation
 * @property {string} img - Path to the image to display in the tile
 */
function $ui_TileLateralGs(object, screen) {
	// This tile is 1 x 1
	object._size = $ui.TileSize.SQUARE;
	$ui_CoreTile.call(this, object, screen);
	$ui.addClass(object.dom,'ui-tile-lateral-g');
	
	// Create the dial area
	object.dom.dial = document.createElement('div');
	$ui.addClass(object.dom.dial,'dial');
	object.dom.contentDiv.appendChild(object.dom.dial);
	
	// Create our vehicle
	object.dom.vehicle = document.createElement('img');
	$ui.addClass(object.dom.vehicle, 'vehicle');
	object.dom.dial.appendChild(object.dom.vehicle);
	object.dom.vehicle.onload = function() {
		this.style.opacity = 1;
	}
	
	// Create our circle
	object.dom.circle = document.createElement('div');
	$ui.addClass(object.dom.circle, 'circle theme-border-color');
	object.dom.dial.appendChild(object.dom.circle);
	
	// Create our line
	object.dom.line = document.createElement('div');
	$ui.addClass(object.dom.line, 'line theme-brand-text-color theme-brand-border-color');
	object.dom.contentDiv.appendChild(object.dom.line);
	object.dom.line.textContent = '150 ft radius';
	
	// img Property
	if (object.img != undefined) {
		object.dom.vehicle.src = object.img;
	}
	object._protected.img = object.img;
	Object.defineProperty(object, 'img', {
		get: function() {return this._protected.img;},
		set: function(value) {
			if (value == this._protected.img) return;
			if (value == undefined) value = '';
			this._protected.img = value;
			this.dom.vehicle.style.opacity = 0;
			this.dom.vehicle.src = value;
		},
		configurable: false}
	);
	
	// rotation Property
	if (object.rotation != undefined) {
		object.dom.dial.style['-webkit-transform'] = 'rotate('+ object.rotation +'deg)';
	}
	object._protected.rotation = object.rotation;
	Object.defineProperty(object, 'rotation', {
		get: function() {return this._protected.rotation;},
		set: function(value) {
			if (value == this._protected.rotation) return;
			if (value == undefined) value = 0;
			this._protected.rotation = value;
			this.dom.dial.style['-webkit-transform'] = 'rotate('+ value +'deg)';
		},
		configurable: false}
	);
	
	// Display the content because we are not waiting for a provider
	object.showContent(true);
	
	return object.dom;
}

/**
 * The MPG tile represents how close to the target miles per gallon target they achieved
 * <br><br><b>Sample Declaration</b>
 * <pre>
 * {
 *    component: $ui.TileMPG,
 *    value: 25,
 *    max: 34,
 *    abbreviation: 'MPG'
 * }
 * </pre>
 * @namespace TileMPG
 * @memberof $ui
 * @extends $ui.CoreTileDonutChart
 * @property {number} [value] - This number value represents the actual MPG value achived
 * @property {number} [max] - This number value represents the target value the driver is hoping to achieve
 * @property {string} [abbreviation] - This string value represents the Miles per gallon or KM per liter abbreviation
 */
function $ui_TileMPG(object, screen) {
	object._size = undefined;
	$ui_CoreTileDonutChart.call(this, object, screen);
	$ui.addClass(object.dom,'ui-tile-mpg-chart');
	
	// Figure out the data array for this chart
	object._calculateData = function() {
		var data;
		if (this.max != undefined && this.value != undefined) {
			var colorValue,
				percent;
			// Check for errors in data
			if (this.value < 0) this.value = 0;
			if (this.value > this.max) {
				percent = 100;	
			} else {
				percent = Math.ceil((this.value / this.max)*100);
			}
			// Determine Color
			switch (true) {
				case (percent > 90):
					colorValue = $ui.theme.chart.color_GREAT;
					break;
				case (percent > 50):
					colorValue = $ui.theme.chart.color_GOOD;
					break;
				default:
					colorValue = $ui.theme.chart.color_OK;
					break;
			}
			// Create our chart data object
			data = [
				{
					value: percent,
					color: colorValue,
				},
				{
					value: (100-percent),
					color: $ui.theme.chart.color
				}
			];	
		} 
		return data;
	}.$bind(object);
	

	// Private function to handle provider updates
	object._providerUpdate = function(value) {
		if (value != undefined) {
			this.value = value.value;
			this.max = value.max;
			this.abbreviation = value.abbreviation;
		} else {
			this.value = 0;
			this.max = 0;
			this.abbreviation = 'MPG';
		}
		// Populate our chart with data
		var data = this._calculateData();
		if (data != undefined) {
			this._setData(data);
			this._setCaption('<span class="tall">'+this.value + '</span> ' + this.abbreviation);
		}
		this.showContent(true);
	}.$bind(object);	
	
	// Handle theme changes
	object._onthemechange = function() {
		// Repaint the control
		this._providerUpdate(this);
	}.$bind(object);
	
	// Load our control if no provider is connected
	if (object.provider == undefined) {
		object._providerUpdate({value: object.value, max: object.max, abbreviation: object.abbreviation })
	}
	
	return object.dom;
}
/**
 * The Profile tile displays the user's profile and participation statistics.
 * <br><br><b>Sample Declaration</b>
 * <pre>
 * {
 *    component: $ui.TileProfile
 *    backgroundImg: 'img/car.png',
 *    avatar: 'img/useravatar.png',
 *    userName:  'brcewane',
 *    stats: {
 *        friends: 12,
 *        groups: 6,
 *        score: 4056,
 *        rank: 2,
 *    }
 * }
 * </pre>
 * @namespace TileProfile
 * @memberof $ui
 * @extends $ui.CoreTile
 * @property {string} [backgroundImg] - This is the path to the background image the user has chosen for their profile.
 * @property {string} [userName] - This is the user's profile name
 * @property {string} [avatar] - This string value represents the path to the user's avatar picture
 * @property {$ui.TileProfile.ProfileStats} [stats] - This object represents the participation statistics for the user
 */
function $ui_TileProfile(object, screen) {
	// This is a tall tile
	object._size = $ui.TileSize.TALL;
	$ui_CoreTile.call(this, object, screen);
	$ui.addClass(object.dom,'ui-tile-profile');
	
	// Create our Color wedge
	object.dom.wedge = document.createElement('div');
	$ui.addClass(object.dom.wedge, 'wedge theme-profile-wedge-background-color');
	object.dom.contentDiv.appendChild(object.dom.wedge);
	
	// Create the space for our vehicle
	object.dom.vehicle = document.createElement('div');
	$ui.addClass(object.dom.vehicle, 'vehicle theme-profile-vehicle-background-color');
	object.dom.contentDiv.appendChild(object.dom.vehicle);
	object.dom.vehicle.image = document.createElement('div');
	$ui.addClass(object.dom.vehicle.image, 'vehicle-image');
	object.dom.vehicle.appendChild(object.dom.vehicle.image);
	object.dom.vehicle.overlay = document.createElement('div');
	$ui.addClass(object.dom.vehicle.overlay, 'vehicle-overlay');
	object.dom.vehicle.image.appendChild(object.dom.vehicle.overlay);
	
	// Create our user name
	object.dom.userName = document.createElement('div');
	$ui.addClass(object.dom.userName,'name');
	object.dom.vehicle.appendChild(object.dom.userName);
	
	// format a number for the stats box
	object._formatNumber = function(value) {
		if (value == undefined) return 0;
		var formattedValue,
			dividedValue;
		switch (true) {
			case (value >= 1000000):
				dividedValue = (value/1000000).toFixed(1);
				if ((dividedValue % 1) == 0) {
					dividedValue = Math.floor(dividedValue);	
				}
				formattedValue = dividedValue + 'M';
				break;
			case (value >= 10000):
				dividedValue = (value/1000).toFixed(1);
				if ((dividedValue % 1) == 0) {
					dividedValue = Math.floor(dividedValue);	
				}
				formattedValue = dividedValue + 'K';
				break;
			case (value >= 1000):
				formattedValue = value.toString();
				formattedValue = formattedValue.slice(0,1) + ',' + formattedValue.slice(1,formattedValue.length);
				break;
			case (value < 1000):
				formattedValue = value;
				break;
			default:
				formattedValue = value;
				break;
		}
			
		return formattedValue;
	}.$bind(object);
	
	// Add our stats box
	object.dom.stats = document.createElement('div');
	$ui.addClass(object.dom.stats, 'stats theme-profile-stats');
	object.dom.contentDiv.appendChild(object.dom.stats);
	
	// Add score box
	object.dom.score = document.createElement('div');
	$ui.addClass(object.dom.score, 'box');
	object.dom.stats.appendChild(object.dom.score);
	object.dom.score.label = document.createElement('div');
	$ui.addClass(object.dom.score.label, 'label theme-profile-label-text-color');
	object.dom.score.appendChild(object.dom.score.label);
	object.dom.score.label.textContent = 'SCORE';
	object.dom.score.number = document.createElement('div');
	$ui.addClass(object.dom.score.number, 'number theme-profile-number-color');
	object.dom.score.appendChild(object.dom.score.number);
	
	// Add friends box
	object.dom.friends = document.createElement('div');
	$ui.addClass(object.dom.friends, 'box');
	$ui.addClass(object.dom.friends, 'right');
	object.dom.stats.appendChild(object.dom.friends);
	object.dom.friends.label = document.createElement('div');
	$ui.addClass(object.dom.friends.label, 'label theme-profile-label-text-color');
	object.dom.friends.appendChild(object.dom.friends.label);
	object.dom.friends.label.textContent = 'FRIENDS';
	object.dom.friends.number = document.createElement('div');
	$ui.addClass(object.dom.friends.number, 'number theme-profile-number-color');
	object.dom.friends.appendChild(object.dom.friends.number);
	
	// Add clubs box
	object.dom.clubs = document.createElement('div');
	$ui.addClass(object.dom.clubs, 'box');
	$ui.addClass(object.dom.clubs, 'right');
	object.dom.stats.appendChild(object.dom.clubs);
	object.dom.clubs.label = document.createElement('div');
	$ui.addClass(object.dom.clubs.label, 'label theme-profile-label-text-color');
	object.dom.clubs.appendChild(object.dom.clubs.label);
	object.dom.clubs.label.textContent = 'CLUBS';
	object.dom.clubs.number = document.createElement('div');
	$ui.addClass(object.dom.clubs.number, 'number theme-profile-number-color');
	object.dom.clubs.appendChild(object.dom.clubs.number);
	
	// Create our avatar space
	object.dom.avatar = document.createElement('div');
	$ui.addClass(object.dom.avatar, 'avatar theme-profile-avatar');
	object.dom.contentDiv.appendChild(object.dom.avatar);
	
	// Add our rank text
	object.dom.rankText = document.createElement('div');
	$ui.addClass(object.dom.rankText, 'rank-text theme-profile-rank-text-color');
	object.dom.contentDiv.appendChild(object.dom.rankText);
	object.dom.rankText.textContent = 'Ranked';
	
	// Add our rank notification
	object.dom.rank = document.createElement('div');
	$ui.addClass(object.dom.rank, 'rank theme-profile-rank');
	object.dom.contentDiv.appendChild(object.dom.rank);
	
	// Add our find Friends button
	object.dom.findFriend = document.createElement('div');
	$ui.addClass(object.dom.findFriend, 'button');
	$ui.addClass(object.dom.findFriend, 'search');
	object.dom.findFriend.textContent = 'Find a Friend';
	object.dom.contentDiv.appendChild(object.dom.findFriend);
	
	// Add our find clubs button
	object.dom.findClub = document.createElement('div');
	$ui.addClass(object.dom.findClub, 'button');
	$ui.addClass(object.dom.findClub, 'plus');
	object.dom.findClub.textContent = 'Join a Club';
	object.dom.contentDiv.appendChild(object.dom.findClub);
	
	// Private function to handle provider updates
	object._providerUpdate = function(value) {
		// Assign our values
		if (value != undefined) {
			this.backgroundImg = value.backgroundImg;
			this.avatar = value.avatar;
			this.userName = value.userName;
			this.stats = value.stats;
		} else {
			this.backgroundImg = undefined;
			this.avatar = undefined;
			this.userName = undefined;
			this.stats = undefined;
		}
		// Load the vehicle
		if (this.backgroundImg) {
			this.loader = new Image();
			this.loader.model = this;
			// Change the opacity on load
			this.loader.onload = function() {
				this.model.dom.vehicle.image.style.opacity = '1.0';
				this.model.dom.vehicle.image.style.backgroundImage = 'url("'+ this.model.backgroundImg + '")';
				this.model.loader = null;
			}
			this.loader.src = this.backgroundImg;
		} else {
			this.dom.vehicle.image.style.backgroundImage = '';
		}
		// Set Username
		if (this.userName) {
			this.dom.userName.textContent = this.userName;
		} else {
			this.dom.userName.textContent = '';
		}
		// Set Stats
		if (this.stats) {
			this.dom.score.number.textContent = this._formatNumber(this.stats.score);
			this.dom.friends.number.textContent = this._formatNumber(this.stats.friends);
			this.dom.clubs.number.textContent = this._formatNumber(this.stats.clubs);
			this.dom.rank.textContent = this.stats.rank;
			this.dom.rank.style.opacity = '1.0';
		} else {
			this.dom.score.number.textContent = '0';
			this.dom.friends.number.textContent = '0';
			this.dom.clubs.number.textContent = '0';
			this.dom.rank.textContent = '1';
			this.dom.rank.style.opacity = '1.0';
		}
		// Set our avatar
		if (this.avatar) {
			this.dom.avatar.style.backgroundImage = 'url("'+ this.avatar + '")';
		}
		this.showContent(true);
	}.$bind(object);	
	
	// Load our control if no provider is connected
	if (object.provider == undefined) {
		object._providerUpdate({backgroundImg: object.backgroundImg, avatar: object.avatar, userName: object.userName, stats: object.stats})
	}
	
	return object.dom;
}
/**
 * Statistics for the user profile tile {@link $ui.TileProfile}
 * @namespace ProfileStats
 * @memberof $ui.TileProfile
 * @property {number} [friends] - The number of friends
 * @property {number} [clubs] - The number of clubs
 * @property {number} [score] - The overall point total for the user
 * @property {number} [rank] - The overall rank of the user among their friends and groups
 */
/**
 * The Record tile provides a button to start recording with optional countdown capability.
 * <br><br><b>Sample Declaration</b>
 * <pre>
 * {
 *    component: $ui.TileRecord,
 *    caption: 'Record 0-60 Time',
 *    countdown: true
 * }
 * </pre>
 * @namespace TileRecord
 * @memberof $ui
 * @extends $ui.CoreTile
 * @property {string} [caption] - This is the caption to show at the bottom of the tile
 * @property {boolean} [countdown=false] - This optional boolean property specifies if you wish to have a count down come after the user presses the start button. If set to true it will do a countdown from 3 before the <b>onrecord</b> event is triggered.
 * @property {GenericEvent} [onstartclick] - Fires when the user presses Start
 * @property {GenericEvent} [onrecord] - Fires when the recording begins
 * @property {GenericEvent} [onstopclick] - Fires when the user presses stop
 */
function $ui_TileRecord(object, screen) {
	// This tile is 1 x 1
	object._size = undefined;
	$ui_CoreTile.call(this, object, screen);
	$ui.addClass(object.dom,'ui-tile-record');
	
	// Create our stage 1 area
	object.dom.stage1 = document.createElement('div');
	$ui.addClass(object.dom.stage1,'stage-1');
	object.dom.contentDiv.appendChild(object.dom.stage1);
	
	// Create our record button
	object.dom.recordButton = document.createElement('div');
	object.dom.recordButton.model = object;
	$ui.addClass(object.dom.recordButton,'record-button theme-brand-background-color theme-brand-border-color');
	object.dom.stage1.appendChild(object.dom.recordButton);
	object.dom.recordButton.textContent = 'Start';
	object.dom.recordButton.onclick = function() {
		var model = this.model;
		if (model._protected.recording == true) {
			model.reset();
			if (model.onstopclick) {
				model.onstopclick();
			}
			return;
		} 
		$ui.playTouchSound();
		// Fire the start click
		if (model.onstartclick) {
			model.onstartclick();
		}
		// See if there is a countdown
		if (model.countdown === true) {
			model.dom.stage1.style.display = 'none';
			model.dom.stage2.style.display = 'inline';
			model._countDownNum = 3;
			model._interval = window.setInterval(model._countDownInterval, 1000);
			if (model.oncountdown) {
				model.oncountdown();
			}
			return;
		} 
		// Change button into recording mode
		this.textContent = 'Stop';
		this.style.backgroundColor = '';
		$ui.removeClass(this,'theme-brand-background-color');
		$ui.addClass(this,'theme-screen-background-color');
		model._protected.borderVisible = true;
		model._interval = window.setInterval(model._pulseInterval, 200);
		model._protected.recording = true;
		// Fire the recording if no countdown
		if (model.onrecord) {
			model.onrecord();
		}
	};
	object.dom.recordButton.ontouchstart = function() {
		this.style.opacity = '0.7';
	};
	object.dom.recordButton.ontouchend = function() {
		this.style.opacity = '1.0';
	};
	object.dom.recordButton.ontouchcancel = object.dom.recordButton.ontouchend;
	if (!$ui.isMobileDevice()) {
		object.dom.recordButton.onmousedown = object.dom.recordButton.ontouchstart;
		object.dom.recordButton.onmouseup = object.dom.recordButton.ontouchend;
		object.dom.recordButton.onmouseleave = object.dom.recordButton.ontouchend;
	}
	
	// Create our caption
	object.dom.captionDiv = document.createElement('div');
	$ui.addClass(object.dom.captionDiv,'caption');
	object.dom.stage1.appendChild(object.dom.captionDiv);
	if (object.caption) {
		object.dom.captionDiv.textContent = object.caption;
	}
	
	// Create our Stage 2 area
	object.dom.stage2 = document.createElement('div');
	$ui.addClass(object.dom.stage2,'stage-2');
	object.dom.contentDiv.appendChild(object.dom.stage2);
	
	// Add our stage 2 number
	object.dom.number = document.createElement('div');
	$ui.addClass(object.dom.number,'number');
	object.dom.stage2.appendChild(object.dom.number);
	object.dom.number.textContent = '3';
	
	// Private function to handle count down
	object._countDownInterval = function(value) {
		this._countDownNum--;
		if (this._countDownNum === 0) {
			window.clearInterval(this._interval);
			this._interval = undefined;
			this.dom.number.textContent = 'GO!';
			$ui.addClass(this.dom.number, 'theme-brand-background-color');
			$ui.addClass(this.dom.number,'animation');
			this._protected.recording = true;
			// Fire the onrecord event
			if (this.onrecord) {
				this.onrecord();
			}
			return;
		}
		this.dom.number.textContent = this._countDownNum;
		if (this.oncountdown) {
			this.oncountdown();
		}
	}.$bind(object);
	
	// Private function to handle stop pulse
	object._pulseInterval = function(value) {
		if (this._protected.borderVisible == true) {
			$ui.removeClass(this.dom.recordButton, 'theme-brand-border-color');
		} else {
			$ui.addClass(this.dom.recordButton, 'theme-brand-border-color');
		}
		this._protected.borderVisible = !this._protected.borderVisible;
	}.$bind(object);
	
	// Private function to handle clean-up
	object._providerUpdate = function(value) {
		if (this._interval != undefined) {
			window.clearInterval(this._interval);
			this._interval = undefined;
		}
	}.$bind(object);
	
	/**
	* Reset the tile to its original state
	* @function reset
	* @memberof $ui.TileRecord
	*/
	object.reset = function() {
		this._protected.recording = false;
		if (this._interval != undefined) {
			window.clearInterval(this._interval);
			this._interval = undefined;
		}
		this.dom.number.style.backgroundColor = '';
		this.dom.number.textContent = '3';
		$ui.removeClass(this.dom.number,'animation');
		this.dom.stage2.style.display = 'none';
		this.dom.stage1.style.display = '';
		this.dom.recordButton.textContent = 'Start';
		$ui.removeClass(this.dom.recordButton, 'theme-screen-background-color');
		$ui.addClass(this.dom.recordButton, 'theme-brand-background-color');
		$ui.addClass(this.dom.recordButton, 'theme-brand-border-color');
		
	}.$bind(object);
	
	return object.dom;
}

/**
 * The Time donut tile represents how close you reach a target number goal
 * <br><br><b>Sample Declaration</b>
 * <pre>
 * {
 *    component: $ui.TileTimeDonut,
 *    value: 3.8,
 *    target: 4.2,
 *    accent: 'Your Best Time'
 * }
 * </pre>
 * @namespace TileTimeDonut
 * @memberof $ui
 * @extends $ui.CoreTileDonutChart
 * @property {number} [value] - This number value represents the actual time achieved
 * @property {number} [target] - This number value represents the target time the driver is hoping to achieve.
 * @property {string} [caption] - This optional string value represents the text to appear to the left of the displayed value
 * @property {string} [accent] - This optional string value represents any extra accent text to display on the tile
 * @property {boolean} [targetHigh=false] - By default the time tile will compare the value to the target where the target is expected to be lower than the value.  By setting <b>targetHigh</b> to true, it will consider the target as higher than value.
 */
function $ui_TileTimeDonut(object, screen) {
	object._size = undefined;
	$ui_CoreTileDonutChart.call(this, object, screen);
	$ui.addClass(object.dom,'ui-tile-time-donut');
	
	// targetHigh Property
	if (object.targetHigh != true) {
		object.targetHigh = false;
	}
	object._protected.targetHigh = object.targetHigh;
	Object.defineProperty(object, 'targetHigh', {
		get: function() {return this._protected.targetHigh;},
		set: function() {
			console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','targetHigh'));
		},
		configurable: false}
	);
	
	// Figure out the data array for this chart
	object._calculateData = function() {
		var data;
		if (this.target != undefined && this.value != undefined) {
			var colorValue,
				percent;
			// Check for errors in data
			if (this.value < 0) this.value = 0;
			if (this.targetHigh == true) {
				if (this.value > this.target) {
					percent = 100;	
				} else {
					percent = Math.ceil((this.value / this.target)*100);
				}
			} else {
				if (this.value < this.target) {
					percent = 100;	
				} else {
					percent = Math.ceil((this.target / this.value)*100);
				}
			}			
			// Determine Color
			switch (true) {
				case (percent > 90):
					colorValue = $ui.theme.chart.color_GREAT;
					break;
				case (percent > 50):
					colorValue = $ui.theme.chart.color_GOOD;
					break;
				default:
					colorValue = $ui.theme.chart.color_OK;
					break;
			}
			// Create our chart data object
			data = [
				{
					value: percent,
					color: colorValue,
				},
				{
					value: (100-percent),
					color: $ui.theme.chart.color
				}
			];	
		} 
		return data;
	}
	object._calculateData = object._calculateData.$bind(object);
	

	// Private function to handle provider updates
	object._providerUpdate = function(value) {
		if (value != undefined) {
			this.value = value.value;
			this.target = value.target;
			this.accent = value.accent;
			this.caption = (value.caption == undefined) ? '' : value.caption;
		} else {
			this.value = 0;
			this.target = 0;
			this.accent = undefined;
			this.caption = '';
		}
		// Populate our chart with data
		var data = this._calculateData();
		if (data != undefined) {
			this._setData(data);
			this._setCaption('<span class="tall">'+this.value + '</span>&nbsp;'+ this.caption);
			this._setAccent(this.accent);
		}
		this.showContent(true);
	}.$bind(object);	
	
	// Handle theme changes
	object._onthemechange = function() {
		// Repaint the control
		this._providerUpdate(this);
	}.$bind(object);
	
	// Load our control if no provider is connected
	if (object.provider == undefined) {
		object._providerUpdate(object);
	}
	
	return object.dom;
}
/**
 * The Time History tile represents past recorded times.
 * <br><br><b>Sample Declaration</b>
 * <pre>
 * {
 *    component: $ui.TileTimeHistory,
 *    labels: ['Apr 10/14','May 12/14','Jul 18/14','Aug 22/14'],
 *    data: [5.2,6.3,4.2,4.5],
 *    caption: 'Recorded 0-60 times (sec)'
 * }
 * </pre>
 * @namespace TileTimeHistory
 * @memberof $ui
 * @extends $ui.CoreTile
 * @property {number[]} [data] - This array of numbers represents the time values
 * @property {string[]} [labels] - This array of strings represents the labels for the times. These labels are typically logging dates.
 * @property {string} [caption] - This optional string value represents the text caption you wish to include
 */
function $ui_TileTimeHistory(object, screen) {
	// Set our default animation
	if (object.animated == undefined) {
		object.animated = true;
	}
	// This tile is 2 x 1
	object._size = $ui.TileSize.WIDE;
	$ui_CoreTile.call(this, object, screen);
	$ui.addClass(object.dom,'ui-tile-time-history');
	
	// Create the caption area
	object.dom.caption = document.createElement('div');
	$ui.addClass(object.dom.caption,'caption');
	object.dom.contentDiv.appendChild(object.dom.caption);
	
	// Create our chart area
	object.dom.canvas = document.createElement('canvas');
	$ui.addClass(object.dom.canvas, 'chart');
	object.dom.canvas.height = 190;
	//object.dom.canvas.width = 490;
	object.dom.contentDiv.appendChild(object.dom.canvas);
	
	// Private function to handle provider updates
	object._providerUpdate = function(value) {
		if (this.dom.offsetWidth) {
			this.dom.canvas.width = this.dom.offsetWidth - 10;
			this.dom.ctx = this.dom.canvas.getContext('2d');
			this.dom.chart = new Chart(this.dom.ctx);
		}
		if (this.dom.chart == undefined) return;
		// Assign our values
		if (value != undefined) {
			this.data = value.data;
			this.labels = value.labels
			this.caption = (value.caption == undefined) ? '' : value.caption;
		} else {
			this.data = undefined;
			this.labels = undefined;
		}
		this.dom.caption.textContent = this.caption;
		// Get our root color
		var RGB = $ui.hexToRgb($ui.theme.chart.color_OK);
		// Load our data
		var data = {
			labels: this.labels,
			datasets: [
				{
					fillColor: 'rgba('+RGB.R+','+RGB.G+','+RGB.B+',0.5)',
					strokeColor: 'rgba('+RGB.R+','+RGB.G+','+RGB.B+',1)',
					data: this.data
				}
			]
		}
		this.dom.chart.Line(data,{scaleShowGridLines: true,showTooltips: false, animation: this.animated, scaleFontColor: window.getComputedStyle(this.dom).color});
		this.showContent(true);
	}.$bind(object);	
	
	// Handle theme changes
	object._onthemechange = function() {
		// Repaint the control
		this._providerUpdate(this);
	}.$bind(object);
	
	// Load our control if no provider is connected
	object._onshow = function() {
		if (this.provider == undefined) {
			this._providerUpdate(this);
		}
	}
	
	return object.dom;
}
/**
 * The Timer tile provides a stop watch timer. <b>NOTE: Currently there is a 60 minute limit for the timer</b>
 * <br><br><b>Sample Declaration</b>
 * <pre>
 * {
 *    component: $ui.TileTimer
 * }
 * </pre>
 * @namespace TileTimer
 * @memberof $ui
 * @extends $ui.CoreTile
 * @property {GenericEvent} [onstart] - This event fires when the timer starts
 * @property {GenericEvent} [onstop] - This event fires when the timer stops
 * @property {GenericEvent} [onreset] - This event fires when the timer has been reset
 */
function $ui_TileTimer(object, screen) {
	// This tile is 1 x 2
	object._size = $ui.TileSize.WIDE;
	$ui_CoreTile.call(this, object, screen);
	$ui.addClass(object.dom,'ui-tile-timer');
	
	// Add our numbers area
	object.dom.numbers = document.createElement('div');
	$ui.addClass(object.dom.numbers,'numbers');
	object.dom.contentDiv.appendChild(object.dom.numbers);
	object.dom.numbers.textContent = '00:00:00';
	
	// Private function to handle the interval
	object._doInterval = function() {
		var now = new Date();
		this._milliseconds = now - this._startTime;
		var minutes = Math.floor(this._milliseconds/60000),
			seconds = Math.floor(this._milliseconds/1000) % 60,
			tenths;
		// Calculate our tenths
		tenths = (this._milliseconds/1000).toFixed(2) - Math.floor(this._milliseconds/1000);
		tenths = Math.floor(tenths * 100);	
		tenths = (tenths >= 100) ? 0 : tenths;
		// Format leading zeros
		minutes = (minutes >= 10) ? minutes : '0'+ minutes;
		seconds = (seconds >= 10) ? seconds : '0'+ seconds;
		tenths = (tenths >= 10) ? tenths : '0'+ tenths;
		// Set our text
		object.dom.numbers.textContent = minutes + ':'+seconds+':'+tenths;	
	}.$bind(object);
	
	/**
	* This function will reset the timer and trigger the <b>onreset</b> event
	* @function reset
	* @memberof $ui.TileTimer
	*/
	object.reset = function() {
		if (this._interval != undefined) {
			window.clearInterval(this._interval);
			this._milliseconds = 0;
			this._interval = undefined;
		}
		this.dom.numbers.textContent = '00:00:00';
		if (this.onreset) {
			this.onreset();
		}
	}.$bind(object);
	
	/**
	* This function will start the timer and trigger the <b>onstart</b> event
	* @function start
	* @memberof $ui.TileTimer
	*/
	object.start = function() {
		if (this._interval != undefined) return; // Already running
		this._startTime = new Date();
		this._milliseconds = 0;
		this._interval = window.setInterval(this._doInterval,10);
		if (this.onstart) {
			this.onstart();
		}
	}.$bind(object);
	
	/**
	* This function will stop the timer and trigger the <b>onstop</b> event
	* @function stop
	* @memberof $ui.TileTimer
	*/
	object.stop = function() {
		if (this._interval != undefined) {
			window.clearInterval(this._interval);
			this._doInterval();
			this._interval = undefined;
			if (this.onstop) {
				this.onstop();
			}
		}
	}.$bind(object);
	
	/**
	* Retrieve the timer's value in Milliseconds
	* @function getMilliseconds
	* @memberof $ui.TileTimer
	*/
	object.getMilliseconds = function() {
		return this._milliseconds;
	}.$bind(object);
	
	/**
	* Retrieve the timer's value in Seconds
	* @function getSeconds
	* @memberof $ui.TileTimer
	*/
	object.getSeconds = function() {
		return (this._milliseconds/1000).toFixed(2);
	}.$bind(object);
	
	/**
	* Retrieve the timer's value in Minutes
	* @function getMinutes
	* @memberof $ui.TileTimer
	*/
	object.getMinutes = function() {
		return (this._milliseconds/60000).toFixed(2);
	}.$bind(object);
	
	// Private function to clean up
	object._destroy = function() {
		if (this._interval != undefined) {
			window.clearInterval(this._interval);
			this._interval = undefined;
		}
	}.$bind(object);
	
	// Stop the timer if the screen is about to pop
	object._onbeforepop = function() {
		this.stop();
	}.$bind(object);
	
	return object.dom;
}

/**
 * This function will provide a temporary pop up message to display to the user 
 * @function toast
 * @memberof $ui
 * @param {string} message - The message to display to the user
 * @param {number} [duration=2500] - Optional parameter to specify the duration of the toast
 */
$ui.toast = function(message, duration){
	var element = document.createElement('div');
	$ui.addClass(element,'ui-toast theme-brand-border-color');
	element.textContent = message;
	document.body.appendChild(element);
	// Set our default
	if (duration == undefined) {
		duration = 2500;
	}
	
	// Handle the end of the toast and do our clean-up
	element._ondisappear = function() {
		this.removeEventListener('webkitAnimationEnd', this._ondisappear);
		this.parentNode.removeChild(this);
	}.$bind(element);
	
	// Handle the showing of the toast
	element._onappear = function() {
		this.removeEventListener('webkitAnimationEnd', this._onappear);
		this.addEventListener('webkitAnimationEnd', this._ondisappear);
		var target = this;
		window.setTimeout(function() {
			target.style['-webkit-animation-name'] = 'ui-toast-disappear';
		},duration);
	}.$bind(element);
	
	element.addEventListener('webkitAnimationEnd', element._onappear);
}
/**
 * The ActiveCallScreen represents an incoming or outgoing call.
 * @namespace ActiveCallScreen
 * @memberof $ui
 * @extends $ui.CoreScreen
 * @property {string} [img] - Background photo for the contact you are calling
 * @property {string} [name] - The person's name who is in the active call
 * @property {string} [number] - The number of the active call
 * @property {string} [iconIncomingCall] - Path to the incoming call icon
 * @property {string} [iconHangUp] - Path to the hang up icon
 * @property {GenericEvent} [onhangup] - Fires when the user hangs up the call
 */
function emulator_ActiveCallScreen(object, data) {
	// Default disable some core screen features
	if (object) {
		object.animated = false;
		object.background = undefined;
	}
	$ui_CoreScreen.call(this, object, data);
	
	if (object) {
		$ui.addClass(object.dom,'emulator-active-call-screen theme-screen-background-color');
		
		// Create our background contact photo
		object.dom.photo = document.createElement('div');
		$ui.addClass(object.dom.photo, 'photo');
		object.dom.appendChild(object.dom.photo);
		object.dom.photo.loader = new Image();
		object.dom.photo.loader.model = object;
		object.dom.photo.loader.onload = function() {
			this.model.dom.photo.style.opacity = 1;
			this.model.dom.photo.style.backgroundImage = 'url("'+this.src+'")';
			var photo = this.model.dom.photo;
			window.setTimeout(function() {
				photo.style['-webkit-transform'] = 'translate3d(-100px,100px,0)';
			},700);
		};
		
		// Create our caller information area
		object.dom.info = document.createElement('div');
		$ui.addClass(object.dom.info, 'info');
		object.dom.appendChild(object.dom.info);
		// Name
		object.dom.nameDiv = document.createElement('div');
		$ui.addClass(object.dom.nameDiv, 'name theme-highlight-text-color');
		object.dom.info.appendChild(object.dom.nameDiv);
		// Number
		object.dom.numberDiv = document.createElement('div');
		$ui.addClass(object.dom.numberDiv, 'number theme-highlight-text-color');
		object.dom.info.appendChild(object.dom.numberDiv);
		
		// Top Wedge
		object.dom.topWedge = document.createElement('div');
		$ui.addClass(object.dom.topWedge, 'top-wedge theme-brand-background-color');
		object.dom.appendChild(object.dom.topWedge);
		object._topWedgeAnimationEnd = function() {
			this.dom.topWedge.removeEventListener('webkitAnimationEnd', this._topWedgeAnimationEnd); 
			this.dom.hangUp.style.opacity = 1;
		}.$bind(object);
		object.dom.topWedge.addEventListener('webkitAnimationEnd', object._topWedgeAnimationEnd, false); 
		
		// Hang-up button
		object.dom.hangUp = document.createElement('div');
		$ui.addClass(object.dom.hangUp, 'hang-up theme-brand-background-color');
		object.dom.appendChild(object.dom.hangUp);
		object.dom.hangUp.circle = document.createElement('div');
		$ui.addClass(object.dom.hangUp.circle, 'circle theme-border-color');
		object.dom.hangUp.circle.model = object;
		// Handle our back click
		object.dom.hangUp.circle.onclick = function() {
			$ui.playTouchSound();
			if (this.model.onhangup) {
				this.model.onhangup();
			}
		};
		object.dom.hangUp.circle.onmousedown = function() {
			this.style.backgroundColor = 'rgba(0,0,0,0.3)';
		}
		object.dom.hangUp.circle.onmouseup = function() {
			this.style.backgroundColor = '';
		};
		
		object.dom.hangUp.appendChild(object.dom.hangUp.circle);
		object.dom.hangUp.label = document.createElement('div');
		$ui.addClass(object.dom.hangUp.label, 'label theme-text-color');
		object.dom.hangUp.appendChild(object.dom.hangUp.label);
		object.dom.hangUp.label.textContent = 'Hang Up';
		
		// Phone Animation
		object.dom.phone = document.createElement('div');
		$ui.addClass(object.dom.phone, 'phone-animation');
		object.dom.appendChild(object.dom.phone);
		
		// iconIncomingCall Property
		if (object.iconIncomingCall != undefined) {
			object.dom.phone.style.backgroundImage = 'url("' + object.iconIncomingCall + '")';	
		} 
		object._protected.iconIncomingCall = object.iconIncomingCall;
		Object.defineProperty(object, 'iconIncomingCall', {
			get: function() {return this._protected.iconIncomingCall;},
			set: function(value) {
				if (value == this._protected.iconIncomingCall) return;
				if (value == undefined) value = '';
				this.dom.phone.style.backgroundImage = 'url("' + value + '")';	
				this._protected.iconIncomingCall = value;
			},
			configurable: false}
		);
		
		// iconHangUp Property
		if (object.iconHangUp != undefined) {
			object.dom.hangUp.circle.style.backgroundImage = 'url("' + object.iconHangUp + '")';	
		} 
		object._protected.iconHangUp = object.iconHangUp;
		Object.defineProperty(object, 'iconHangUp', {
			get: function() {return this._protected.iconHangUp;},
			set: function(value) {
				if (value == this._protected.iconHangUp) return;
				if (value == undefined) value = '';
				this.dom.hangUp.circle.style.backgroundImage = 'url("' + value + '")';	
				this._protected.iconHangUp = value;
			},
			configurable: false}
		);
		
		// name Property
		if (object.name != undefined) {
			object.dom.nameDiv.textContent = object.name;	
		} 
		object._protected.name = object.name;
		Object.defineProperty(object, 'name', {
			get: function() {return this._protected.name;},
			set: function(value) {
				if (value == this._protected.name) return;
				if (value == undefined) value = '';
				this.dom.nameDiv.textContent = value;
				this._protected.name = value;
			},
			configurable: false}
		);
		
		// number Property
		if (object.number != undefined) {
			object.dom.numberDiv.textContent = object.number;	
		} 
		object._protected.number = object.number;
		Object.defineProperty(object, 'number', {
			get: function() {return this._protected.number;},
			set: function(value) {
				if (value == this._protected.number) return;
				if (value == undefined) value = '';
				this.dom.numberDiv.textContent = value;
				this._protected.number = value;
			},
			configurable: false}
		);
		
		// img Property
		if (object.img != undefined) {
			object.dom.photo.loader.src = object.img;	
		} 
		object._protected.img = object.img;
		Object.defineProperty(object, 'img', {
			get: function() {return this._protected.img;},
			set: function(value) {
				if (value == this._protected.img) return;
				if (value == undefined) value = '';
				this._protected.img = value;
				this.dom.photo.style.opacity = 0;
				this.dom.photo.loader.src = value;
			},
			configurable: false}
		);
		
		return object.dom;
	}
}


/**
 * The App Container is a window that is used for opening up an application in an iFrame in the emulator. This is mainly an internal class that is used by the Head Unit to open up a new app.
 * <br><br><b>Sample Declaration</b>
 * <pre>
 * function myAppContainer() {
 *   this.component = $ui.AppContainer;
 *   this.src = 'http://someurl';
 *}
 * </pre>
 * @namespace AppContainer
 * @memberof $ui
 * @extends $ui.CoreScreen
 * @property {string} src - This is the URL path to the application that will be opened in the inner iFrame
 */
function emulator_AppContainer(object, data) {
	$ui_CoreScreen.call(this, object, data);
	
	if (object) {
		$ui.addClass(object.dom,'emulator-app-container theme-screen-background-color');
		object._protected.firstLoad = true;
		
		// Set the width
		object.dom.style.width = (object.width == undefined) ? window.innerWidth + 'px' : object.width + 'px';

		// Create our content div for the controls
		object.dom.contentDiv = document.createElement('div');
		$ui.addClass(object.dom.contentDiv, 'inner');
		object.dom.appendChild(object.dom.contentDiv);
		if (object.iconSplash) {
			object.dom.contentDiv.style.backgroundImage = 'url("' + object.iconSplash + '")';
		}
		
		// Delay the visibilty so we don't get a white flash
		object._delayedVisibility = function() {
			this.dom.contentWindow.style.visibility = 'visible';
			this.dom.contentWindow.style.height = '100%'; // NOTE: This is a a hack to solve an iframe issue in webkit. Otherwise it will not scroll
		}
		object._delayedVisibility = object._delayedVisibility.$bind(object);
		
		// Make the content area visible on load
		object._contentWindowLoad = function(screen, data) {
			// onload triggers twice.. we want the second load
			if (this._protected.firstLoad) {
				this._protected.firstLoad = false;
				return;
			}
			setTimeout(this._delayedVisibility, 500);
		}
		object._contentWindowLoad = object._contentWindowLoad.$bind(object);
		
		// Create our contentWindow for the app
		object.dom.contentWindow = document.createElement('iframe');
		$ui.addClass(object.dom.contentWindow, 'window theme-screen-background-color');
		object.dom.contentDiv.appendChild(object.dom.contentWindow);
		object.dom.contentWindow.onload = object._contentWindowLoad;
		
		// This function fires when this App Container has been successfully displayed
		object._initialize = function(screen, data) {
			this.dom.contentWindow.src = this.src;
		}
		object._initialize = object._initialize.$bind(object);

		// Handle resizes
		object._onresize = function(){
			this.dom.style.width = window.innerWidth + 'px';
		}
		object._onresize = object._onresize.$bind(object);
		return object.dom;
	}
}
/**
 * This is the object that represents the main Chrome App framework
 * @namespace ChromeApp
 * @memberof $ui
 * @extends $ui.CoreScreen
 */
function emulator_ChromeApp(object, data) {
	var SIZE_STORAGE_KEY = "brainiac_emulator_chromeapp_lastsize";
	$ui_CoreScreen.call(this, object);
	if (object) {
		$ui.addClass(object.dom,'emulator-chrome-app theme-screen-background-color');
		object._protected.size = '800x1280';
		object._protected.lastSize = null;
		
		// Create our titlebar area
		object.titleBar = {parent: object};
	 	new emulator_TitleBar(object.titleBar, object);
		object.dom.appendChild(object.titleBar.dom);
		
		// Create our main body area
		object.dom.contentDiv = document.createElement('div');
		$ui.addClass(object.dom.contentDiv,'content');
		object.dom.appendChild(object.dom.contentDiv);

		// Create our viewer area
		object.dom.viewer = document.createElement('div');
		$ui.addClass(object.dom.viewer, 'viewer theme-dark-border-color size800x1280');
		object.dom.viewer.setAttribute('src', 'index.html');
		object.dom.contentDiv.appendChild(object.dom.viewer);

		// Create our iframe
		object.dom.iframe = document.createElement('iframe');
		object.dom.iframe.model = object;
		object.dom.iframe.setAttribute('src', 'index.html');
		object.dom.viewer.appendChild(object.dom.iframe);
		object.dom.iframe.onload = function() {
			this.style.visibility = 'visible';
		}

		// Private function to get the resolution of the frame (used by the buttons)
		object._getResolution = function() {
			return this._protected.size;
		}.$bind(object);

		// Private function to set the resolution of the frame
		object._setResolution = function(size) {
			if (size == this._protected.size) return;
			// Remove old class
			$ui.removeClass(this.dom.viewer,'size' + this._protected.size);
			this.dom.iframe.style.visibility = 'hidden';
			this._protected.size = size;
			var sourcePage = 'index.html';
			// Set our sizes
			if (size == '1024x600') {
				$ui.addClass(this.dom.viewer,'size1024x600');
			} else if (size == '1280x800') {
				$ui.addClass(this.dom.viewer,'size1280x800');
			} else if (size == '375x667') {
				$ui.addClass(this.dom.viewer,'size375x667');
				sourcePage = 'mobile.html';
			} else {
				$ui.addClass(this.dom.viewer,'size800x1280');
			}
			// Store the size.
			var toSet = {};
			toSet[SIZE_STORAGE_KEY] = size;
			chrome.storage.local.set(toSet);
			this._scaleViewer();
			this.dom.iframe.src = sourcePage;
			this.titleBar.highlightButtons();
		}.$bind(object);
		
		// Handle scaling
		object._scaleViewer = function() {
			var titleBarHeight = this.titleBar.dom.offsetHeight,
				neededWidth,
				actualWidth = window.innerWidth,
				neededHeight,
				actualHeight = window.innerHeight - titleBarHeight,
				border = 6;
			if (this._protected.size == '1024x600') {
				neededWidth = 1024 + border;
				neededHeight = 600 + border + titleBarHeight;
			} else if (this._protected.size == '1280x800') {
				neededWidth = 1280 + border;
				neededHeight = 800 + border + titleBarHeight;
			} else if (this._protected.size == '375x667') {
				neededWidth = 375 + border;
				neededHeight = 667 + border + titleBarHeight;
			} else {
				neededHeight = 1280 + border + titleBarHeight; 
				neededWidth = 800 + border;
			}
			
			var byWidth = actualWidth / neededWidth;
			var byHeight = actualHeight / neededHeight;
			
			var scale = Math.min(byWidth,byHeight);
			if (scale < 1) {
				this.dom.viewer.style['-webkit-transform'] = 'scale('+scale+','+ scale+')';
			} else {
				this.dom.viewer.style['-webkit-transform'] = '';
			}
		}.$bind(object);
		
		// Handle window resize events
		window.addEventListener('resize',object._scaleViewer);
		
		// Recalculate the viewer when the screen shows
		object._initialize = function() {
			if (this._protected.lastSize == null) {
				chrome.storage.local.get(SIZE_STORAGE_KEY,function(values) {
					var lastSize = values[SIZE_STORAGE_KEY];
					if (lastSize && lastSize !== object._protected.size) {
						object._setResolution(lastSize);
					} else {
						object._protected.lastSize = "not found";
						object._scaleViewer();
					}
				});
			} else {
				this._scaleViewer();
			}
		}.$bind(object);

		return object.dom;
	}
}
/**
 * The CoreWedgeScreen represents the base abstract object for any wedge screen.
 * <b>NOTE: This is an abstract class and should not be declared</b>
 * @namespace CoreWedgeScreen
 * @memberof $ui
 * @extends $ui.CoreScreen
 * @property {string} [backButton] - This optional object specifies details for the back button. If it is not specified a back arrow and the word "Back" will be used. The object definition for this property looks like the following:
 * <pre>
 * {
 *    icon: 'my-icon-class', // CSS class specifying the background icon
 *    caption: 'Done' // Text to show on the back button
 *}
 */
function emulator_CoreWedgeScreen(object, data) {
	// Default disable some core screen features
	if (object) {
		object.disableAnimation = true;
		object.background = undefined;
		object.floatOnTop = true;
	}
	$ui_CoreScreen.call(this, object, data);
	
	if (object) {
		$ui.addClass(object.dom,'emulator-core-wedge-screen');
		object.dom.style.backgroundColor = 'transparent';
		
		if (window.innerHeight > window.innerWidth) {
			$ui.addClass(object.dom,'portrait');
		}
		
		if (object.direction == undefined) {
			object.direction = 'left';
		}
		
		if (object.direction == 'right') {
			object._isRightToLeft = true;
		} else {
			object._isRightToLeft = false;
		}
		
		// Create our wedge
		object.dom.wedge = document.createElement('div');
		$ui.addClass(object.dom.wedge, 'wedge theme-brand-background-color');
		object.dom.appendChild(object.dom.wedge);
		
		// Set our wedge dimensions and angle
		var wedgeWidth = (window.innerWidth > window.innerHeight) ? Math.floor(window.innerWidth/3) : Math.floor(window.innerHeight/3),
			buttonWidth = Math.floor(wedgeWidth/2),
			buttonBottom = 20,
			opposite = window.innerHeight,
		    adjacent = window.innerWidth,
			hypotenuse = Math.sqrt(Math.pow(opposite,2) + Math.pow(adjacent,2)),
			degrees = 90 - Math.asin(opposite/hypotenuse)*(180/Math.PI);
		object._degrees	= degrees;
		// Set our wedge values
		object.dom.wedge.style.width = wedgeWidth + 'px';
		if (object._isRightToLeft == true) {
			degrees = '-' + degrees;
			object.dom.wedge.style.right = (window.innerWidth > window.innerHeight) ? Math.floor(wedgeWidth/2) + 'px' : '-'+Math.floor(wedgeWidth/1.5) + 'px';
		} else {
			object.dom.wedge.style.left = (window.innerWidth > window.innerHeight) ? Math.floor(wedgeWidth/2) + 'px' : '-'+Math.floor(wedgeWidth/1.5) + 'px';
		}
		object.dom.wedge.style['-webkit-transform'] = 'rotate('+degrees+'deg)';
		
		// Create our back button
		object.dom.back = document.createElement('div');
		$ui.addClass(object.dom.back,'back theme-border-color');
		object.dom.appendChild(object.dom.back);
		object.dom.back.style.bottom = '-' + buttonWidth + 'px';
		object.dom.back.style.width = buttonWidth + 'px';
		object.dom.back.style.height = buttonWidth + 'px';
		object.dom.back.style.borderRadius = (Math.floor(buttonWidth/2) + 1) + 'px';
		object.dom.back.textDiv = document.createElement('div');
		$ui.addClass(object.dom.back.textDiv, 'back-text theme-highlight-text-color');
		object.dom.back.appendChild(object.dom.back.textDiv);
		if (object._isRightToLeft == true) {
			if ($system && ($system.isClientDevice == true)) {
				object.dom.back.style.right = '10px';
			} else {
				object.dom.back.style.right = (window.innerWidth > window.innerHeight) ? Math.floor(buttonWidth/3)+ 'px' : '20px';
			}
			$ui.addClass(object.dom.back.textDiv,'right-to-left');
		} else {
			if ($system && ($system.isClientDevice == true)) {
				object.dom.back.style.left = '10px';
			} else {
				object.dom.back.style.left = (window.innerWidth > window.innerHeight) ? Math.floor(buttonWidth/3)+ 'px' : '20px';
			}
		}
		
		// See if we have back button customization
		if (object.backButton && object.backButton.caption) {
				object.dom.back.textDiv.textContent = object.backButton.caption;
		} else {
			object.dom.back.textDiv.textContent = 'Back';
		}
		if (object.backButton && object.backButton.icon) {
			object.dom.back.style.backgroundImage = 'url("'+ object.backButton.icon+'")';
		} else {
			$ui.addClass(object.dom.back,'emulator-icon-back-white');
		}
		
		// Handle our back click
		object.dom.back.onclick = function() {
			$ui.playTouchSound();
			$ui.pop();
		}
		object.dom.back.ontouchstart = function() {
			this.style.backgroundColor = 'rgba(0,0,0,0.3)';
		}
		object.dom.back.ontouchend = function() {
			this.style.backgroundColor = '';
		}
		object.dom.back.ontouchcancel = object.dom.back.ontouchend;
		if (!$ui.isMobileDevice()) {
			object.dom.back.onmousedown = object.dom.back.ontouchstart;
			object.dom.back.onmouseup = object.dom.back.ontouchend;
			object.dom.back.onmouseleave = object.dom.back.ontouchend;
		}
		
		// Trigger our animations
		window.setTimeout(function() {object.dom.wedge.style.opacity = '1.0';},0);
		window.setTimeout(function() { 
			object.dom.back.style['-webkit-transform'] = 'translateY(-'+(buttonWidth + buttonBottom) + 'px)';
			object.dom.back.addEventListener('webkitTransitionEnd', function(e) {
					this.textDiv.style.opacity = '1.0';
				}, false);
		},200);
		
		
		return object.dom;
	}
}
/**
 * This is the object that represents the main chrome menu system for a Head Unit. A HeadUnitChrome is declared as a JavaScript function and has various different properties. 
 * When a HeadUnitChrome is pushed onto the stack a new instance of the screen will be created and rendered.
 * <br><br><b>Sample Declaration</b>
 * <pre>
 * function MyChrome() {
 *   this.disableAnimation = true;
 *   this.component = $ui.HeadUnitChrome;
 *   this.home = myHomePane;
 *}
 * </pre>
 * @namespace HeadUnitChrome
 * @memberof $ui
 * @extends $ui.CoreScreen
 * @property {$ui.HVAC} [hvac] - This represents the HVAC controls that are shown in the emulator.
 * @property {$ui.WindowPane} primaryWindow - This property represents the {@link $ui.Window} that displays the main content
 * @property {$ui.WindowPane} secondaryWindow - This property represents the {@link $ui.Window} you wish to use as the secondary display. This area will only be visible if <b>isDualView()</b> evaluates to true
 * @property {GenericEvent} [onsettingsclick] - Fires when the user selects the settings button
 */
function emulator_HeadUnitChrome(object, data) {
	$ui_CoreScreen.call(this, object);
	
	if (object) {
		$ui.addClass(object.dom,'emulator-head-unit-chrome');

		/**
		* This readonly boolean property will return true if the view has two different viewable Window areas creating a stacked display.
		* @name isDualView
		* @type {boolean}
		* @readonly
		* @memberof $ui.HeadUnitChrome
		*/
		object.isDualView = (window.innerHeight > window.innerWidth) && ($system.isClientDevice == false);
		if (object.isDualView == true || $system.isClientDevice == true) {
			$ui.addClass(object.dom,'portrait');
		}
		
		// Recalculate the layout of the different views
		object._recalculateLayout = function() {			
			// Make adjustments for HVAC
			if (this.hvac) {
				if (this.hvac.visible == true) {
					if ((this.isDualView == false) || ($system.isClientDevice == true)) {
						this.primaryWindow.dom.style.bottom = this.hvac._getHeight()+'px';
						this.primaryWindow.dom.style.height = 'inherit';
					} else if (this.secondaryWindow) {
						this.secondaryWindow.dom.style.bottom = this.hvac._getHeight()+'px';
					}
				}
			} 
		}
		object._recalculateLayout = object._recalculateLayout.$bind(object);
		
		// Create our primary window area
		if (object.primaryWindow == undefined) {
			object.primaryWindow = {};
		}
		object.primaryWindow.secondary = false;
		object.primaryWindow.parent = object;
		var dom = new emulator_Window(object.primaryWindow,object);
		$ui.addClass(dom,'primary theme-brand-border-color');
		object.dom.appendChild(dom);
		
		
		// Create our secondary view area
		if ((object.secondaryWindow == undefined) || (object.isDualView == false)) {
			object.secondaryWindow = {};
		}
		object.secondaryWindow.secondary = true;
		object.secondaryWindow.parent = object;
		dom = new emulator_Window(object.secondaryWindow,object);
		$ui.addClass(dom,'secondary');
		object.dom.appendChild(dom);
		
		
		// Create our navigation bar
		object._navigation = {};
		object._navigation._chrome = object;
		dom = new emulator_NavigationBar(object._navigation,object);
		object.dom.appendChild(dom);

		// See if we have HVAC
		if (object.hvac) {
			dom = new emulator_HVACBar(object.hvac,object);
			object.dom.appendChild(dom);
		}
	
		// Assign the middle navigation menu to the window pane provided
		object._setNavigationMenu = object._navigation._setNavigationMenu;
		
		return object.dom;
	}
}
function emulator_DefrostButton(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom,'defrost-button theme-brand-background-color');
	$ui.addClass(object.dom,'off');
	
	object.dom.onclick = function() {
		$ui.playTouchSound();
		/*if (this.model.onclick) {
			this.model.onclick();
		}*/
	}
	object.dom.ontouchstart = function() {
		$ui.addClass(this,'selected');
	}
	object.dom.ontouchend = function() {
		$ui.removeClass(this,'selected');
	}
	object.dom.ontouchcancel = object.dom.ontouchend;
	if (!$ui.isMobileDevice()) {
		object.dom.onmousedown = object.dom.ontouchstart;
		object.dom.onmouseup = object.dom.ontouchend;
		object.dom.onmouseleave = object.dom.ontouchend;
	}
	
	return object.dom;
}
/**
 * This core component draws circle toggle buttons on the screen that
 * allow tweaking the HVAC settings. It is not likely to be used directly.
 * @namespace FanDirectionControl
 * @memberof $ui
 * @extends $ui.CoreComponent
 */
function emulator_FanDirectionControl(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom, 'ui-fan-direction-control');

	object._private = {};
	object._private.direction = {};

	function uiButton(classes, onclick, alwaysEnabled) {
		var toReturn = document.createElement("div");
		toReturn.onclick = onclick;
		for (var i = 0; i < classes.length; ++i) {
			$ui.addClass(toReturn, classes[i]);
		}
		setEvents(toReturn,alwaysEnabled);
		return toReturn;
	}

	function touchStart() {
		if (object._private.direction.enabled) {
			$ui.playTouchSound();
			this.style.opacity = "0.7";
		}
	}

	function touchStartAlways() {
		$ui.playTouchSound();
		this.style.opacity = "0.7";
	}

	function touchEnd() {
		this.style.opacity = "";
	}

	function setEvents(o,alwaysEnabled) {
		o.ontouchstart = alwaysEnabled ? touchStartAlways : touchStart;
		o.ontouchend = touchEnd;
		o.ontouchcancel = touchEnd;
		if (!$ui.isMobileDevice()) {
			o.onmousedown = o.ontouchstart;
			o.onmouseup = o.ontouchend;
			o.onmouseleave = o.ontouchcancel;
		}
	}


	object._private.toggleFace = function () {
		var direction = this._private.direction;
		if (!direction.enabled) {
			return;
		}
		if (direction.face && !direction.feet && !direction.frontDemist) {
			// ignore - this would disable ALL directions...
		} else {
			direction.face = !direction.face;
			if (direction.face) {
				direction.frontDemist = false;
			}
			$system.hvac.fanDirection = direction;
		}
	}.$bind(object);

	object._private.toggleFeet = function () {
		var direction = this._private.direction;
		if (!direction.enabled) {
			return;
		}
		if (direction.feet && !direction.face && !direction.frontDemist) {
			// ignore - this would disable ALL directions.
		} else {
			direction.feet = !direction.feet;
			$system.hvac.fanDirection = direction;
		}
	}.$bind(object);

	object._private.toggleFrontDemist = function () {
		var direction = this._private.direction;
		if (!direction.enabled) {
			return;
		}
		if (direction.frontDemist && !direction.face && !direction.feet) {
			// ignore - this would disable ALL directions.
		} else {
			direction.frontDemist = !direction.frontDemist;
			if (direction.frontDemist) {
				direction.face = false;
			}
			$system.hvac.fanDirection = direction;
		}
	}.$bind(object);

	object._private.toggleRearDemist = function () {
		var direction = this._private.direction;
		direction.rearDemist = !direction.rearDemist;
		$system.hvac.fanDirection = direction;
	}.$bind(object);

	object._private.toggleAC = function () {
		if (!this._private.direction.enabled) {
			return;
		}
		var direction = this._private.direction;
		direction.ac = !direction.ac;
		$system.hvac.fanDirection = (direction);
	}.$bind(object);

	object._private.toggleRecirc = function () {
		var direction = this._private.direction;
		direction.recirc = !direction.recirc;
		$system.hvac.fanDirection = direction;
	}.$bind(object);

	object._private.setEnabled = function (enabled) {
		var asBool = enabled === true;
		var direction = this._private.direction;
		if (asBool !== direction.enabled) {
			direction.enabled = asBool;
			$system.hvac.fanDirection = (direction);
		}
	}.$bind(object);

	object._private.checkStyle = function () {
		var direction = $system.hvac.fanDirection;
		this._private.direction = direction;
		var flags = [direction.face, direction.feet, direction.frontDemist, direction.rearDemist, direction.ac];
		var obj = [this.dom.face, this.dom.feet, this.dom.frontDemist, this.dom.rearDemist, this.dom.ac];
		var canBeDisabled = [true, true, true, false, true];

		for (var i = 0; i < flags.length; ++i) {
			if (!direction.enabled && canBeDisabled[i]) {
				obj[i].style.backgroundColor = "";
				$ui.addClass(obj[i], "disabled");
			} else {
				$ui.removeClass(obj[i], "disabled");
				if (flags[i]) {
					$ui.addClass(obj[i], 'theme-brand-background-color');
				} else {
					$ui.removeClass(obj[i], 'theme-brand-background-color');
				}
			}
		}

		if (direction.recirc) {
			$ui.removeClass(this.dom.recirc, "fresh");
			$ui.addClass(this.dom.recirc, "recirc");
			$ui.removeClass(this.dom.recirc, 'theme-brand-background-color');
		} else {
			$ui.removeClass(this.dom.recirc, "recirc");
			$ui.addClass(this.dom.recirc, "fresh");
			$ui.addClass(this.dom.recirc, 'theme-brand-background-color');
		}
	}.$bind(object);

	object.dom.appendChild(object.dom.face = uiButton(["toggle theme-border-color", "top", "left", "face"], object._private.toggleFace,false));
	object.dom.appendChild(object.dom.feet = uiButton(["toggle theme-border-color", "mid", "left", "feet"], object._private.toggleFeet,false));
	object.dom.appendChild(object.dom.frontDemist = uiButton(["toggle theme-border-color", "bot", "left", "frontDemist"], object._private.toggleFrontDemist,false));
	object.dom.appendChild(object.dom.rearDemist = uiButton(["toggle theme-border-color", "top", "right", "rearDemist"], object._private.toggleRearDemist,true));
	object.dom.appendChild(object.dom.ac = uiButton(["toggle theme-border-color", "mid", "right", "ac"], object._private.toggleAC,false));
	object.dom.appendChild(object.dom.recirc = uiButton(["toggle theme-border-color", "bot", "right", "recirc"], object._private.toggleRecirc,true));

	object._private.checkStyle();

	object._private.onfanspeedchanged = function(event) {
		var enabled = event.data.fanSpeed !== 0;
		this._private.setEnabled(enabled);
	}.$bind(object);
	$ui.addEventListener("onfanspeedchanged",object._private.onfanspeedchanged);

	object._private.onfandirectionchanged = function(event) {
		this._private.checkStyle();
	}.$bind(object);
	$ui.addEventListener("onfandirectionchanged",object._private.onfandirectionchanged);

	object._destroy = function() {
		$ui.removeEventListener("onfanspeedchanged",this._private.onfanspeedchanged);
		$ui.removeEventListener("onfandirectionchanged",this._private.onfandirectionchanged);
	}.$bind(object);

	return object.dom;
}

/**
 * This button is used in the emulators {@link $ui.HVAC} controls for adjusting the fans<br><br>
 * <b>Sample Declaration</b><br>
 * <pre>
 * {
 *   value: $ui.HeadUnitChrome.Fans.AUTO,
 *   onclick: function() {
 *      // Do something
 *   }
 * }
 * @namespace FansButton
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {$ui.HeadUnitChrome.Fans} [value=$ui.HeadUnitChrome.Fans.AUTO] - The current settings for the fans
 * @property {GenericEvent} [onclick] - This will fire when a user clicks thefans button control
 */
function emulator_FansButton(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom,'feet');
	$ui.addClass(object.dom,'fans');
	
	// Set defaults
	if (object.value == undefined) {
		object.value = $ui.HeadUnitChrome.Fans.AUTO;
	}
	
	// Handle touch interaction
	object.dom.onclick = function() {
		$ui.playTouchSound();
		if (this.model.onclick) {
			this.model.onclick();
		}
	}
	object.dom.ontouchstart = function() {
		object.dom.style.opacity = 1;
	}
	object.dom.ontouchend = function() {
		object.dom.style.opacity = 0.5;
	}
	object.dom.ontouchcancel = object.dom.ontouchend;
	if (!$ui.isMobileDevice()) {
		object.dom.onmousedown = object.dom.ontouchstart;
		object.dom.onmouseup = object.dom.ontouchend;
		object.dom.onmouseleave = object.dom.ontouchend;
	}
	
	/**
	* Set the fans value property of the control
	* @function setValue
	* @memberof $ui.FansButton
	* @param {$ui.HeadUnitChrome.Fans} value - The value to set for the fans
	*/
	object.setValue = function(value) {
		var prevValue = (this.value == undefined) ? $ui.HeadUnitChrome.Fans.AUTO : this.value;
		if (value == undefined) value = $ui.HeadUnitChrome.Fans.AUTO;
		this.value = value;
		// Remove previous setting styling
		$ui.removeClass(this.dom,'emulator-icon-head-unit-fans-setting-'+prevValue);
		$ui.addClass(this.dom,'emulator-icon-head-unit-fans-setting-'+this.value);
	}
	object.setValue = object.setValue.$bind(object);
	
	// Check for defined fan setting
	if (object.value != undefined) {
		object.setValue(object.value);	
	}
	
	// We need to make the opacity show up based on a delay because
	// opacity can't animate when display changes from a previous state of none
	object._onshow = function(value) {
		setTimeout(this._timedOpacity,500);
	}
	object._onshow = object._onshow.$bind(object);
	
	// Make the button visible
	object._timedOpacity = function(value) {
		this.dom.style.opacity = '0.5';
	}
	object._timedOpacity = object._timedOpacity.$bind(object);

	object._onfandirectionchanged = function(event) {
		var styleToUse = "fan";

		$ui.removeClass(this.dom,"fan");
		$ui.removeClass(this.dom,"face");
		$ui.removeClass(this.dom,"feet");
		$ui.removeClass(this.dom,"frontDemist");

		if (event && event.data && event.data.fanDirection) {
			var data = event.data.fanDirection;
			if (!data.enabled) {
				styleToUse = "fan";
			} else if (data.face) {
				styleToUse = "face";
			} else if (data.feet) {
				styleToUse = "feet";
			} else {
				styleToUse = "frontDemist";
			}
		}

		$ui.addClass(this.dom,styleToUse);
	}.$bind(object);

	$ui.addEventListener("onfandirectionchanged",object._onfandirectionchanged);
	
	return object.dom;
}

/**
 * This core component draws a fan speed dial to 
 * allow tweaking the HVAC settings. It is not likely to be used directly.
 * @namespace FanSpeedControl
 * @memberof $ui
 * @extends $ui.CoreComponent
 */
function emulator_FanSpeedControl(object, screen) {
	$ui_CoreComponent.call(this,object,screen);

	object._private = {
		touched: false,
		rotation: -3000,
		fanSpeed: -6,
		oldRotation: -1
	};

	function touchStart() {
		this.style.opacity = "0.7";
	}

	function touchEnd() {
		this.style.opacity = "1";
	}

	function setEvents(o) {
		o.ontouchstart = touchStart;
		o.ontouchend = touchEnd;
		o.ontouchcancel = touchEnd;
		if (!$ui.isMobileDevice()) {
			o.onmousedown = touchStart;
			o.onmouseup = touchEnd;
			o.onmouseleave = touchEnd;
		}
	}

	function textButton(parent, klass, text) {
		var toReturn = document.createElement("div");
		$ui.addClass(toReturn, "text-button theme-text-color");
		$ui.addClass(toReturn, klass);
		toReturn.textContent = text;
		setEvents(toReturn);
		parent.appendChild(toReturn);
		return toReturn;
	}

	function addCircleEvents(o) {
		o.ontouchstart = object._private.circleTouchStart;
		o.ontouchmove = object._private.circleTouchMove;
		o.ontouchend = object._private.circleTouchEnd;
		o.ontouchcancel = object._private.circleTouchCancel;
		if (!$ui.isMobileDevice()) {
			o.onmousedown = object._private.circleTouchStart;
			o.onmousemove = object._private.circleTouchMove;
			o.onmouseup = object._private.circleTouchEnd;
			o.onmouseleave = object._private.circleTouchCancel;
		}
	}

	object._private.circleTouchStart = function (event) {
		$ui.playTouchSound();
		this._private.touched = true;
		this._private.touchStartedTime = new Date().getTime();
		this._private.oldRotation = this._private.rotation;
		this._private.oldTransition = this.dom.outerCircle.style.webkitTransition;
		this._private.circleTouchMove(event);
	}.$bind(object);

	object._private.circleTouchMove = function (event) {
		if (this._private.touched) {
			if (this._private.touchStartedTime && new Date().getTime() - this._private.touchStartedTime > 100) {
				this.dom.outerCircle.style.webkitTransition = "translate 0.1s";
				this._private.touchStartedTime = null;
			}
			var dx,dy;
			if (event.offsetX) {
				dx = event.offsetX - 200;
				dy = event.offsetY - 200;
			} else if (event.touches) {
				var touch = event.touches[0];
				var rect = this.dom.touchCircle.getBoundingClientRect();

				dx = touch.clientX - rect.left - 200;
				dy = touch.clientY - rect.top - 200;
			}
			 
			var tan;
			if (dy == 0) {
				if (dx > 0) {
					tan = 90;
				} else {
					tan = 270;
				}
			} else {
				tan = Math.atan(dx / dy) / 2 / Math.PI * 360;
				if (dx > 0 && dy > 0) {

				} else if (dy < 0 && dx > 0) {
					tan = 90 + (90 - -tan);
				} else if (dy < 0 && dy < 0) {
					tan = 180 + tan;
				} else if (dy > 0 && dx < 0) {
					tan = 270 + (90 - -tan);
				}
			}
			tan = 360 - tan;

			if (tan < 55 && tan > 30) {
				tan = 45;
			} else if (tan < 30) {
				tan = 0;
			} else if (tan > 330) {
				tan = 0;
			} else if (tan > 315 && tan < 345) {
				tan = 315;
			}

			this._private.setRotation(tan);
		}
	}.$bind(object);

	object._private.circleTouchEnd = function (event) {
		if (this._private.touched) {
			this._private.touched = false;
			this.dom.outerCircle.style.webkitTransition = this._private.oldTransition;

			var rotation = this._private.rotation;
			if (rotation == 0) {
				this.setFanSpeed(-1);
			} else {
				this.setFanSpeed((rotation - 45) / 270);
			}
		}
	}.$bind(object);

	object._private.circleTouchCancel = function (event) {
		if (this._private.touched) {
			this._private.touched = false;
			this.dom.outerCircle.style.webkitTransition = this._private.oldTransition;
			setTimeout(this._private.revertRotation, 150);
		}
	}.$bind(object);

	object._private.revertRotation = function () {
		if (!this._private.touched) {
			this._private.setRotation(this._private.oldRotation);
		}
	}.$bind(object);

	object.setFanSpeed = function (speed) {
		if (speed == -1 || speed >= 0 && speed <= 1) {
			if (speed != this._private.fanSpeed) {
				this._private.fanSpeed = speed;
				if (speed == -1) {
					this._private.setRotation(0);
				} else {
					var angle = 45 + speed * 270;
					this._private.setRotation(angle);
				}
				$system.hvac.fanSpeed = speed;
			}
		}
	}.$bind(object);

	object._private.setRotation = function (angle) {
		if (angle < 0) {
			angle = -angle;
			angle %= 360;
			angle = 360 - angle;
		}
		angle %= 360;
		if (this._private.rotation != angle) {
			this.dom.outerCircle.style.webkitTransform = "rotate(" + angle + "deg)";
			this.dom.fanOuterCircle.style.webkitTransform = "rotate(" + (angle * 0.1) + "deg)";
			this._private.rotation = angle;
		}
	}.$bind(object);
	
	$ui.addClass(object.dom, 'ui-fan-speed-control');

	object.dom.off = textButton(object.dom, "off", "Off");
	object.dom.auto = textButton(object.dom, "auto", "Auto");
	object.dom.max = textButton(object.dom, "max", "Max");

	object.dom.off.onclick = function () {
		$ui.playTouchSound();
		this.setFanSpeed(0);
	}.$bind(object);

	object.dom.auto.onclick = function () {
		$ui.playTouchSound();
		this.setFanSpeed(-1);
	}.$bind(object);

	object.dom.max.onclick = function () {
		$ui.playTouchSound();
		this.setFanSpeed(1);
	}.$bind(object);

	object.dom.outerCircle = document.createElement("div");
	$ui.addClass(object.dom.outerCircle, "outer-circle theme-border-color");
	object.dom.appendChild(object.dom.outerCircle);

	object.dom.innerCircle = document.createElement("div");
	$ui.addClass(object.dom.innerCircle, 'inner-circle theme-border-color');
	object.dom.outerCircle.appendChild(object.dom.innerCircle);

	object.dom.dot = document.createElement("div");
	$ui.addClass(object.dom.dot, "dot theme-border-color theme-brand-background-color");
	object.dom.outerCircle.appendChild(object.dom.dot);

	object.dom.fanOuterCircle = document.createElement("div");
	$ui.addClass(object.dom.fanOuterCircle, "fan-outer-circle theme-border-color");
	object.dom.appendChild(object.dom.fanOuterCircle);

	object.dom.fanInnerCircle = document.createElement("div");
	$ui.addClass(object.dom.fanInnerCircle, "fan-inner-circle theme-border-color");
	object.dom.fanOuterCircle.appendChild(object.dom.fanInnerCircle);

	object.dom.touchCircle = document.createElement("div");
	$ui.addClass(object.dom.touchCircle, "touch-circle");
	object.dom.appendChild(object.dom.touchCircle);
	addCircleEvents(object.dom.touchCircle);

	object.setFanSpeed($system.hvac.fanSpeed);

	return object.dom;
}

/**
 * The HVAC Interface is used with the {@link $ui.HeadUnitChrome} and provides and emulated interface of the HVAC controls of the vehicle.
 * <br><br><b>Sample Declaration</b>
 * <pre>
 * {
 *   driver: {
 *      temperature: {
 *          value: 75
 *      }
 *   },
 *   passenger: {
 *     temperature: {
 *          value: 73
 *      }
 *   },
 *   fans: {
 *      value: $ui.HeadUnitChrome.Fans.AUTO
 *   }
 *}
 * </pre>
 * @namespace HVAC
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {$ui.HVACSide} [driver] - Represents the driver side controls for the emulated HVAC interface
 * @property {$ui.HVACSide} [passenger] - Represents the driver side controls for the emulated HVAC interface
 * @property {$ui.FansButton} [fans] - Represents the HVAC fan settings
 */
function emulator_HVACBar(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom,'hvac theme-brand-border-color theme-screen-background-color');
	var dom;
	
	// Set driver defaults driver heat settings
	if (object.driver == undefined) {
		object.driver = {
			temperature: {
				value: 0, 
				side: 'left', 
				visible: false
			},
			seat: {
				value: 0,
				side: 'left',
				visible: false
			}
		}
	} else {
		if (object.driver.temperature == undefined) {
			object.driver.temperature = {
					value: 0, 
					visible: false
				}
		}
		if (object.driver.seat == undefined) {
			object.driver.seat = {
					value: 0, 
					visible: false
				}
		}
		object.driver.temperature.side = 'left';
		object.driver.seat.side = 'left';
	}
	// Create the driver temperature button
	dom = new emulator_TemperatureButton(object.driver.temperature, screen);
	object.dom.appendChild(dom);
	// Create the driver seat button
	dom = new emulator_SeatButton(object.driver.seat, screen);
	object.dom.appendChild(dom);
	
	// Create passenger heat settings
	if (object.passenger == undefined) {
		object.passenger = {
			temperature: {
				value: 0, 
				side: 'right', 
				visible: false
			},
			seat: {
				value: 0,
				side: 'right',
				visible: false
			}
		}
	} else {
		if (object.passenger.temperature == undefined) {
			object.passenger.temperature = {
					value: 0, 
					visible: false
				}
		} 
		if (object.passenger.seat == undefined) {
			object.passenger.seat = {
					value: 0, 
					visible: false
				}
		} 
		object.passenger.temperature.side = 'right';
		object.passenger.seat.side = 'right';
	}
	// Create passenger temperature button
	dom = new emulator_TemperatureButton(object.passenger.temperature, screen);
	object.dom.appendChild(dom);
	// Create the passenger seat button
	dom = new emulator_SeatButton(object.passenger.seat, screen);
	object.dom.appendChild(dom);
	
	// Create the rear defrost button
	if (object.showDefrostOnBar == true) {
		object._rearDefrost = {parent: object};
	} else {
		object._rearDefrost = {parent: object, visible: false};
	}
	dom = new emulator_DefrostButton(object._rearDefrost, screen);
	object.dom.appendChild(dom);
	
	// Create fan settings button
	if (object.fans) {
		object.fans.parent = object;
	} else {
		object.fans = {parent: object, visible: false};
	}
	dom = new emulator_FansButton(object.fans, screen);
	object.dom.appendChild(dom);
	
	// Get the height of the control
	object._getHeight = function() {
		if ($system.isClientDevice == true) return 60;
		return 120;
	}
	object._getHeight = object._getHeight.$bind(object);
	
	// If this is visible then make the primary window bottom align with the
	// top of this control
	object._setVisible = function(value) {
		this.screen._recalculateLayout();
	}
	object._setVisible = object._setVisible.$bind(object);
	object._setVisible(object.visible);
	
	return object.dom;
}

/**
 * Represents either a driver or passenger side of the vehicle for heat settings
 * @namespace HVACSide
 * @memberof $ui
 * @property {$ui.SeatButton} [seat] - Represents the temperature of the side of the car
 * @property {$ui.TemperatureButton} [temperature] - Represents the temperature of the side of the car
 */
 $ui.HVACSide = {};
/**
 * This screen is used to provide popup behaviour containing (many) HVAC
 * controls. It is unlikely to be used directly.
 * @namespace PopupHvac
 * @memberof $ui
 * @extends $ui.CoreScreen
 */
function emulator_PopupHvac(object, data) {
	if (object) {
		object.animated = false;
		object.floatOnTop = true;
	}
	$ui_CoreScreen.call(this,object,data);
	$ui.addClass(object.dom,"emulator-popup-hvac");

	object._protected.ontouchstart = function() {
		this.dom.doneSpan.style.opacity = 0.7;
	}.bind(object);

	object._protected.ontouchend = function() {
		if (this.dom && this.dom.doneSpan) {
			this.dom.doneSpan.style.opacity = "";
		}
	}.bind(object);

	object._protected.ondone = function(event) {
		event.stopPropagation();
		$ui.playTouchSound();
		$ui.pop();
	}.bind(object);

	// Done button
	object.dom.done = document.createElement("div");
	$ui.addClass(object.dom.done,"done theme-brand-background-color theme-text-color");
	object.dom.appendChild(object.dom.done);

	object.dom.done.onclick = object._protected.ondone;
	object.dom.onclick = object._protected.ondone;


	object.dom.done.ontouchstart = object._protected.ontouchstart;
	object.dom.done.ontouchend = object._protected.ontouchend;
	object.dom.done.ontouchcancel = object._protected.ontouchend;
	if (!$ui.isMobileDevice()) {
		object.dom.done.onmousedown = object._protected.ontouchstart;
		object.dom.done.onmouseleave = object._protected.ontouchend;
		object.dom.done.onmouseup = object._protected.ontouchend;
	}

	object.dom.doneSpan = document.createElement("span");
	object.dom.doneSpan.textContent = "Done";
	object.dom.done.appendChild(object.dom.doneSpan);

	object.dom.content = document.createElement("div");
	$ui.addClass(object.dom.content,"content theme-screen-background-color theme-border-color");
	object.dom.appendChild(object.dom.content);

	// Stop the main controls from also closing the screen...
	object.dom.content.onclick = function(event) {
		event.stopPropagation();
	};

	if (!object.fanDirection) {
		object.fanDirection = {};
	}
	object.fanDirection.parent = object;
	object.dom.content.appendChild(new emulator_FanDirectionControl(object.fanDirection,object));


	if (!object.fanSpeed) {
		object.fanSpeed = {};
	}
	object.fanSpeed.parent = object;
	object.dom.content.appendChild(new emulator_FanSpeedControl(object.fanSpeed,object));
	
	/** 
	 * Set the background for the screen
	 * @function setBackground
	 * @memberof $ui.WindowPane
	 * @param {ScreenBackground} screenBackground - The background object to use for the screen.
	 */
	object.setBackground = function(screenBackground) {
		if (screenBackground == undefined) {
			this.dom.content.style.backgroundImage = '';
		} else {
			this.dom.content.style.backgroundImage = 'url("'+ screenBackground.img + '")';
		}
	}.$bind(object);
	
	return object.dom;
}
/**
 * This button is used in the emulators {@link $ui.HVAC} controls for adjusting the heated seats. It can be used for either the Driver or Passenger controls
 * <br><br><b>Sample Declaration</b>
 * <pre>
 * {
 *   level: 2,
 *   maxLevel: 3,
 *   side: 'left',
 *   onclick: function() {
 *      // Do something
 *   }
 *}
 * </pre>
 * @namespace SeatButton
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {number} [level=0] - The numeric level that the heated seat. This cannot exceed the <b>maxLevel</b> property
 * @property {number} [maxLevel=0] - The numeric maximum level that the heated seat can reach
 * @property {string} [side=left] - The side in which the button should be displayed. This is either 'right' or 'left'.
 * @property {GenericEvent} [onclick] - This will fire when a user presses the seat button
 */
function emulator_SeatButton(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom,'seat');
	
	// Set the side of the display
	if (object.side != undefined) {
		$ui.addClass(object.dom,object.side);
	}
	
	// Make sure we have a default max levels
	if (object.maxLevel == undefined) {
		object.maxLevel = 0;
	}
	
	// Handle our clicks
	object.dom.onclick = function() {
		if (this.model.level == this.model.maxLevel) {
			this.model.setLevel(0);
		} else {
			this.model.setLevel(this.model.level + 1);
		}
		$ui.playTouchSound();
		if (this.model.onclick) {
			this.model.onclick();
		}
	}
	object.dom.ontouchstart = function() {
		$ui.addClass(this,'selected');
	}
	object.dom.ontouchend = function() {
		$ui.removeClass(this,'selected');
	}
	object.dom.ontouchcancel = object.dom.ontouchend;
	if (!$ui.isMobileDevice()) {
		object.dom.onmousedown = object.dom.ontouchstart;
		object.dom.onmouseup = object.dom.ontouchend;
		object.dom.onmouseleave = object.dom.ontouchend;
	}
	
	/**
	* Set the level to the value provided as a parameter
	* @memberof $ui.SeatButton
	* @function setLevel
	* @param {number} value - Numeric value to use for the <b>level</b> property
	*/
	object.setLevel = function(value) {
		var prevLevel = (this.level == undefined) ? 0 : this.level;
		if (value == undefined) value = 0;
		this.level = value;
		// Remove previous level styling
		$ui.removeClass(this.dom,'level-'+prevLevel);
		$ui.addClass(this.dom,'level-'+this.level);
	}
	object.setLevel = object.setLevel.$bind(object);
	
	// Check for defined seat level
	if (object.level != undefined) {
		object.setLevel(object.level);	
	}
	
	// We need to make the opacity show up based on a delay because
	// opacity can't animate when display changes from a previous state of none
	object._onshow = function(value) {
		setTimeout(this._timedOpacity,500);
	}
	object._onshow = object._onshow.$bind(object);
	
	// Make the button visible
	object._timedOpacity = function(value) {
		this.dom.style.opacity = '1.0';
	}
	object._timedOpacity = object._timedOpacity.$bind(object);
	
	return object.dom;
}

/**
 * This button is used in the emulators {@link $ui.HVAC} controls for adjusting the cabin temperature. It can be used for either the Driver or Passenger controls
 * <br><br><b>Sample Declaration</b>
 * <pre>
 * {
 *   value: 75,
 *   side: 'left',
 *   onclick: function() {
 *      $ui.push(wedgeDriverTemperature, {temperature: this.value});
 *   }
 * }
 * </pre>
 * @namespace TemperatureButton
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {number} value - The current temperature value
 * @property {string} [side=left] - The side in which the button should be displayed. This is either 'right' or 'left'.
 * @property {GenericEvent} [onclick] - This will fire when a user presses the temperature button
 */
function emulator_TemperatureButton(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom,'temperature theme-brand-text-color');
	
	// Set the side of the display
	if (object.side != undefined) {
		$ui.addClass(object.dom,object.side);
	}
	
	// Handle our clicks
	object.dom.onclick = function() {
		$ui.playTouchSound();
		if (this.model.onclick) {
			this.model.onclick();
		}
	}
	object.dom.ontouchstart = function() {
		$ui.removeClass(this,'theme-brand-text-color');
		$ui.addClass(this,'theme-text-color');
	}
	object.dom.ontouchend = function() {
		$ui.removeClass(this,'theme-text-color');
		$ui.addClass(this,'theme-brand-text-color');
	}
	object.dom.ontouchcancel = object.dom.ontouchend;
	if (!$ui.isMobileDevice()) {
		object.dom.onmousedown = object.dom.ontouchstart;
		object.dom.onmouseup = object.dom.ontouchend;
		object.dom.onmouseleave = object.dom.ontouchend;
	}
	
	// Set the temperature
	object.setTemperature = function(value) {
		this.value = value;
		var degree = ($system.isCelsius()) ? 'C' : 'F';
		this.dom.innerHTML = value+'<span class="small">&deg;'+degree+'</span>';
	}
	object.setTemperature = object.setTemperature.$bind(object);
	
	// Driver control decisions
	if (object.value) {
		object.setTemperature(object.value);	
	}
	
	return object.dom;
}
function emulator_NavigationBar(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom,'navigation theme-screen-background-color theme-brand-border-color');
	
	// Add our clock
	object.dom.clock = document.createElement('div');
	$ui.addClass(object.dom.clock,'clock theme-brand-text-color');
	object.dom.appendChild(object.dom.clock);
	object._updateClock = function() {
		var date = new Date(),
			hour = date.getHours(),
			min = date.getMinutes();
		hour = (hour > 12) ? (hour - 12) : hour;
		min = (min < 10) ? ('0' + min) : min;
		this.dom.clock.textContent = hour + ':' + min;	
	}
	object._updateClock = object._updateClock.$bind(object);
	window.setInterval(object._updateClock,10000); // update every 10 seconds
	object._updateClock();
	
	// Create the home line
	object.dom.homeLine = document.createElement('div');
	$ui.addClass(object.dom.homeLine,'line theme-light-background-color');
	$ui.addClass(object.dom.homeLine,'home');
	object.dom.appendChild(object.dom.homeLine);
	
	// Create the center line
	object.dom.centerLine = document.createElement('div');
	$ui.addClass(object.dom.centerLine,'line theme-light-background-color');
	$ui.addClass(object.dom.centerLine,'center');
	object.dom.appendChild(object.dom.centerLine);

	// Create the more line
	object.dom.moreLine = document.createElement('div');
	$ui.addClass(object.dom.moreLine,'line theme-light-background-color');
	$ui.addClass(object.dom.moreLine,'more');
	object.dom.appendChild(object.dom.moreLine);
	
	// Create our highlight dot
	object.dom.dot = document.createElement('div');
	$ui.addClass(object.dom.dot,'dot theme-brand-background-color');
	object.dom.appendChild(object.dom.dot);
	
	// Create the home button
	object.dom.homeBtn = document.createElement('div');
	object.dom.homeBtn.model = object;
	object._selectedButton = object.dom.homeBtn;
	$ui.addClass(object.dom.homeBtn,'circle-button theme-border-color');
	$ui.addClass(object.dom.homeBtn,'home');
	object.dom.appendChild(object.dom.homeBtn);
	object.dom.homeBtn.onclick = function() {
		if (this.model._selectedButton == this) return;
		this.model._selectedButton = this;
		if (this.model._chrome.isDualView || ($system.isClientDevice == true)) {
			this.model.dom.dot.style['-webkit-transform'] = 'translateX(0px)';
		} else {
			this.model.dom.dot.style['-webkit-transform'] = 'translateY(0px)';
		}
		this.model.dom.centerBtn._hide();
		// Clear out existing screens in the primary display
		this.model._chrome.primaryWindow.popToHome();
		$ui.playTouchSound();
	}
	
	// Create the center button
	object.dom.centerBtn = document.createElement('div');
	object.dom.centerBtn.model = object;
	object.dom.centerBtn._hidden = true;
	$ui.addClass(object.dom.centerBtn,'circle-button theme-border-color');
	$ui.addClass(object.dom.centerBtn,'center');
	object.dom.appendChild(object.dom.centerBtn);
	object.dom.centerBtn.onclick = function() {
		if (this._hidden === true) return;
		if (this.model._selectedButton == this) return;
		this.model._selectedButton = this;
		if (this.model._chrome.isDualView || ($system.isClientDevice == true)) {
			this.model.dom.dot.style['-webkit-transform'] = 'translateX('+(this.offsetLeft - this.model.dom.homeBtn.offsetLeft)+'px)';
		} else {
			this.model.dom.dot.style['-webkit-transform'] = 'translateY('+(this.offsetTop - this.model.dom.homeBtn.offsetTop)+'px)';
		}
		$ui.playTouchSound();
		this.model._chrome.primaryWindow.pop();
	}
	object.dom.centerBtn._hide = function() {
		this.model.dom.centerBtn.style.opacity = '0';
		this.model.dom.centerLine.style.opacity = '1.0';
		this._hidden = true;
	}
	object.dom.centerBtn._hide = object.dom.centerBtn._hide.$bind(object.dom.centerBtn);
	object.dom.centerBtn._show = function() {
		this.model.dom.centerBtn.style.opacity = '1.0';
		this.model.dom.centerLine.style.opacity = '0';
		this._hidden = false;
	}
	object.dom.centerBtn._show = object.dom.centerBtn._show.$bind(object.dom.centerBtn);

	// Create the more button
	object.dom.moreBtn = document.createElement('div');
	object.dom.moreBtn.model = object;
	$ui.addClass(object.dom.moreBtn,'circle-button theme-border-color');
	$ui.addClass(object.dom.moreBtn,'more');
	object.dom.appendChild(object.dom.moreBtn);
	object.dom.moreBtn.onclick = function() {
		if (this.model._selectedButton == this) return;
		this.model._selectedButton = this;
		if (this.model._chrome.isDualView || ($system.isClientDevice == true)) {
			this.model.dom.dot.style['-webkit-transform'] = 'translateX('+(this.offsetLeft - this.model.dom.homeBtn.offsetLeft)+'px)';
		} else {
			this.model.dom.dot.style['-webkit-transform'] = 'translateY('+(this.offsetTop - this.model.dom.homeBtn.offsetTop)+'px)';
		}
		$ui.playTouchSound();
		if (this.model._chrome && this.model._chrome.onsettingsclick) {
			this.model._chrome.onsettingsclick();
		}
	}
	
	// This will re-layout the control based on screen dimensions
	object._recalculateLayout = function() {
		if (this._chrome.isDualView || ($system.isClientDevice == true)) {
			var leftThreshold = this.dom.homeBtn.offsetLeft + this.dom.homeBtn.offsetWidth,
				rightThreshold = this.dom.moreBtn.offsetLeft,
				center = Math.floor((rightThreshold - leftThreshold)/2),
				centerLeft;
			// Adjust our center button
			centerLeft = (rightThreshold - center - Math.floor(this.dom.centerBtn.offsetWidth/2));
			this.dom.centerBtn.style.left = centerLeft + 'px';
			// Adjust our lines
			this.dom.homeLine.style.width = (centerLeft - leftThreshold + 2) + 'px';
			this.dom.moreLine.style.width = (rightThreshold - centerLeft - this.dom.centerBtn.offsetHeight + 2) + 'px';
			// Update our dot position
			this.dom.dot.style['-webkit-transform'] = 'translateX('+(this._selectedButton.offsetLeft - this.dom.homeBtn.offsetLeft)+'px)';	
		} else {
			var topThreshold = this.dom.homeBtn.offsetTop + this.dom.homeBtn.offsetHeight,
				bottomThreshold = this.dom.moreBtn.offsetTop,
				center = Math.floor((bottomThreshold - topThreshold)/2),
				centerTop;
			// Adjust our center button
			centerTop = (bottomThreshold - center - Math.floor(this.dom.centerBtn.offsetHeight/2));
			this.dom.centerBtn.style.top = centerTop + 'px';
			// Adjust our lines
			this.dom.homeLine.style.height = (centerTop - topThreshold) + 'px';
			this.dom.moreLine.style.height = (bottomThreshold - centerTop - this.dom.centerBtn.offsetHeight) + 'px';
			// Update our dot position
			this.dom.dot.style['-webkit-transform'] = 'translateY('+(this._selectedButton.offsetTop - this.dom.homeBtn.offsetTop)+'px)';
		}
	}
	object._recalculateLayout = object._recalculateLayout.$bind(object);
	
	// Clean up any pointers
	object._onresize = function() {
		this._recalculateLayout();
	}
	object._onresize = object._onresize.$bind(object);
	
	// Get the height of the control
	object._getHeight = function() {
		if ($system.isClientDevice == true) {
			return 86
		} else if (window.innerHeight > window.innerWidth) {
			return 126;
		}
		return 150;
	}
	object._getHeight = object._getHeight.$bind(object);
	
	// Assign the middle navigation menu to the window pane provided
	object._setNavigationMenu = function(appContainer) {
		if (this.dom.centerBtn._appContainer == appContainer) return;
		this.dom.centerBtn._hidden = false;
		this.dom.centerBtn.style.opacity = '1.0';
		this.dom.centerBtn._appContainer = appContainer;
		// Set our icon
		this.dom.centerBtn.style.backgroundImage = 'url("'+appContainer.icon+'")'; 
		this.dom.centerLine.style.opacity = '0';
		this._selectedButton = this.dom.centerBtn
		if (this._chrome.isDualView || ($system.isClientDevice == true)) {
			this.dom.dot.style['-webkit-transform'] = 'translateX('+(this.dom.centerBtn.offsetLeft - this.dom.homeBtn.offsetLeft)+'px)';
		} else {
			this.dom.dot.style['-webkit-transform'] = 'translateY('+(this.dom.centerBtn.offsetTop - this.dom.homeBtn.offsetTop)+'px)';
		}
	}
	object._setNavigationMenu = object._setNavigationMenu.$bind(object);

	// Immediately redraw the control
	setTimeout(object._recalculateLayout,0);
	return object.dom;
}
/* Used with the Chrome App */
function emulator_TitleBar(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	if (object) {
		$ui.addClass(object.dom,'emulator-title-bar theme-brand-border-color');
		
		// Create the button bar area
		object.dom.buttonBar = document.createElement('div');
		$ui.addClass(object.dom.buttonBar, 'button-bar');
		object.dom.appendChild(object.dom.buttonBar);
		
		// Create phone button
		object.dom.sizePhone = document.createElement('div');
		object.dom.sizePhone.model = object;
		$ui.addClass(object.dom.sizePhone, 'button');
		object.dom.buttonBar.appendChild(object.dom.sizePhone);
		object.dom.sizePhone.outline = document.createElement('div');
		$ui.addClass(object.dom.sizePhone.outline, 'outline theme-dark-border-color theme-text-color sizePhone');
		object.dom.sizePhone.appendChild(object.dom.sizePhone.outline);
		object.dom.sizePhone.speaker = document.createElement('div');
		$ui.addClass(object.dom.sizePhone.speaker,'speaker');
		object.dom.sizePhone.outline.appendChild(object.dom.sizePhone.speaker);
		object.dom.sizePhone.screen = document.createElement('div');
		$ui.addClass(object.dom.sizePhone.screen,'screen');
		object.dom.sizePhone.outline.appendChild(object.dom.sizePhone.screen);
		object.dom.sizePhone.homeButton = document.createElement('div');
		$ui.addClass(object.dom.sizePhone.homeButton,'homeButton');
		object.dom.sizePhone.outline.appendChild(object.dom.sizePhone.homeButton);
		object.dom.sizePhone.phoneText = document.createElement('div');
		object.dom.sizePhone.phoneText.textContent = 'Phone'
		$ui.addClass(object.dom.sizePhone.phoneText,'phoneText theme-highlight-text-color');
		object.dom.sizePhone.appendChild(object.dom.sizePhone.phoneText);
		object.dom.sizePhone.onclick = function() {
			this.model.parent._setResolution('375x667');
		}
		
		// Create 7 inch button
		object.dom.size7 = document.createElement('div');
		object.dom.size7.model = object;
		$ui.addClass(object.dom.size7, 'button');
		object.dom.buttonBar.appendChild(object.dom.size7);
		object.dom.size7.outline = document.createElement('div');
		$ui.addClass(object.dom.size7.outline, 'outline theme-dark-border-color theme-text-color size7');
		object.dom.size7.appendChild(object.dom.size7.outline);
		object.dom.size7.outline.textContent = '7';
		object.dom.size7.onclick = function() {
			this.model.parent._setResolution('1024x600');
		}
		
		// Create 10.1 inch portrait
		object.dom.size10portrait = document.createElement('div');
		object.dom.size10portrait.model = object;
		$ui.addClass(object.dom.size10portrait, 'button');
		object.dom.buttonBar.appendChild(object.dom.size10portrait);
		object.dom.size10portrait.outline = document.createElement('div');
		$ui.addClass(object.dom.size10portrait.outline, 'outline theme-text-color size10portrait');
		object.dom.size10portrait.appendChild(object.dom.size10portrait.outline);
		$ui.addClass(object.dom.size10portrait.outline,'theme-brand-border-color');
		object.dom.size10portrait.outline.textContent = '10.1';
		object.dom.size10portrait.onclick = function() {
			this.model.parent._setResolution('800x1280');
		}
		
		// Create 10.1 inch landscape
		object.dom.size10landscape = document.createElement('div');
		object.dom.size10landscape.model = object;
		$ui.addClass(object.dom.size10landscape, 'button');
		object.dom.buttonBar.appendChild(object.dom.size10landscape);
		object.dom.size10landscape.outline = document.createElement('div');
		$ui.addClass(object.dom.size10landscape.outline, 'outline theme-dark-border-color theme-text-color size10landscape');
		object.dom.size10landscape.appendChild(object.dom.size10landscape.outline);
		object.dom.size10landscape.outline.textContent = '10.1';
		object.dom.size10landscape.onclick = function() {
			this.model.parent._setResolution('1280x800');
		}

		object.highlightButtons = function() {
			var size = object.parent._getResolution();
			$ui.removeClass(this.dom.size7.outline,'theme-brand-border-color');
			$ui.removeClass(this.dom.size10portrait.outline,'theme-brand-border-color');
			$ui.removeClass(this.dom.size10landscape.outline,'theme-brand-border-color');
			$ui.removeClass(this.dom.sizePhone.outline,'theme-brand-border-color');
			
			$ui.addClass(this.dom.size7.outline,'theme-dark-border-color');
			$ui.addClass(this.dom.size10portrait.outline,'theme-dark-border-color');
			$ui.addClass(this.dom.size10landscape.outline,'theme-dark-border-color');
			$ui.addClass(this.dom.sizePhone.outline,'theme-dark-border-color');

			if (size === "1024x600") {
				$ui.removeClass(this.dom.size7.outline,'theme-dark-border-color');
				$ui.addClass(this.dom.size7.outline,'theme-brand-border-color');
			} else if (size === "800x1280") {
				$ui.removeClass(this.dom.size10portrait.outline,'theme-dark-border-color');
				$ui.addClass(this.dom.size10portrait.outline,'theme-brand-border-color');
			} else if (size === "1280x800") {
				$ui.removeClass(this.dom.size10landscape.outline,'theme-dark-border-color');
				$ui.addClass(this.dom.size10landscape.outline,'theme-brand-border-color');
			} else if (size === "375x667") {
				$ui.removeClass(this.dom.sizePhone.outline,'theme-dark-border-color');
				$ui.addClass(this.dom.sizePhone.outline,'theme-brand-border-color');
			}
		}.$bind(object);

		return object.dom;
	}
}

/**
 * This screen is used in the emulators {@link $ui.HVAC} controls for adjusting the cabin temperature. It can be used for either the Driver or Passenger controls
 * <br><br><b>Sample Declaration</b>
 * <pre>
 * function myTemperatureWedge() {
 *    this.component = $ui.WedgeNumber;
 *    this.direction = $ui.WedgeNumber.RIGHT;
 *    this.onchange = function() {
 *        // Do something
 *    }
 * }
 * </pre>
 * @namespace WedgeNumber
 * @memberof $ui
 * @extends $ui.CoreWedgeScreen
 * @property {number} value - The numeric value to show in the control
 * @property {number} [min] - The minimum value that can be set
 * @property {number} [max] - The maximum value that can be set
 * @property {$ui.WedgeNumber.Direction} [direction=$ui.WedgeNumber.Direction.LEFT] - The side in which the wedge should be displayed.
 * @property {NumberChangeEvent} [onchange] - This will fire when a user changes the value
 */
function emulator_WedgeNumber(object, data) {
	emulator_CoreWedgeScreen.call(this, object, data);
	$ui.addClass(object.dom,'emulator-wedge-number');
	
	// Create our temperature box
	object.dom.box = document.createElement('div');
	$ui.addClass(object.dom.box,'box');
	object.dom.wedge.appendChild(object.dom.box);
	
	var dom,
		degrees = object._degrees;
	if (object._isRightToLeft != true) {
		degrees = '-' + degrees;
	}
	object.dom.box.style['-webkit-transform'] = 'rotate('+degrees+'deg)'
		
	// Increase Number
	object._increaseNumber = function() {
		if (this.onspinnerpress) {
			return;
		}
		var orig = this.value;
		this.value = this.value + 1;
		if (orig != this.value) {
			if (this.onchange) {
				this.onchange();
			}
		}
	}.$bind(object);	
		
	// Decrease Number
	object._decreaseNumber = function() {
		if (this.onspinnerpress) {
			return;
		}
		var orig = this.value;
		this.value = this.value - 1;
		if (orig != this.value) {
			if (this.onchange) {
				this.onchange();
			}
		}
	}.$bind(object);

	object._upPressed = function(pressed) {
		if (this.onspinnerpress) {
			this.onspinnerpress(+1,pressed);
		}
	}.$bind(object);

	object._downPressed = function(pressed) {
		if (this.onspinnerpress) {
			this.onspinnerpress(-1,pressed);
		}
	}.$bind(object);
		
	// Create the up button
	object._upButton = {direction: 'up', onclick: object._increaseNumber, onpressed: object._upPressed};
	dom = new emulator_WedgeNumberButton(object._upButton, object);
	object.dom.box.appendChild(dom);
	
	// Create the down button
	object._downButton = {direction: 'down', onclick: object._decreaseNumber, onpressed: object._downPressed};
	dom = new emulator_WedgeNumberButton(object._downButton, object);
	object.dom.box.appendChild(dom);
	
	// Create the display area
	object.dom.display = document.createElement('div');
	$ui.addClass(object.dom.display, 'display theme-text-color');
	object.dom.box.appendChild(object.dom.display);

	// value Property
	if (object.value == undefined) {
		object.value = 0;
	}
	object.dom.display.textContent = object.value;
	object._protected.value = object.value;
	Object.defineProperty(object, 'value', {
		get: function() {return this._protected.value;},
		set: function(value) {
			if (value == undefined) value = 0;
			if (value == this._protected.value) return;
			if (this.min != undefined) {
				if (value < this.min) return;
			}
			if (this.max != undefined) {
				if (value > this.max) return;
			}
			this._protected.value = value;
			this.dom.display.textContent = value;
		},
		configurable: false}
	);
	
	// min Property
	object._protected.min = object.min;
	Object.defineProperty(object, 'min', {
		get: function() {return this._protected.min;},
		set: function(value) {
			if (value == undefined) value = 0;
			if (value == this._protected.min) return;
			this._protected.min = value;
		},
		configurable: false}
	);
	
	// max Property
	object._protected.max = object.max;
	Object.defineProperty(object, 'max', {
		get: function() {return this._protected.max;},
		set: function(value) {
			if (value == undefined) value = 0;
			if (value == this._protected.max) return;
			this._protected.max = value;
		},
		configurable: false}
	);
	
	return object.dom;
}

/**
 * The {@link $ui.WedgeNumber} <b>onchange</b> event will fire when the user interacts with a number button
 * @callback NumberChangeEvent
 * @param {number} value - The value that was just set
 */
function emulator_WedgeNumberButton(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	$ui.addClass(object.dom,'button');
	
	// Set the side of the display
	if (object.direction != undefined) {
		$ui.addClass(object.dom,object.direction);
	} else {
		$ui.addClass(object.dom,'up');
	}
	
	// Add our arrow
	object.dom.arrow = document.createElement('div');
	$ui.addClass(object.dom.arrow,'arrow');
	object.dom.appendChild(object.dom.arrow);
	
	// Handle our clicks
	object.dom.onclick = function() {
		$ui.playTouchSound();
		if (this.model.onclick) {
			this.model.onclick();
		}
	}

	Object.defineProperty(object,"pressed", { 
		get: function() {
			console.log("Getting...");
			return this._pressed;

		}.$bind(object),
		set: function(pressed) {
			console.log("Pressing...");
			if (this._pressed != pressed) {
				this._pressed = pressed;
				if (this.onpressed) {
					this.onpressed(this._pressed);
				}
			}
		}.$bind(object)
	});

	object.dom.ontouchstart = function() {
		this.pressed = true;
		this.dom.style.opacity = '0.5';
	}.$bind(object);

	object.dom.ontouchend = function() {
		this.pressed = false;
		this.dom.style.opacity = '';
	}.$bind(object);

	object.dom.ontouchcancel = object.dom.ontouchend;

	if (!$ui.isMobileDevice()) {
		object.dom.onmousedown = object.dom.ontouchstart;
		object.dom.onmouseup = object.dom.ontouchend;
		object.dom.onmouseleave = object.dom.ontouchend;
	}
	
	return object.dom;
}
/**
 * This object represents a windowed area in a {@link $ui.HeadUnitChrome} screen. A Window is an internal display area of a HeadUnitChrome control that can show one or more {@link $ui.WindowPane} or 
 * {@link $ui.AppContainer} objects.
 * @namespace Window
 * @memberof $ui
 * @extends $ui.CoreComponent
 * @property {$ui.WindowPane} [windowPane] - The initial WindowPane to load into this windowed area
 * @property {object} [manifest] - The manifest of the application to open in this windowed area.
 * @property {boolean} [secondary=false] - Determines if this is a secondary window area or not so that it doesn't update the navigation menu
 */
function emulator_Window(object, screen) {
	$ui_CoreComponent.call(this, object, screen);
	if (object) {
		$ui.addClass(object.dom,'emulator-window theme-screen-background-color');
		
		object.screens = [];
		
		// secondary Property
		if (object.secondary != true) {
			object.secondary = false;
		}
		object._protected.secondary = object.secondary;
		Object.defineProperty(object, 'secondary', {
			get: function() {return this._protected.secondary;},
			set: function() {
				console.log($ui._protected.PROPERTY_WARNING.replace('[prop]','secondary'));
			},
			configurable: false}
		);
		
		/**
		* This function will push a new window pane onto the stack for display inside the Windowed area
		* @function push
		* @memberof $ui.Window
		* @param {$ui.WindowPane} windowPane - Window to push onto the stack
		* @param {object} data - Data to be passed to the new window
		*/
		object.push = function(screen, data) {
			screen = new screen();
			screen.container = this;
			screen.chrome = this.parent;
			if (!screen.width) {
				screen.width = this.dom.offsetWidth;
			}
			if (screen.component == $ui.AppContainer) {
				var dom = new emulator_AppContainer(screen, data);
			} else if (screen.component == $ui.WindowPane) {
				var dom = new $ui_WindowPane(screen, data);
			} else {
				return;
			}
			this.screens.push(screen);
			// See if we have an icon to set
			if (screen.icon && (this.secondary == false)) {
				this.screen._setNavigationMenu(screen); // this.screen is the HeadUnitChrome
			}
			this.dom.appendChild(dom);
			screen.initialize();
		}.$bind(object);
	
	
		/**
		* This will pop/destroy all of the screens stacked in this window except the first one
		* @function popToHome
		* @memberof $ui.Window
		*/
		object.popToHome = function() {
			if (this.screens.length <= 1) return;
			$ui.inScreenTransition = true;
			$ui._blockAllTapEvent(true);
			this.screens[0].dom.style.visibility = '';
			if (this.screens.length > 1) {
				var screen = this.screens[this.screens.length - 1];
				// Let the top most screen know it is going to be popped
				if (screen.onbeforepop) {
					screen.onbeforepop();
				}
			}
			setTimeout(this._popToHome, 0);
		}.$bind(object);
		
		/**
		* This will pop the topmost screen in this window stack
		* @function popToHome
		* @memberof $ui.Window
		*/
		object.pop = function() {
			if (this.screens.length <= 1) return;
			$ui.inScreenTransition = true;
			$ui._blockAllTapEvent(true);
			this.screens[this.screens.length-2].dom.style.visibility = '';
			if (this.screens.length > 1) {
				var screen = this.screens[this.screens.length - 1];
				// Let the top most screen know it is going to be popped
				if (screen.onbeforepop) {
					screen.onbeforepop();
				}
			}
			setTimeout(this._pop, 0);
		}.$bind(object);
		
		// Internal function to do the dirty work of the pop
		object._pop = function() {
			if (this.screens.length <= 1) return;
			var screen = this.screens[this.screens.length-1];
			this._removeScreen(screen);
			$ui.inScreenTransition = false;
			$ui._blockAllTapEvent(false);
		}.$bind(object);
		
		// Internal function to do the dirty work after the root page has been re-drawn
		object._popToHome = function() {
			if (this.screens.length <= 1) return;
			var i,
				screen;
			// Take the top most screen and animate out it as long as animation is not disabled
			screen = this.screens[this.screens.length-1];
			this._removeScreen(screen);
			$ui.inScreenTransition = false;
			$ui._blockAllTapEvent(false);
			// Remove all the middle screens
			for (i = this.screens.length - 1; i > 0; i--) {
				this._removeScreen(this.screens[i]);
			}
		}.$bind(object);
		
		// Remove the screen from the dom and the array
		object._removeScreen = function(screen) {
			screen.dom.style.display = 'none';
			this.dom.removeChild(screen.dom);
			// Remove any global event listeners for the application
			if (screen._appId != undefined) {
				$system.unregisterApp(screen._appId);
			}
			screen.destroy();
			this.screens.pop();
		}.$bind(object);
		
	
		// Dispatch the resize event to nested screens
		object._resizeListener = function() {
			// Fire any screen resize events needed
			var i, 
				screen;
			for (i = 0; i < this.screens.length; i++) {
				screen = this.screens[i];
				// Run internal resize
				if (screen._onresize) {
					screen._onresize();
				}
				// Run internal Window pane resize
				if (screen._onwindowpaneresize) {
					screen._onwindowpaneresize();
				}
				// Fire the screen's public event
				if (screen.onresize) {
					screen.onresize();
				}
			}
		}.$bind(object);
		window.addEventListener('resize', object._resizeListener, false);
		
		// Handle cleanup
		object._destroy = function() {
			window.removeEventListener('resize', this._resizeListener);
		}.$bind(object);
		
		// Handle theme changes
		object._onthemechange = function() {
			var i,
				screen;
			for (i = 0; i < this.screens.length; i++) {
				screen = this.screens[i];
				if (screen._onthemechange) {
					screen._onthemechange();
				}
			}
		}.$bind(object);
		
		if (object.windowPane) {
			// We open on another thread so that the root HeadUnitChrome has been inserted into the DOM
			setTimeout(function(){
				object.push(object.windowPane);
			},0);
		} else if (object.manifest) {
			// We open on another thread so that the root HeadUnitChrome has been inserted into the DOM
			setTimeout(function(){
				$core.openApp(object.manifest, object);
			},0);
		}
		
		return object.dom;
	}
}

